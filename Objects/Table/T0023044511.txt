OBJECT Table 23044511 IWX Event Param
{
  OBJECT-PROPERTIES
  {
    Date=02/25/21;
    Time=[ 2:19:53 PM];
    Modified=Yes;
    Version List=IWX2.4.7684.0;
  }
  PROPERTIES
  {
    DataPerCompany=No;
    CaptionML=[ENU=IWX Event Param;
               ESM=IWX Evento Param;
               FRC=IWX êvÇnement Param;
               ENC=IWX Event Param];
  }
  FIELDS
  {
    { 1   ;   ;Key                 ;Text50        ;CaptionML=[ENU=Key;
                                                              ESM=Clave;
                                                              FRC=ClÇ;
                                                              ENC=Key];
                                                   NotBlank=Yes }
    { 2   ;   ;Value               ;Text250       ;CaptionML=[ENU=Value;
                                                              ESM=Valor;
                                                              FRC=Valeur;
                                                              ENC=Value] }
    { 1000;   ;Event               ;Integer       ;CaptionML=[ENU=Event;
                                                              ESM=Evento;
                                                              FRC=ÇvÇnement;
                                                              ENC=Event] }
    { 1001;   ;Output Blob         ;BLOB          ;CaptionML=[ENU=Output Blob;
                                                              ESM=Blob de salida;
                                                              FRC=NumÇro de ligne de la plaque d'immatriculation parent;
                                                              ENC=Output Blob] }
    { 1002;   ;Output Text         ;Text250       ;CaptionML=[ENU=Output Text;
                                                              ESM=Texto de salida;
                                                              FRC=Texte de sortie;
                                                              ENC=Output Text] }
    { 1003;   ;Output Integer      ;Integer       ;CaptionML=[ENU=Output Integer;
                                                              ESM=Entero de salida;
                                                              FRC=Nombre entier de sortie;
                                                              ENC=Output Integer] }
    { 1004;   ;Output Decimal      ;Integer       ;CaptionML=[ENU=Output Decimal;
                                                              ESM=Decimal de salida;
                                                              FRC=DÇcimal de sortie;
                                                              ENC=Output Decimal] }
    { 1005;   ;Output Date         ;Date          ;CaptionML=[ENU=Output Date;
                                                              ESM=Fecha de salida;
                                                              FRC=Date de sortie;
                                                              ENC=Output Date] }
    { 1006;   ;Output Boolean      ;Boolean       ;CaptionML=[ENU=Output Boolean;
                                                              ESM=Salida booleana;
                                                              FRC=BoolÇen de sortie;
                                                              ENC=Output Boolean] }
    { 1007;   ;Output RecordID     ;RecordID      ;CaptionML=[ENU=Output RecordID;
                                                              ESM=ID de registro de salida;
                                                              FRC=RecordID de sortie;
                                                              ENC=Output RecordID] }
    { 1010;   ;Extensibility Event ;Option        ;CaptionML=[ENU=Extensibility Event;
                                                              ESM=extensibilidad Evento;
                                                              FRC=ÇvÇnement d'ExtensibilitÇ;
                                                              ENC=Extensibility Event];
                                                   OptionString=,,,OnPrint,,,OnBeforeProcessEvent,,,OnAfterProcessEvent,,,OnAssignLP,,,OnBeforeModify,,,OnChangeTracking,,,OnSetup,,,OnRemoveUsage,,,OnReportRun }
    { 1020;   ;Extensibility Blob  ;BLOB          ;CaptionML=[ENU=Extensibility Blob;
                                                              ESM=extensibilidad Blob;
                                                              FRC=ExtensibilitÇ Blob;
                                                              ENC=Extensibility Blob] }
  }
  KEYS
  {
    {    ;Key                                     ;Clustered=Yes }
  }
  FIELDGROUPS
  {
  }
  CODE
  {
    VAR
      tcInvalidValueForKey@1000000000 : TextConst 'ENU=The value [%1] is invalid for field [%2]';
      recLocation@1000000002 : Record 14;
      recSalesLine@1000000003 : Record 37;
      recTransferLine@1000000004 : Record 5741;
      recPurchaseLine@1000000005 : Record 39;
      recItemJournalLine@1000000007 : Record 83;
      recTransferHeader@1000000008 : Record 5740;
      cuWHICommon@1000000001 : Codeunit 23044501;
      tcInvalidDateTime@1000000006 : TextConst 'ENU=The value [%1] is an invalid datetime.';
      recLicensePlateLine@1000000012 : Record 23044506;
      recLPLineUsage@1000000009 : Record 23044507;

    PROCEDURE getDocumentNo@1000000006() ltxtOut : Text[250];
    BEGIN
      // Introduced for standardization.
      // doc_num is the chosen standard, the other options are for backwards compatibility
      // for patches with previous releases of IWX
      ltxtOut := getValue('doc_num');
      IF ( '' = ltxtOut ) THEN BEGIN
        ltxtOut := getValue('doc_number');
      END;
      IF ( '' = ltxtOut ) THEN BEGIN
        ltxtOut := getValue('doc_no');
      END;
      IF ( '' = ltxtOut ) THEN BEGIN
        ltxtOut := getValue('document_number');
      END;
      IF ( '' = ltxtOut ) THEN BEGIN
        ltxtOut := getValue('Doc No.');
      END;
      IF ( '' = ltxtOut ) THEN BEGIN
        ltxtOut := getValue('Document No.');
      END;
      IF ( '' = ltxtOut ) THEN BEGIN
        ltxtOut := getValue('No.');
      END;
      IF ( '' = ltxtOut ) THEN BEGIN
        ltxtOut := getValue('po_number');
      END;
    END;

    PROCEDURE getLegacyDocumentNo@1000000046(ptxtLegacyKey@1000000000 : Text) ltxtOut : Text[250];
    BEGIN
      //
      // Only use this for backwards compatiblity scenarios.
      // This will first check for the standard document number, and only if not
      // found, will it use the override.
      // Use this for upgrades that still depend on sales_number,transfer_number.
      // DO NOT use this for new code that you are introducing.
      //
      IF ( ptxtLegacyKey <> '' ) THEN BEGIN   // check for blank in case of programmer error.
        ltxtOut := getValue( ptxtLegacyKey );
      END;

      IF ( '' = ltxtOut ) THEN BEGIN
        ltxtOut := getDocumentNo();
      END;
    END;

    PROCEDURE setDocumentNo@1000000007(ptxtDocumentNo@1000000000 : Text[250]);
    BEGIN
      // Introduced for standardization.
      //
      // The set is in place to provide backwards compatibility for
      // hotfixes for specific clients, and previous versions.
      //
      setValue('doc_num', ptxtDocumentNo );
      setValue('doc_number', ptxtDocumentNo );
      setValue('doc_no', ptxtDocumentNo );
      setValue('document_number', ptxtDocumentNo );
      setValue('Doc No.', ptxtDocumentNo );
      setValue('Document No.', ptxtDocumentNo );

      //setValue('No.', ptxtDocumentNo );
      // Although 'No.' is sometimes used is previous releases of
      // IWX for a document no, it is also used as an item no.
      // or for other purposes, and is thus not safe for
      // generalizing across the board.
      //getValue('No.');
    END;

    PROCEDURE getItemNo@1000000037() ltxtOut : Text;
    BEGIN
      // Introduced for standardization.

      ltxtOut := getValue('item_number'); // this can occur from older devices, as well as
                                          // non menu driven item actions.
      IF ( '' = ltxtOut ) THEN BEGIN
        ltxtOut := getValue('Item No.');  // typically on warehouse driven tables.
      END;

      IF ( '' = ltxtOut ) THEN BEGIN
        ltxtOut := getValue('Reserve.ItemNumber');  // workflow
      END;


      IF ( '' = ltxtOut ) THEN BEGIN
        ltxtOut := getValue('No.'); // typically on non-warehouse driven tables
                                    // try this last as No. is generic and could be
                                    // also a document number.
      END;
    END;

    PROCEDURE getVariant@1000000047() ltxtOut : Text;
    BEGIN
      ltxtOut := getValue('variant_code'); // this can occur from older devices, as well as
                                           // non menu driven item actions.
      IF ( '' = ltxtOut ) THEN BEGIN
        ltxtOut := getValue('barcode.VariantCode');  // workflow screens from a barcode
      END;


      IF ( '' = ltxtOut ) THEN BEGIN
        ltxtOut := getValue('Variant Code');  // typical name on a field
      END;
      IF ( '' = ltxtOut ) THEN BEGIN
        ltxtOut := getValue('variant');  // legacy
      END;
      IF ( '' = ltxtOut ) THEN BEGIN
        ltxtOut := getValue('variant code');  // legacy #2
      END;
    END;

    PROCEDURE getLotNo@1000000041() ltxtOut : Text[250];
    BEGIN
      ltxtOut := getValue('lot_number'); // this can occur from older devices, as well as
                                          // non menu driven item actions.
      IF ( '' = ltxtOut ) THEN BEGIN
        ltxtOut := getValue('Lot No.');  // typically on warehouse driven tables.
      END;

      IF ( '' = ltxtOut ) THEN BEGIN
        ltxtOut := getValue('Lot');  // found on custom tables
      END;

      IF ( '' = ltxtOut ) THEN BEGIN
        ltxtOut := getValue('lot_no');  // legacy (very old) scanners
      END;

      IF ( '' = ltxtOut ) THEN BEGIN
        ltxtOut := getValue('Reserve.LotNumber');  // workflow
      END;


      IF ( '' = ltxtOut ) THEN BEGIN
        ltxtOut := getValue('Lot No');  // more custom tables, no period
      END;

      ltxtOut := UPPERCASE(ltxtOut);
    END;

    PROCEDURE getSerialNo@1000000044() ltxtOut : Text[250];
    BEGIN
      ltxtOut := getValue('serial_number'); // this can occur from older devices, as well as
                                            // non menu driven item actions.
      IF ( '' = ltxtOut ) THEN BEGIN
        ltxtOut := getValue('Serial No.');  // typically on warehouse driven tables.
      END;
      IF ( '' = ltxtOut ) THEN BEGIN
        ltxtOut := getValue('serial');
      END;

      IF ( '' = ltxtOut ) THEN BEGIN
        ltxtOut := getValue('Reserve.SerialNumber');  // workflow
      END;


      IF ( '' = ltxtOut ) THEN BEGIN
        ltxtOut := getValue('serial_no'); // legacy (very old) scanners
      END;

      ltxtOut := UPPERCASE(ltxtOut);
    END;

    PROCEDURE getLineNo@1000000008() liResult : Integer;
    VAR
      lsValue@1000000000 : Text[250];
    BEGIN
      // Line No. is the chosen standard, the other options are for backwards compatibility
      // for patches with previous releases of IWX

      lsValue := getValue('Line No.');

      IF ( '' = lsValue ) THEN BEGIN
        lsValue := getValue('line_number');
      END;
      IF ( '' = lsValue ) THEN BEGIN
        lsValue := getValue('line');
      END;
      IF ( '' = lsValue ) THEN BEGIN
        lsValue := getValue('line no');
      END;

      IF ( '' = lsValue ) THEN BEGIN
        lsValue := getValue('line_num');
      END;

      IF ( '' = lsValue ) THEN BEGIN
        liResult := 0;
      END ELSE IF ( NOT EVALUATE(liResult, lsValue ) ) THEN BEGIN
        // if we do have a value, but it's not valid, then
        // throw a more usefull error.
        ERROR( tcInvalidValueForKey, lsValue, liResult );
      END;
      EXIT( liResult );
    END;

    PROCEDURE getLocation@1000000016(VAR precOutLocation@1000000000 : Record 14);
    VAR
      lsValue@1000000001 : Text[250];
    BEGIN
      // Returns the location.

      IF ( recLocation.Code = '' ) THEN
        recLocation.GET(getLocationCode());

      precOutLocation := recLocation;
    END;

    PROCEDURE getLocationCode@1000000004() : Text;
    VAR
      lsValue@1000000000 : Text;
    BEGIN
      //<FUNC>
      //  Description: Wrapper for getting event parameter for location.
      //</FUNC>

      lsValue :=getValue('location');
      IF lsValue <> '' THEN
        EXIT(lsValue);

      lsValue :=getValue('location_code'); // backwards compatibility.
      IF lsValue <> '' THEN
        EXIT(lsValue);

      EXIT(getValue('loc_code'));
    END;

    PROCEDURE getEvent@1000000010() liEvent : Integer;
    BEGIN
      //
      // Added to allow passing the event ID into a StartSession for
      // background printing in NAV 2013

      // For normal extensibility
      IF ( 0 <> Rec."Event" ) THEN BEGIN
        liEvent := Rec."Event";
      END ELSE BEGIN
        // this is done because variables on a temporary record
        // object do not transfer over properly when passed
        // through StartSession, which is required for printing.
        liEvent := getValueAsInt( 'event' );
      END;
    END;

    PROCEDURE setEvent@1000000011(piEvent@1000000000 : Integer);
    BEGIN
      //
      // Added to allow passing the event ID into a StartSession for
      // background printing in NAV 2013
      //

      // For normal extensibility
      Rec."Event" := piEvent;
      Rec.MODIFY(FALSE);

      // this is done because variables on a temporary record
      // object do not transfer over properly when passed
      // through StartSession, which is required for printing.
      setValue( 'event', FORMAT( piEvent ) );
    END;

    PROCEDURE getBin@1000000043() ltxtOut : Text[250];
    BEGIN
      ltxtOut := getValue('Bin Code');
      IF ( '' = ltxtOut ) THEN BEGIN
        ltxtOut := getValue('bin');
      END;
      IF ( '' = ltxtOut ) THEN BEGIN
        ltxtOut := getValue('bin_code');
      END;
    END;

    PROCEDURE getExtensibilityOverride@1000000015() lbOverride : Boolean;
    BEGIN
      //
      // Added to allow extensibility codeunits in WHI.
      //

      // this is done because variables on a temporary record
      // object do not transfer over properly when passed
      // through StartSession, which is required for printing.
      lbOverride := getValueAsBool( 'override_whi' );
    END;

    PROCEDURE setExtensibilityOverride@1000000014(pbOverride@1000000000 : Boolean);
    BEGIN
      //
      // Added to allow extensibility codeunits in WHI.
      //

      // this is done because variables on a temporary record
      // object do not transfer over properly when passed
      // through StartSession, which is required for printing.
      IF ( pbOverride) THEN BEGIN
        setValue( 'override_whi', '1' );
      END ELSE BEGIN
        setValue( 'override_whi', '0' );
      END;
    END;

    PROCEDURE getExtensibilityEvent@1000000013() liExtensibilityOption : Integer;
    BEGIN
      //
      // Added to allow passing the event ID into a StartSession for
      // background printing in NAV 2013
      //

      // this is done because variables on a temporary record
      // object do not transfer over properly when passed
      // through StartSession, which is required for printing.
      liExtensibilityOption := getValueAsInt( 'Extensibility Event' );

      // For normal extensibility
      IF ( 0 = liExtensibilityOption ) THEN BEGIN
        liExtensibilityOption := Rec."Extensibility Event";
      END;
    END;

    PROCEDURE setExtensibilityEvent@1000000012(poptExtensibilityEvent@1000000000 : Option);
    VAR
      liTemp@1000000001 : Integer;
    BEGIN
      //
      // Added to allow passing the event ID into a StartSession for
      // background printing in NAV 2013
      //

      // For normal extensibility
      Rec."Extensibility Event" := poptExtensibilityEvent;
      Rec.MODIFY(FALSE);

      // this is done because variables on a temporary record
      // object do not transfer over properly when passed
      // through StartSession, which is required for printing.
      liTemp := Rec."Extensibility Event";
      setValue( 'Extensibility Event', FORMAT( liTemp ) );
    END;

    PROCEDURE setExtensibilitySalesLine@1000000017(VAR precSalesLine@1000000000 : Record 37);
    BEGIN
      // Used to set the a reference for customizations
      recSalesLine := precSalesLine;
    END;

    PROCEDURE setExtensibilityTransferLine@1000000018(VAR precTransferLine@1000000000 : Record 5741);
    BEGIN
      // Used to set the a reference for customizations
      recTransferLine := precTransferLine;
    END;

    PROCEDURE setExtensibilityPurchaseLine@1000000019(VAR precPurchaseLine@1000000000 : Record 39);
    BEGIN
      // Used to set the a reference for customizations
      recPurchaseLine := precPurchaseLine;
    END;

    PROCEDURE setExtensibilityIJournalLine@1000000026(VAR precItemJournalLine@1000000000 : Record 83);
    BEGIN
      // Used to set the a reference for customizations
      recItemJournalLine := precItemJournalLine;
    END;

    PROCEDURE getExtensibilitySalesLine@1000000024(VAR precSalesLine@1000000000 : Record 37);
    BEGIN
      // Used to get the a reference for customizations
      precSalesLine := recSalesLine;
    END;

    PROCEDURE getExtensibilityTransferLine@1000000023(VAR precTransferLine@1000000000 : Record 5741);
    BEGIN
      // Used to get the a reference for customizations
      precTransferLine := recTransferLine;
    END;

    PROCEDURE getExtensibilityPurchaseLine@1000000022(VAR precPurchaseLine@1000000000 : Record 39);
    BEGIN
      // Used to get the a reference for customizations
      precPurchaseLine :=  recPurchaseLine;
    END;

    PROCEDURE getExtensibilityLPLine@1000000025(VAR precLicensePlateLine@1000000000 : Record 23044506);
    BEGIN
      // Used to get the a reference for WMDM customizations
      precLicensePlateLine := recLicensePlateLine;
    END;

    PROCEDURE getExtensibilityIJournalLine@1000000027(VAR precItemJournalLine@1000000000 : Record 83);
    BEGIN
      // Used to get the a reference for customizations
      precItemJournalLine := recItemJournalLine;
    END;

    PROCEDURE getExtensibilityTransferHeader@1000000028(VAR precTransferHeader@1000000000 : Record 5740);
    BEGIN
      // Used to get the a reference for customizations
      precTransferHeader := recTransferHeader;
    END;

    PROCEDURE setExtensibilityTransferHeader@1000000029(VAR precTransferHeader@1000000000 : Record 5740);
    BEGIN
      // Used to set the a reference for customizations
      recTransferHeader := precTransferHeader;
    END;

    PROCEDURE getExtensibilityLPUsage@1000010031(VAR precLPLineUsage@1000000000 : Record 23044507);
    BEGIN
      // Used to get the a reference for WMDM customizations
      precLPLineUsage := recLPLineUsage;
    END;

    PROCEDURE setExtensibilityLPUsage@1000000030(VAR precLPLineUsage@1000000001 : Record 23044507);
    BEGIN
      // Used to set the a reference for WMDM customizations
      recLPLineUsage := precLPLineUsage;
    END;

    PROCEDURE getValue@1000000000(psKey@1000000000 : Text[50]) : Text[250];
    BEGIN

      IF Rec.GET(psKey) THEN
        EXIT(Rec.Value);

      IF ( Rec.GET( LOWERCASE(psKey) ) ) THEN
        EXIT(Rec.Value);

      psKey := LOWERCASE(psKey);
      Rec.RESET;
      IF (Rec.FINDSET(FALSE)) THEN BEGIN
        REPEAT
          IF( LOWERCASE(Rec.Key) = psKey ) THEN
            EXIT(Rec.Value);
        UNTIL(Rec.NEXT=0);
      END;

      EXIT('');
    END;

    PROCEDURE getValueAsBool@1000000001(psKey@1000000000 : Text[50]) lbResult : Boolean;
    VAR
      lsValue@1000000001 : Text[250];
    BEGIN
      lsValue := LOWERCASE(getValue(psKey));
      lbResult := ((lsValue='1') OR (lsValue='yes') OR (lsValue='true') OR ( lsValue = 't' ) OR ( lsValue = 'on' ) );
      EXIT( lbResult );
    END;

    PROCEDURE getValueAsDecimal@1000000002(psKey@1000000000 : Text[50]) ldResult : Decimal;
    VAR
      lsValue@1000000001 : Text[250];
    BEGIN
      lsValue := getValue(psKey);
      IF ( '' = lsValue ) THEN BEGIN
        ldResult := 0;
      END ELSE IF ( NOT EVALUATE(ldResult, lsValue) ) THEN BEGIN
        // if we do have a value, but it's not valid, then
        // throw a more usefull error.
        ERROR( tcInvalidValueForKey, lsValue, psKey );
      END;
      EXIT( ldResult );
    END;

    PROCEDURE getValueAsInt@1000000003(psKey@1000000000 : Text[50]) liResult : Integer;
    VAR
      lsValue@1000000001 : Text[250];
    BEGIN
      lsValue := getValue(psKey);
      IF ( '' = lsValue ) THEN BEGIN
        liResult := 0;
      END ELSE IF ( NOT EVALUATE(liResult, lsValue) ) THEN BEGIN
        // if we do have a value, but it's not valid, then
        // throw a more usefull error.
        ERROR( tcInvalidValueForKey, lsValue, psKey );
      END;
      EXIT( liResult );
    END;

    PROCEDURE getValueAsDate@1000010004(psKey@1000000000 : Text[50]) ldtResult : Date;
    VAR
      lsValue@1000000001 : Text[250];
      ldtDateTimeValue@1000000002 : DateTime;
    BEGIN
      ldtDateTimeValue := getValueAsDateTime( psKey,'' );
      IF (ldtDateTimeValue <> 0DT) THEN BEGIN
        ldtResult :=  DT2DATE( ldtDateTimeValue );
      END ELSE BEGIN
        ldtResult := 0D;
      END;

      EXIT( ldtResult );
    END;

    PROCEDURE setValue@1000000005(psKey@1000000000 : Text[50];psValue@1000000001 : Text[250]);
    BEGIN
      IF( Rec.GET(psKey) ) THEN BEGIN
        Rec.Value := psValue;
        Rec.MODIFY;
      END
      ELSE BEGIN
        Rec.Key := psKey;
        Rec.Value := psValue;
        Rec.INSERT;
      END;
    END;

    PROCEDURE setLargeValueFromText@1000100030(psKey@1000000000 : Text[50];psValue@1000000001 : Text);
    VAR
      ltrecTempBlob@1000000003 : TEMPORARY Record 99008535;
    BEGIN

      cuWHICommon.WriteTextToBlob(psValue,FALSE,ltrecTempBlob);

      IF ( Rec.GET(psKey) ) THEN BEGIN
        Rec."Extensibility Blob" := ltrecTempBlob.Blob;
        Rec.MODIFY;
      END ELSE BEGIN
        Rec.INIT();
        Rec.Key := psKey;
        Rec."Extensibility Blob" := ltrecTempBlob.Blob;
        Rec.INSERT();
      END;
    END;

    PROCEDURE setLargeValueFromFile@1000000045(psKey@1000000002 : Text[50];ptxtServerBlobFile@1000000001 : Text);
    VAR
      ltrecTempBlob@1000000005 : TEMPORARY Record 99008535;
    BEGIN
      cuWHICommon.WriteFileToBlob(ptxtServerBlobFile,ltrecTempBlob);
      IF ( Rec.GET(psKey) ) THEN BEGIN
        Rec."Extensibility Blob" := ltrecTempBlob.Blob;
        Rec.MODIFY;
      END ELSE BEGIN
        Rec.INIT();
        Rec.Key := psKey;
        Rec."Extensibility Blob" := ltrecTempBlob.Blob;
        Rec.INSERT;
      END;
    END;

    PROCEDURE getLargeValue@1000000020(psKey@1000000000 : Text[50]) : Text;
    VAR
      ltrecTempBlob@1000000002 : TEMPORARY Record 99008535;
      lsValue@1000000003 : Text;
    BEGIN

      IF ( Rec.GET( psKey) ) THEN BEGIN
        Rec.CALCFIELDS("Extensibility Blob");
        ltrecTempBlob.Blob := Rec."Extensibility Blob";
        ltrecTempBlob.INSERT;
        lsValue := cuWHICommon.GetTextFromBlob(ltrecTempBlob);
      END;

      EXIT(lsValue);
    END;

    PROCEDURE getHasKey@1000000021(psKey@1000000000 : Text[50]) lbResult : Boolean;
    VAR
      lsValue@1000000001 : Text[250];
    BEGIN
      // True, if the key is supplied, false if they key is not available.
      EXIT( Rec.GET(psKey) ) ;
    END;

    PROCEDURE getValueAsTime@1000000033(psKey@1000000000 : Text[50]) ldtResult : Time;
    VAR
      lsValue@1000000001 : Text[250];
    BEGIN
      // return time, and if not available returns TIME()
      lsValue := getValue(psKey);
      IF ( '' = lsValue ) THEN BEGIN
        ldtResult := TIME;
      END ELSE IF ( NOT EVALUATE(ldtResult, lsValue) ) THEN BEGIN
        // if we do have a value, but it's not valid, then
        // throw a more usefull error.
        ERROR( tcInvalidValueForKey, lsValue, psKey );
      END;
      EXIT( ldtResult );
    END;

    PROCEDURE getSupportsFastDataset@1000000039() rbSupportsFast : Boolean;
    BEGIN
      //
      // Fast datasets have item tracking information not included with
      // each row, and instead cached.
      //
      rbSupportsFast := FALSE;
    END;

    PROCEDURE getNeedsItemTrackingTable@1000000035() rbNeedsItemTrack : Boolean;
    BEGIN
      IF ( getSupportsFastDataset() ) THEN BEGIN
        rbNeedsItemTrack := getValueAsBool( 'need_itemtracking' );
      END ELSE BEGIN
        // no support for this in earlier builds.
        rbNeedsItemTrack := FALSE;
      END;
    END;

    PROCEDURE getUnitOfMeasure@1000000048(VAR precOutUnitOfMeasure@1000000000 : Record 204) pbWorked : Boolean;
    VAR
      ltxtUom@1000000001 : Text;
    BEGIN
      precOutUnitOfMeasure.RESET();

      ltxtUom := getValue('Unit of Measure Code');  // Most common

      IF ( '' = ltxtUom ) THEN BEGIN
        ltxtUom := getValue('uom');  // legacy screens
      END;

      IF ( '' = ltxtUom ) THEN BEGIN
        ltxtUom := getValue('scanned_uom');  // if the unit of measure is in the barcode but not yet known
      END;

      IF ( '' = ltxtUom ) THEN BEGIN
        ltxtUom := getValue('Unit Of Measure');  // usually the name of the uom, but in some tables also the code.
      END;


      IF (ltxtUom <> '' ) THEN BEGIN
        IF ( NOT precOutUnitOfMeasure.GET( COPYSTR( ltxtUom, 1, MAXSTRLEN( precOutUnitOfMeasure.Code) ) ) ) THEN BEGIN
          // doens't exist as a code, try description
          precOutUnitOfMeasure.RESET();
          precOutUnitOfMeasure.SETRANGE(Description, ltxtUom );
          IF ( NOT precOutUnitOfMeasure.FINDFIRST() ) THEN BEGIN
            // then just reset the out variable.
            precOutUnitOfMeasure.RESET();
          END;
        END;
      END;

      pbWorked := NOT precOutUnitOfMeasure.ISEMPTY();
    END;

    PROCEDURE getEntryNo@1000000049() liResult : Integer;
    VAR
      lsValue@1000000000 : Text[250];
    BEGIN
      lsValue := getValue('Entry No.'); // if this is from a table row

      IF ( '' = lsValue ) THEN BEGIN
        lsValue := getValue('entry_number'); // legacy
      END;
      IF ( '' = lsValue ) THEN BEGIN
        lsValue := getValue('Reserv.EntryNumber'); // workflow
      END;

      IF ( '' = lsValue ) THEN BEGIN
        liResult := 0;
      END ELSE IF ( NOT EVALUATE(liResult, lsValue ) ) THEN BEGIN
        // if we do have a value, but it's not valid, then
        // throw a more usefull error.
        ERROR( tcInvalidValueForKey, lsValue, liResult );
      END;
      EXIT( liResult );
    END;

    PROCEDURE getTagNo@1000000050() liResult : Integer;
    VAR
      lsValue@1000000000 : Text[250];
    BEGIN
      // Introduced for standardization.
      lsValue := getValue('Tag No.');

      IF ( '' = lsValue ) THEN BEGIN
        lsValue := getValue('tag_number');
      END;

      IF ( '' = lsValue ) THEN BEGIN
        liResult := 0;
      END ELSE IF ( NOT EVALUATE(liResult, lsValue ) ) THEN BEGIN
        // if we do have a value, but it's not valid, then
        // throw a more usefull error.
        ERROR( tcInvalidValueForKey, lsValue, liResult );
      END;
      EXIT( liResult );
    END;

    PROCEDURE getSheetName@1000000051() ltxtOut : Text[250];
    BEGIN
      // Introduced for standardization.
      ltxtOut := getValue('Sheet Name');
      IF ( '' = ltxtOut ) THEN BEGIN
        ltxtOut := getValue('sheet_name');
      END;
    END;

    PROCEDURE getValueAsDateTime@1000000009(psKey@1000000000 : Text[50];psDefaultDateFormat@1000000002 : Text) ldtResult : DateTime;
    BEGIN
      // return datetime, if the key is not found it will return 0dt

      ldtResult := ParseDateTime(
        getValue(psKey),
        psDefaultDateFormat,
        getValue('device_culture'));

      EXIT( ldtResult );
    END;

    PROCEDURE getExpirationDate@1000000075(psDefaultDateFormat@1000000000 : Text) ldtResult : Date;
    VAR
      lsValue@1000000001 : Text[250];
      ldtDateTimeValue@1000000013 : DateTime;
    BEGIN
      // Return Expiration date, or 0D if no expiration date is found

      ldtDateTimeValue := getValueAsDateTime('exp_date', psDefaultDateFormat);
      IF (ldtDateTimeValue = 0DT) THEN BEGIN
        ldtDateTimeValue := getValueAsDateTime('Expiration Date',psDefaultDateFormat);
      END;

      IF (ldtDateTimeValue <> 0DT) THEN BEGIN
        ldtResult :=  DT2DATE( ldtDateTimeValue );
      END ELSE BEGIN
        ldtResult := 0D;
      END;

      EXIT(ldtResult);
    END;

    PROCEDURE ParseDateTime@1000000031(psValue@1000000000 : Text[50];psDefaultDateFormat@1000000002 : Text;psCulture@1000000014 : Text) ldtResult : DateTime;
    VAR
      ldnServerCulture@1000000004 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Globalization.CultureInfo";
      ldnClientCulture@1000000003 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Globalization.CultureInfo";
      ldnPossibleFormatsCSV@1000000005 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.String";
      ldnArrayOfFormats@1000000008 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Array";
      ldnExpirationDate@1000000010 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.DateTime";
      ldnDateTimeStyle@1000000009 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Globalization.DateTimeStyles";
      ldnSeperatorArray@1000000012 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.String";
      lbCovertSuccess@1000000006 : Boolean;
      ltxtFormatsString@1000000007 : Text[1024];
      ltxtFormat@1000000011 : Text[80];
      liLastPostion@1000000013 : Integer;
    BEGIN
      // return datetime, if the key is not found it will return 0dt

      //lsValue := getValue(psKey);

      lbCovertSuccess:= FALSE;

      IF ( '' = psValue ) THEN BEGIN
        ldtResult := 0DT;
      END ELSE BEGIN
        ldnServerCulture :=  ldnServerCulture.InvariantCulture();
        ldnClientCulture :=  ldnClientCulture.CultureInfo( psCulture);

        ldnPossibleFormatsCSV := psDefaultDateFormat;
        ldnSeperatorArray := ',';
        ldnArrayOfFormats :=  ldnPossibleFormatsCSV.Split(ldnSeperatorArray.ToCharArray());
        ldnDateTimeStyle := ldnDateTimeStyle.None;

        IF (psDefaultDateFormat <> '') THEN BEGIN
          // Try Server culture first
          lbCovertSuccess := ldnExpirationDate.TryParseExact(psValue,
                                          ldnArrayOfFormats,
                                          ldnServerCulture,
                                          ldnDateTimeStyle.None,
                                          ldtResult );
          // Try client culture again
          IF (NOT lbCovertSuccess) THEN BEGIN
            lbCovertSuccess := ldnExpirationDate.TryParseExact(psValue,
                                            ldnArrayOfFormats,
                                            ldnClientCulture,
                                            ldnDateTimeStyle,
                                            ldtResult );
          END;
        END ELSE BEGIN
          // Try just parse server culture
          lbCovertSuccess := ldnExpirationDate.TryParse(psValue, ldnServerCulture, ldnDateTimeStyle.None, ldtResult);

          // Try just parse client culture
          IF (NOT lbCovertSuccess) THEN BEGIN
            ldnExpirationDate.TryParse(psValue, ldnClientCulture, ldnDateTimeStyle.None, ldtResult);
          END;

        END;

        // at last, try nav evaluate
        IF (NOT lbCovertSuccess) THEN BEGIN
          IF ( NOT EVALUATE(ldtResult, psValue) ) THEN BEGIN
            // if we do have a value, but it's not valid, then
            // throw a more usefull error.
            ERROR( tcInvalidDateTime, psValue );
          END;
        END;
      END;

      // special case to handle blank/minvalue dates from the handhelds
      IF DT2DATE(ldtResult) = DMY2DATE(24, 11, 1974) THEN
        ldtResult := 0DT;



      EXIT( ldtResult );
    END;

    BEGIN
    {
      ************************
      Copyright Notice
      This objects content is copyright of Insight Works 2011.  All rights reserved.
      Any redistribution or reproduction of part or all of the contents in any form is prohibited.
      ************************
    }
    END.
  }
}

