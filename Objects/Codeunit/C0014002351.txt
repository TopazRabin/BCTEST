OBJECT Codeunit 14002351 E.D.I. Format
{
  OBJECT-PROPERTIES
  {
    Date=07/13/20;
    Time=12:00:00 PM;
    Version List=SE0.62;
  }
  PROPERTIES
  {
    OnRun=BEGIN
          END;

  }
  CODE
  {
    VAR
      EDISetup@1240020000 : Record 14002367;
      SLNItemDetail@1240020001 : Boolean;
      SLNGroup@1240020002 : Integer;
      DateTimeVar@1240020007 : DateTime;
      UTCDateTime@1240020006 : DateTime;
      UTCDT@1240020005 : DateTime;
      UTCDifference@1240020004 : Duration;

    PROCEDURE FormatOutput@13(EDITemplate@1240030000 : Record 14002350;EDIElement@1240030001 : Record 14002355;VAR OutFldArray@1240030002 : ARRAY [100] OF Text[250];VAR OutErrorArray@1240030003 : ARRAY [100] OF Boolean;VAR i@1240030004 : Integer;VAR BypassSegment@1240030005 : Boolean;VAR BooleanVariable@1240030006 : Boolean;VAR DateVariable@1240030007 : Date;VAR DecimalVariable@1240030008 : Decimal;VAR IntegerVariable@1240030009 : Integer;VAR TimeVariable@1240020006 : Time;VAR DateTimeVariable@1240020007 : DateTime);
    VAR
      DecPosition@1240030010 : Integer;
      InsertedCharCount@1240030011 : Integer;
      InsChar@1240030012 : Integer;
      LastInpCharPos@1240030013 : Integer;
      TextFormat@1240030014 : Text[80];
      TotalLength@1240030015 : Integer;
      j@1240030016 : Integer;
      TestDecimalValue@1240030017 : Decimal;
      TestTextFormat@1240030018 : Text[30];
      DecimalSymbol@1240030019 : Text[1];
      CharPos@1240030020 : Integer;
      CurrDecimal@1240030021 : Integer;
      Char@1240020000 : Char;
      TextValue@1240020001 : Text[250];
      Position@1240020002 : Integer;
      Length@1240020003 : Integer;
      NumericValue@1240020004 : Text[250];
      AlphaNumericValue@1240020005 : Text[250];
      DateVariable2@1240020009 : Date;
      TimeVariable2@1240020008 : Time;
      Year@1240020010 : Integer;
      DateText@1240020019 : Text[25];
      DateTimeText@1240020022 : Text[25];
      XMLDateTime@1240020018 : Text[25];
      ExportTime@1240020017 : Text[25];
      UTCDifference@1240020016 : Duration;
      UTCDateTime@1240020015 : DateTime;
      UTCTime@1240020014 : Time;
      Hours@1240020013 : Decimal;
      HoursText@1240020012 : Text[6];
      UTCDate@1240020020 : Date;
    BEGIN
      EDISetup.GET;
      IF i = 1 THEN
        BypassSegment := FALSE;
      CASE EDIElement."NAV Data Type" OF
        EDIElement."NAV Data Type"::Boolean:
          BEGIN
            IF EDIElement."NAV Data Type" = EDIElement."NAV Data Type"::Boolean THEN
              IF BooleanVariable THEN
                OutFldArray[i] := COPYSTR('YES',1,EDIElement.Length)
              ELSE
               OutFldArray[i] := COPYSTR('NO',1,EDIElement.Length);
            IF EDIElement."Bypass Segment if Blank" AND (NOT BooleanVariable) THEN
              BypassSegment := TRUE;
            IF EDIElement."Bypass Segment if Not Blank" AND BooleanVariable THEN
              BypassSegment := TRUE;
          END;
        EDIElement."NAV Data Type"::Date:
          BEGIN
            CASE EDIElement."Data Type" OF
              EDIElement."Data Type"::"Date YYMMDD":
                IF EDIElement."Format String" = '' THEN
                  OutFldArray[i] := FORMAT(DateVariable,EDIElement.Length,'<year,2><Month,2><Day,2>')
                ELSE
                  OutFldArray[i] := FORMAT(DateVariable,EDIElement.Length,EDIElement."Format String");
              EDIElement."Data Type"::"Date YYYYMMDD":
                BEGIN
                  IF EDIElement."Format String" = '' THEN BEGIN
                    IF EDITemplate."File Format" = EDITemplate."File Format"::XML THEN
                      OutFldArray[i] := FORMAT(DateVariable,0,9)
                    ELSE
                      OutFldArray[i] := FORMAT(DateVariable,EDIElement.Length,'<Year4,4><Month,2><Day,2>');
                  END ELSE
                    OutFldArray[i] := FORMAT(DateVariable,EDIElement.Length,EDIElement."Format String");
                END;
              EDIElement."Data Type"::"Date DDMMYY":
                IF EDIElement."Format String" = '' THEN
                  OutFldArray[i] := FORMAT(DateVariable,EDIElement.Length,'<Day,2><Month,2><Year,2>')
                ELSE
                  OutFldArray[i] := FORMAT(DateVariable,EDIElement.Length,EDIElement."Format String");
              EDIElement."Data Type"::"Date DDMMYYYY":
                IF EDIElement."Format String" = '' THEN
                  OutFldArray[i] := FORMAT(DateVariable,EDIElement.Length,'<Day,2><Month,2><Year4,4>')
                ELSE
                  OutFldArray[i] := FORMAT(DateVariable,EDIElement.Length,EDIElement."Format String");
              EDIElement."Data Type"::"Date YYYYDDMM":
                IF EDIElement."Format String" = '' THEN
                  OutFldArray[i] := FORMAT(DateVariable,EDIElement.Length,'<Year4,4><Day,2><Month,2>')
                ELSE
                  OutFldArray[i] := FORMAT(DateVariable,EDIElement.Length,EDIElement."Format String");
              EDIElement."Data Type"::"Date MMDDYY":
                IF EDIElement."Format String" = '' THEN
                  OutFldArray[i] := FORMAT(DateVariable,EDIElement.Length,'<Month,2><Day,2><Year,2>')
                ELSE
                  OutFldArray[i] := FORMAT(DateVariable,EDIElement.Length,EDIElement."Format String");
              EDIElement."Data Type"::"Date MMDDYYYY":
                IF EDIElement."Format String" =  '' THEN
                  OutFldArray[i] := FORMAT(DateVariable,EDIElement.Length,'<Month,2><Day,2><Year4,4>')
                ELSE
                  OutFldArray[i] := FORMAT(DateVariable,EDIElement.Length,EDIElement."Format String");
              EDIElement."Data Type"::"Date XML DateTime":
                BEGIN
                  IF DateVariable = 0D THEN
                    OutFldArray[i] := ''
                  ELSE BEGIN
                    UTCDateTime := GetDate(DateVariable,UTCDifference,0DT,EDIElement);
                    Hours := UTCDifference/36000;
                    HoursText := FORMAT(Hours);
                    IF STRLEN(HoursText) <> 5 THEN
                      REPEAT
                        HoursText := INSSTR(HoursText,'0',2);
                      UNTIL STRLEN(HoursText) = 5;
                    DateText := FORMAT(DateVariable,0,9) + 'T';
                    XMLDateTime := COPYSTR(DateText,1,11);
                    IF (EDIElement.Origin = EDIElement.Origin::"EDI Out") AND
                       (UPPERCASE(EDIElement."Field Name") = 'TODAY')
                    THEN BEGIN
                      UTCTime := DT2TIME(UTCDateTime);
                      ExportTime :=
                        CONVERTSTR(
                          FORMAT(
                            UTCTime,0,0),' ','0');
                      XMLDateTime := XMLDateTime + COPYSTR(ExportTime,1,8);
                    END ELSE BEGIN
                      ExportTime := '00:00:00';
                      XMLDateTime := XMLDateTime + ExportTime;
                    END;
                    CASE EDIElement."Time Zone" OF
                      EDIElement."Time Zone"::Offset:
                        XMLDateTime := XMLDateTime + HoursText;
                      EDIElement."Time Zone"::Z:
                        XMLDateTime := XMLDateTime + 'Z';
                    END;
                    OutFldArray[i] := XMLDateTime;
                  END;
                END;
              EDIElement."Data Type"::"Date UTC":
                BEGIN
                  IF DateVariable = 0D THEN
                    OutFldArray[i] := ''
                  ELSE BEGIN
                    CLEAR(UTCDate);
                    CLEAR(UTCDateTime);
                    UTCDateTime := GetDate(DateVariable,UTCDifference,0DT,EDIElement);
                    UTCDate := DT2DATE(UTCDateTime);
                    Hours := UTCDifference/36000;
                    HoursText := FORMAT(Hours);
                    IF STRLEN(HoursText) <> 5 THEN
                      REPEAT
                        HoursText := INSSTR(HoursText,'0',2);
                      UNTIL STRLEN(HoursText) = 5;
                    HoursText := INSSTR(HoursText,':',4);
                    OutFldArray[i] :=
                      FORMAT(
                        UTCDate,
                        EDIElement.Length,
                        '<Year4,4>-<Month,2>-<Day,2>');
                    CASE EDIElement."Time Zone" OF
                      EDIElement."Time Zone"::Offset:
                        OutFldArray[i] := OutFldArray[i] + HoursText;
                      EDIElement."Time Zone"::Z:
                        OutFldArray[i] := OutFldArray[i] + 'Z';
                    END;
                  END;
                END;
            END;
            IF (EDIElement."Bypass Segment if Blank" = TRUE) AND (DateVariable = 0D) THEN
              BypassSegment := TRUE;
            IF (EDIElement."Bypass Segment if Not Blank" = TRUE) AND (DateVariable <> 0D) THEN
              BypassSegment := TRUE;
          END;
        EDIElement."NAV Data Type"::Decimal:
          BEGIN
            IF EDIElement."Format String" = '' THEN BEGIN
              TestDecimalValue := 5 / 3;
              TestTextFormat := FORMAT(TestDecimalValue,4,1);
              DecimalSymbol := COPYSTR(TestTextFormat,2,1);
              IF EDITemplate."Decimal Symbol" <> '' THEN
                DecimalSymbol := EDITemplate."Decimal Symbol";
              IF (EDIElement."Reverse Sign") AND (DecimalVariable <> 0) THEN
                DecimalVariable := (-1 * DecimalVariable);
              IF (EDIElement."Round Value") AND (DecimalVariable <> 0) THEN
                DecimalVariable := RoundValue(DecimalVariable,EDIElement);
              TextFormat := FORMAT(DecimalVariable,EDIElement.Length,1);
              DecPosition := STRPOS(TextFormat,DecimalSymbol);
              IF DecPosition = 0 THEN BEGIN
                DecPosition := STRLEN(TextFormat) + 1;
                TextFormat := INSSTR(TextFormat,DecimalSymbol,DecPosition);
              END;

              TextFormat := COPYSTR(TextFormat,1,(DecPosition + EDIElement.Decimals));
              TextFormat := PADSTR(TextFormat,(DecPosition + EDIElement.Decimals),'0');

              CASE EDIElement."Data Type" OF
                EDIElement."Data Type"::"Dec Implied":
                  BEGIN
                    OutFldArray[i] := DELCHR(TextFormat,'=',DecimalSymbol);
                    LastInpCharPos := STRLEN(OutFldArray[i]) - EDIElement.Length;
                    IF LastInpCharPos > 0 THEN
                      OutFldArray[i] := COPYSTR(OutFldArray[i],LastInpCharPos + 1,EDIElement.Length);
                  END;
                EDIElement."Data Type"::"Dec Explicit":
                  BEGIN
                    OutFldArray[i] := '';
                    LastInpCharPos := STRLEN(TextFormat);
                    InsertedCharCount := 0;
                    REPEAT
                      IF LastInpCharPos > 0 THEN
                        OutFldArray[i] := INSSTR(OutFldArray[i],COPYSTR(TextFormat,LastInpCharPos,1),1)
                      ELSE
                        OutFldArray[i] := INSSTR(OutFldArray[i],' ',1);
                      LastInpCharPos := LastInpCharPos - 1;
                      InsertedCharCount := InsertedCharCount + 1;
                    UNTIL InsertedCharCount = EDIElement.Length;
                    TextFormat := OutFldArray[i];
                    CharPos := STRLEN(TextFormat);
                    REPEAT
                      CASE TextFormat[CharPos] OF
                        '0':
                          IF NOT EDITemplate."Export Trailing Decimals" THEN BEGIN
                            TextFormat[CharPos] := 0;
                            TextFormat := ' ' + TextFormat;
                            CharPos := CharPos + 1;
                          END;
                        '1','2','3','4','5','6','7','8','9':
                          CharPos := 1;
                        DecimalSymbol[1]:
                          BEGIN
                            IF NOT EDITemplate."Export Trailing Decimals" THEN BEGIN
                              TextFormat[CharPos] := 0;
                              TextFormat := ' ' + TextFormat;
                            END;
                            CharPos := 1;
                          END;
                      END;
                      CharPos := CharPos - 1;
                    UNTIL CharPos < 1;
                    CurrDecimal := STRPOS(TextFormat,DecimalSymbol);
                    IF CurrDecimal <> 0 THEN
                      OutFldArray[i] := COPYSTR(TextFormat,1,CurrDecimal + EDIElement.Decimals)
                    ELSE
                      OutFldArray[i] := TextFormat;
                  END;
              END;
            END ELSE
              OutFldArray[i] := FORMAT(DecimalVariable,EDIElement.Length,EDIElement."Format String");

            IF EDIElement.Justify = EDIElement.Justify::"Right Zero Fill" THEN BEGIN
              OutFldArray[i] := DELCHR(OutFldArray[i],'>');
              IF EDIElement.Length <> 0 THEN BEGIN
                IF STRLEN(OutFldArray[i]) < EDIElement.Length THEN
                  REPEAT
                    OutFldArray[i] := INSSTR(OutFldArray[i],' ',1);
                  UNTIL STRLEN(OutFldArray[i]) = EDIElement.Length;
                END;
              OutFldArray[i] := CONVERTSTR(OutFldArray[i],' ','0');
            END;

            IF (EDIElement."Minimum Length" <> 0) AND (DecimalVariable = 0) THEN
              OutErrorArray[i] := TRUE;

            IF (EDIElement."Bypass Segment if Blank" = TRUE) AND (DecimalVariable = 0) THEN
              BypassSegment := TRUE;
            IF (EDIElement."Bypass Segment if Not Blank" = TRUE) AND (DecimalVariable <> 0) THEN
              BypassSegment := TRUE;
          END;
        EDIElement."NAV Data Type"::Integer:
          BEGIN
            IF (EDIElement."Reverse Sign") AND (IntegerVariable <> 0) THEN
              IntegerVariable := (-1 * IntegerVariable);
            OutFldArray[i] := FORMAT(IntegerVariable,EDIElement.Length,'<sign><integer>');
            IF EDIElement.Justify = EDIElement.Justify::"Right Zero Fill" THEN BEGIN
              OutFldArray[i] := DELCHR(OutFldArray[i],'>');
              OutFldArray[i] := CONVERTSTR(OutFldArray[i],' ','0');
            END;

            IF (EDIElement."Minimum Length" <> 0) AND (IntegerVariable = 0) THEN
              OutErrorArray[i] := TRUE;

            IF (EDIElement."Bypass Segment if Blank" = TRUE) AND (IntegerVariable = 0) THEN
              BypassSegment := TRUE;
            IF (EDIElement."Bypass Segment if Not Blank" = TRUE) AND (IntegerVariable <> 0) THEN
              BypassSegment := TRUE;
          END;
        EDIElement."NAV Data Type"::DateTime:
          BEGIN
            CASE EDIElement."Data Type" OF
              EDIElement."Data Type"::"DateTime YYYYMMDDHHMM":
                BEGIN
                  IF EDIElement."Format String" = '' THEN BEGIN
                    IF EDITemplate."File Format" = EDITemplate."File Format"::XML THEN
                      OutFldArray[i] := FORMAT(DateTimeVariable,0,9)
                    ELSE BEGIN
                      DateVariable2 := DT2DATE(DateTimeVariable);
                      TimeVariable2 := DT2TIME(DateTimeVariable);
                      OutFldArray[i] := FORMAT(DateVariable2,8,'<year4,4><Month,2><Day,2>');
                      OutFldArray[i] :=
                        OutFldArray[i] +
                        CONVERTSTR(FORMAT(TimeVariable2,4,'<Hours24,2><Minutes,2>'),' ','0');
                    END;
                  END ELSE
                    OutFldArray[i] := FORMAT(DateTimeVariable,EDIElement.Length,EDIElement."Format String");
                END;
              EDIElement."Data Type"::"DateTime XML":
                BEGIN
                  IF DateTimeVariable = 0DT THEN
                    OutFldArray[i] := ''
                  ELSE BEGIN
                    UTCDateTime := GetDate(0D,UTCDifference,DateTimeVariable,EDIElement);
                    Hours := UTCDifference/36000;
                    HoursText := FORMAT(Hours);
                    IF STRLEN(HoursText) <> 5 THEN
                      REPEAT
                        HoursText := INSSTR(HoursText,'0',2);
                      UNTIL STRLEN(HoursText) = 5;
                    DateTimeText := FORMAT(DateTimeVariable,0,9);
                    XMLDateTime := COPYSTR(DateTimeText,1,10);
                    ExportTime := COPYSTR(DateTimeText,11,9);
                    XMLDateTime := XMLDateTime + COPYSTR(ExportTime,1,9);
                    CASE EDIElement."Time Zone" OF
                      EDIElement."Time Zone"::Offset:
                        XMLDateTime := XMLDateTime + FORMAT(HoursText);
                      EDIElement."Time Zone"::Z:
                        XMLDateTime := XMLDateTime + 'Z';
                    END;
                    OutFldArray[i] := XMLDateTime;
                  END;
                END;
             END;
            IF (EDIElement."Bypass Segment if Blank" = TRUE) AND (DateTimeVariable = 0DT) THEN
              BypassSegment := TRUE;
            IF (EDIElement."Bypass Segment if Not Blank" = TRUE) AND (DateTimeVariable <> 0DT) THEN
              BypassSegment := TRUE;
          END;
        EDIElement."NAV Data Type"::Time:
          BEGIN
            CASE EDIElement."Data Type" OF
              EDIElement."Data Type"::"Time HHMM":
                IF EDIElement."Format String" = '' THEN
                  OutFldArray[i] :=
                    CONVERTSTR(FORMAT(TimeVariable,4,'<Hours24,2><Minutes,2>'),' ','0')
                ELSE
                  OutFldArray[i] := FORMAT(TimeVariable,EDIElement.Length,EDIElement."Format String");
            END;
            IF (EDIElement."Bypass Segment if Blank" = TRUE) AND (TimeVariable = 0T) THEN
              BypassSegment := TRUE;
            IF (EDIElement."Bypass Segment if Not Blank" = TRUE) AND (TimeVariable <> 0T) THEN
              BypassSegment := TRUE;
          END;
      END;

      IF (EDIElement."NAV Data Type" <> EDIElement."NAV Data Type"::Decimal) AND
        (EDIElement."NAV Data Type" <> EDIElement."NAV Data Type"::Boolean) AND
        (EDIElement."NAV Data Type" <> EDIElement."NAV Data Type"::Integer) AND
        (EDIElement."NAV Data Type" <> EDIElement."NAV Data Type"::Time) AND
        (EDIElement."NAV Data Type" <> EDIElement."NAV Data Type"::DateTime)
      THEN BEGIN
        IF (EDIElement."Bypass Segment if Blank" = TRUE) AND (OutFldArray[i] = '') THEN
          BypassSegment := TRUE;
        IF (EDIElement."Bypass Segment if Not Blank" = TRUE) AND (OutFldArray[i] <> '') THEN
          BypassSegment := TRUE;
        IF (EDIElement."Format Numeric") AND (OutFldArray[i] <> '') THEN BEGIN
          Position := 1;
          Length := STRLEN(OutFldArray[i]);
          NumericValue := '';
          REPEAT
            TextValue := COPYSTR(OutFldArray[i],Position,1);
            EVALUATE(Char,TextValue);
            IF (Char >= 48) AND (Char <= 57) THEN
              NumericValue := NumericValue + TextValue;
            Position := Position + 1;
          UNTIL Position = Length + 1;
          OutFldArray[i] := NumericValue;
        END;
        IF (EDIElement."Format AlphaNumeric") AND (OutFldArray[i] <> '') THEN BEGIN
          Position := 1;
          Length := STRLEN(OutFldArray[i]);
          AlphaNumericValue := '';
          REPEAT
            TextValue := COPYSTR(OutFldArray[i],Position,1);
            EVALUATE(Char,TextValue);
            IF (((Char >= 48) AND (Char <= 57)) OR
                ((Char >= 65) AND (Char <= 90)) OR
                ((Char >= 97) AND (Char <=122)))
            THEN
              AlphaNumericValue := AlphaNumericValue + TextValue;
            Position := Position + 1;
          UNTIL Position = Length + 1;
          OutFldArray[i] := AlphaNumericValue;
        END;
      END;

      IF (EDITemplate."File Format" = EDITemplate."File Format"::Delimited) OR
         (EDITemplate."File Format" = EDITemplate."File Format"::XML)
      THEN BEGIN
        IF (EDIElement.Justify = EDIElement.Justify::"Right Zero Fill") AND
           (OutFldArray[i] <> ' ')
        THEN BEGIN
          OutFldArray[i] := DELCHR(OutFldArray[i],'>');
          IF EDIElement.Length <> 0 THEN BEGIN
            IF STRLEN(OutFldArray[i]) < EDIElement.Length THEN
              REPEAT
                OutFldArray[i] := INSSTR(OutFldArray[i],' ',1);
              UNTIL STRLEN(OutFldArray[i]) = EDIElement.Length;
          END;
          OutFldArray[i] := CONVERTSTR(OutFldArray[i],' ','0');
        END;
        EDIElement.Justify := EDIElement.Justify::Left;
      END;
      IF OutFldArray[i] <> ' ' THEN
        CASE EDIElement.Justify OF
          EDIElement.Justify::Left:
            IF COPYSTR(OutFldArray[i],1,1) = ' ' THEN
              REPEAT
                OutFldArray[i] := DELCHR(OutFldArray[i],'<',' ');
              UNTIL COPYSTR(OutFldArray[i],1,1) <> ' ';
          EDIElement.Justify::Right:
            IF STRLEN(OutFldArray[i]) < EDIElement.Length THEN BEGIN
              InsChar := EDIElement.Length - STRLEN(OutFldArray[i]);
              REPEAT
                OutFldArray[i] := INSSTR(OutFldArray[i],' ',1);
                InsChar := InsChar - 1;
              UNTIL InsChar = 0;
            END;
          EDIElement.Justify::"Right Zero Fill":
            BEGIN
              OutFldArray[i] := DELCHR(OutFldArray[i],'>');
              IF EDIElement.Length <> 0 THEN BEGIN
                IF STRLEN(OutFldArray[i]) < EDIElement.Length THEN
                  REPEAT
                    OutFldArray[i] := INSSTR(OutFldArray[i],' ',1);
                  UNTIL STRLEN(OutFldArray[i]) = EDIElement.Length;
                END;
              OutFldArray[i] := CONVERTSTR(OutFldArray[i],' ','0');
            END;
        END;

      // Check for Special Characters in EDIFACT
      IF EDITemplate."Interface File Type" = EDITemplate."Interface File Type"::"EDIFACT Delimited" THEN BEGIN
        j := 1;
        TotalLength := EDIElement.Length;
        REPEAT
          IF (COPYSTR(OutFldArray[i],j,1) = EDITemplate."Component Delimeter") OR
             (COPYSTR(OutFldArray[i],j,1) = EDITemplate."Element Delimeter") OR
             (COPYSTR(OutFldArray[i],j,1) = EDITemplate."Segment Terminator") THEN BEGIN
            OutFldArray[i] := INSSTR(OutFldArray[i],'?',j);
            j := j + 1;
            TotalLength := TotalLength + 1;
          END;
          j := j + 1;
        UNTIL j > TotalLength;
      END;

      // Check minimum required length
      OutFldArray[i] := DELCHR(OutFldArray[i],'>',' ');
      IF EDISetup."Zero Value Sets Send Doc Error" THEN BEGIN
        IF (EDIElement."NAV Data Type" <> EDIElement."NAV Data Type"::Decimal) AND
           (EDIElement."NAV Data Type" <> EDIElement."NAV Data Type"::Integer)
        THEN BEGIN
          IF (EDIElement."Minimum Length" <> 0) AND
             (STRLEN(OutFldArray[i]) < EDIElement."Minimum Length") THEN
            OutErrorArray[i] := TRUE
          ELSE
            OutErrorArray[i] := FALSE;
        END;
      END ELSE BEGIN
        IF (EDIElement."Minimum Length" <> 0) AND
           (STRLEN(OutFldArray[i]) < EDIElement."Minimum Length") THEN
          OutErrorArray[i] := TRUE
        ELSE
          OutErrorArray[i] := FALSE;
      END;
    END;

    PROCEDURE LoadEDIInFields@1(EDIElement@1240030000 : Record 14002355;InternalDocNo@1240030001 : Code[10];SegmentGroup@1240030002 : Integer;ProcessingLines@1240030003 : Boolean;VAR i@1240030004 : Integer;VAR OutFldArray@1240030005 : ARRAY [100] OF Text[80];VAR BooleanVariable@1240030006 : Boolean;VAR DateVariable@1240030007 : Date;VAR DecimalVariable@1240030008 : Decimal;VAR IntegerVariable@1240030009 : Integer;VAR TimeVariable@1240020000 : Time;VAR DateTimeVariable@1240020001 : DateTime);
    VAR
      EDIRecDocFields@1240030010 : Record 14002359;
      EDIInFound@1240020002 : Boolean;
    BEGIN
      BooleanVariable := FALSE;
      DateVariable := 0D;
      IntegerVariable := 0;
      DecimalVariable := 0;
      TimeVariable := 0T;
      DateTimeVariable := 0DT;
      EDIInFound := FALSE;

      EDIRecDocFields.RESET;
      EDIRecDocFields.SETCURRENTKEY("Internal Doc. No.","Field Name");
      EDIRecDocFields.SETRANGE("Internal Doc. No.",InternalDocNo);
      EDIRecDocFields.SETRANGE("Field Name",EDIElement."Field Name");
      IF ProcessingLines THEN
        EDIRecDocFields.SETRANGE("Segment Group",SegmentGroup)
      ELSE
        EDIRecDocFields.SETRANGE("Segment Group",0);
      IF EDIRecDocFields.FIND('-') THEN BEGIN
        EDIInFound := TRUE;
        IF SLNItemDetail AND ProcessingLines THEN BEGIN
          IF EDIRecDocFields.COUNT > 1 THEN
             EDIRecDocFields.SETRANGE("SLN Group",SLNGroup);
             IF EDIRecDocFields.FIND('-') THEN
               EDIInFound := TRUE
             ELSE
               EDIInFound := FALSE;
        END;
        IF EDIInFound THEN BEGIN
          CASE EDIElement."Data Type" OF
            EDIElement."Data Type"::Text:
              OutFldArray[i] := EDIRecDocFields."Field Text Value";
            EDIElement."Data Type"::"Dec Implied":
              DecimalVariable := EDIRecDocFields."Field Dec. Value";
            EDIElement."Data Type"::"Dec Explicit":
              DecimalVariable := EDIRecDocFields."Field Dec. Value";
            EDIElement."Data Type"::Integer:
              IntegerVariable := EDIRecDocFields."Field Integer Value";
            EDIElement."Data Type"::"Date YYMMDD":
              DateVariable := EDIRecDocFields."Field Date Value";
            EDIElement."Data Type"::"Date YYYYMMDD":
              DateVariable := EDIRecDocFields."Field Date Value";
            EDIElement."Data Type"::"Time HHMM":
              TimeVariable := EDIRecDocFields."Field Time Value";
            EDIElement."Data Type"::"DateTime YYYYMMDDHHMM":
              DateTimeVariable := EDIRecDocFields."Field DateTime Value";
          END;
        END;
      END;
    END;

    PROCEDURE RoundValue@1240030001(DecimalValue@1240030004 : Decimal;CurrEDIElement@1240020000 : Record 14002355) RoundedValue : Decimal;
    VAR
      RoundingPrecision@1240030003 : Decimal;
      DecimalPlaces@1240030001 : Integer;
      Decimals@1240030000 : Integer;
      RoundingPrecisionString@1240030002 : Text[20];
      RoundDirection@1240020001 : Text[10];
    BEGIN
      IF CurrEDIElement."NAV Data Type" = CurrEDIElement."NAV Data Type"::Decimal THEN BEGIN
        Decimals := CurrEDIElement.Decimals;
        DecimalPlaces := 0;
        IF Decimals > 0 THEN BEGIN
          RoundingPrecisionString  := '0.1';
          IF Decimals = 1 THEN
            DecimalPlaces := 1
          ELSE
            DecimalPlaces := Decimals - 1;
          WHILE DecimalPlaces > 0 DO BEGIN
            RoundingPrecisionString := INSSTR(RoundingPrecisionString,'0',3);
            DecimalPlaces := DecimalPlaces - 1;
          END;
        END ELSE
          RoundingPrecisionString := '1';
        EVALUATE(RoundingPrecision,RoundingPrecisionString);
        CASE CurrEDIElement."Round Direction" OF
          CurrEDIElement."Round Direction"::" ",CurrEDIElement."Round Direction"::"Nearest Value":
            RoundDirection := '=';
          CurrEDIElement."Round Direction"::Up:
            RoundDirection := '>';
          CurrEDIElement."Round Direction"::Down:
            RoundDirection := '<';
        END;
        RoundedValue := ROUND(DecimalValue,RoundingPrecision,RoundDirection);
      END;
    END;

    PROCEDURE SetSLNFound@1240020000(SLN@1240020000 : Boolean);
    BEGIN
      SLNItemDetail := SLN;
    END;

    PROCEDURE SetSLNGroup@1240020002(Group@1240020000 : Integer);
    BEGIN
      SLNGroup := Group;
    END;

    PROCEDURE GetDate@1240020003(CurrentDate@1240020000 : Date;VAR UTCDifference2@1240020001 : Duration;CurrentDateTime@1240020003 : DateTime;EDIElement@1240020004 : Record 14002355) ResultDT : DateTime;
    VAR
      UseCurrentDateTime@1240020005 : Boolean;
    BEGIN
      IF (EDIElement.Origin = EDIElement.Origin::"EDI Out") AND
         (UPPERCASE(EDIElement."Field Name") = 'TODAY')
      THEN
        UseCurrentDateTime := TRUE
      ELSE
        UseCurrentDateTime := FALSE;
      IF EDIElement."NAV Data Type" = EDIElement."NAV Data Type"::Date THEN
        DateTimeVar := UTC2LocalDT(CREATEDATETIME(CurrentDate,000000T),UseCurrentDateTime)
      ELSE
        DateTimeVar := UTC2LocalDT(CurrentDateTime,UseCurrentDateTime);
      UTCDifference2 := UTCDifference;
      EXIT(UTCDT);
    END;

    LOCAL PROCEDURE UTC2LocalDT@1240020001(UTC@1000 : DateTime;UseCurrentDateTime@1240020000 : Boolean) LocalDT : DateTime;
    VAR
      CurrentDT@1018 : DateTime;
    BEGIN
      IF UTC <> 0DT THEN BEGIN
        IF UseCurrentDateTime THEN
          CurrentDT := ROUNDDATETIME(CURRENTDATETIME)
        ELSE
          CurrentDT := ROUNDDATETIME(UTC);
        UTCDT := LocalDT2UTC(CurrentDT);
        UTCDifference := CurrentDT - UTCDT;
      END ELSE
        LocalDT := 0DT;
    END;

    PROCEDURE LocalDT2UTC@2(LocalDT@1000 : DateTime) UTC : DateTime;
    BEGIN
      IF LocalDT <> 0DT THEN
        UTC := ParseUTCString(FORMAT(LocalDT,0,9))
      ELSE
        UTC := 0DT;
    END;

    LOCAL PROCEDURE ParseUTCString@3(UTCString@1000 : Text[1024]) ResultDT : DateTime;
    VAR
      Time@1004 : Time;
      Year@1005 : Integer;
      Month@1006 : Integer;
      Day@1007 : Integer;
      Hour@1008 : Integer;
      Minute@1003 : Integer;
      Sec@1002 : Integer;
      Millisec@1001 : Integer;
      PosDot@1009 : Integer;
      PosZ@1010 : Integer;
    BEGIN
      IF UTCString = '' THEN
        EXIT(0DT);
      EVALUATE(Year,COPYSTR(UTCString,1,4));
      EVALUATE(Month,COPYSTR(UTCString,6,2));
      EVALUATE(Day,COPYSTR(UTCString,9,2));
      EVALUATE(Hour,COPYSTR(UTCString,12,2));
      EVALUATE(Minute,COPYSTR(UTCString,15,2));
      EVALUATE(Sec,COPYSTR(UTCString,18,2));
      PosDot := STRPOS(UTCString,'.');
      PosZ := STRPOS(UTCString,'Z');
      IF PosDot > 0 THEN
        EVALUATE(Millisec,COPYSTR(UTCString, PosDot + 1,PosZ - PosDot - 1));
      EVALUATE(Time,STRSUBSTNO('%1:%2:%3.%4',Hour,Minute,Sec,Millisec));
      ResultDT := CREATEDATETIME(DMY2DATE(Day,Month,Year),Time);
    END;

    BEGIN
    END.
  }
}

