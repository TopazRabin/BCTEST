OBJECT Codeunit 23044501 WHI Common Functions
{
  OBJECT-PROPERTIES
  {
    Date=03/01/21;
    Time=[ 4:43:32 AM];
    Modified=Yes;
    Version List=WHI2.4.7684.0;
  }
  PROPERTIES
  {
    Permissions=TableData 6550=rimd;
    OnRun=BEGIN
          END;

  }
  CODE
  {
    VAR
      cuWhseResMgmt2@1000000006 : Codeunit 23044514;
      cuResMgmt@1000000005 : Codeunit 23044504;
      iColumnIndex@1000000007 : Integer;
      trecColumns@1000000010 : TEMPORARY Record 23044512;
      bWriteColumnHeader@1000000011 : Boolean;
      bIsConfigurableColumn@1000000012 : Boolean;
      trecColumnsVisibleOverride@1000000013 : TEMPORARY Record 23044512;
      cuLinksAndDocs@1000000018 : Codeunit 23044529;
      cuCommonBase@1000000020 : Codeunit 23044519;
      recDeviceConfig@1000000021 : Record 23044504;
      cuTranslationMgmt@1000000023 : Codeunit 23044526;
      trecPDAColumnCSVOverride@1000000024 : TEMPORARY Record 23044512;
      tcDuplicateFieldNameLbl@100000000 : TextConst 'ENU=Duplicate column defined: [%1] for Event ID: [%2], Table No.: [%3];ENC=Duplicate column defined: [%1] for Event ID: [%2], Table No.: [%3]';

    PROCEDURE generateErrorXML@1000000017(psErrorMessage@1000000000 : Text) : Text;
    BEGIN
      //<FUNC>
      //  Description: Takes the error message provided and formats it into an acceptable xml string.
      //  Called From:
      //  Side Effect: None
      //</FUNC>
      IF( psErrorMessage <> '' ) THEN BEGIN
        IF ( NOT GUIALLOWED) THEN BEGIN
          // get this error message in the windows event log.
          MESSAGE( psErrorMessage );
        END;
        EXIT( STRSUBSTNO('<ERROR><MSG>%1</MSG></ERROR>', escapeText( psErrorMessage ) ) )
      END ELSE
        EXIT('');
    END;

    PROCEDURE generateSuccessReturn@1000000009(piSuccessCode@1000000001 : Integer;VAR pbsOutput@1000000000 : BigText);
    BEGIN
      //<FUNC>
      //  Description: Takes the success message provided and formats it into an acceptable xml string.
      //               Typically called when no user message is required to be displayed to the user on success.
      //  Called From: Numerous application handling codeunits.
      //  Side Effect: None
      //</FUNC>

      pbsOutput.ADDTEXT( STRSUBSTNO('<SUCCESS>%1</SUCCESS>',piSuccessCode) );
    END;

    PROCEDURE generateSuccessReturnWithMsg@1000000018(piSuccessCode@1000000001 : Integer;psMessage@1000000000 : Text;VAR pbsOutput@1000000003 : BigText);
    VAR
      lbsXMLOutput@1000000002 : BigText;
    BEGIN
      //<FUNC>
      //  Description: Takes the success message provided and additional user message and formats it into an acceptable xml string.
      //  Called From: Numerous application handling codeunits.
      //  Side Effect: None
      //</FUNC>

      pbsOutput.ADDTEXT( '<RESULT>' );
      pbsOutput.ADDTEXT( STRSUBSTNO('<SUCCESS>%1</SUCCESS>',piSuccessCode) );
      pbsOutput.ADDTEXT( STRSUBSTNO('<MESSAGE>%1</MESSAGE>',escapeText(psMessage)) );
      pbsOutput.ADDTEXT( '</RESULT>' );
    END;

    PROCEDURE addSuccessMessageNoReturn@1000000035(piSuccessCode@1000000001 : Integer;psMessage@1000000000 : Text;VAR pbsOutput@1000000003 : BigText);
    VAR
      lbsXMLOutput@1000000002 : BigText;
    BEGIN
      //<FUNC>
      //  Description: Takes the success message provided and additional user message and formats it into an acceptable xml string.
      //               Deprecated.  Use generateSuccessReturnWithMsg()
      //  Called From:
      //  Side Effect: None
      //</FUNC>

      pbsOutput.ADDTEXT( STRSUBSTNO('<SUCCESS>%1</SUCCESS>',piSuccessCode) );
      pbsOutput.ADDTEXT( STRSUBSTNO('<MESSAGE>%1</MESSAGE>',escapeText(psMessage)) );
    END;

    PROCEDURE addMessage@1000000037(psMessage@1000000000 : Text;VAR pbsOutput@1000000003 : BigText);
    VAR
      lbsXMLOutput@1000000002 : BigText;
    BEGIN
      //<FUNC>
      //  Description: Adds a user message and formats it into an acceptable xml string.
      //  Called From: "WHI Physical Inv. Mgmt."::"getPageEntries"
      //               "WHI Physical Inv. Mgmt."::"getCountSheetLines"
      //               "License Plate Mgmt."::"testLPCharacteristicsInWS"
      //  Side Effect: None
      //</FUNC>

      pbsOutput.ADDTEXT( STRSUBSTNO('<MESSAGE>%1</MESSAGE>',escapeText(psMessage)) );
    END;

    PROCEDURE addComment@1000000031(psCommentText@1000000000 : Text;VAR pbsOutput@1000000001 : BigText);
    BEGIN
      //<FUNC>
      //  Description: Adds an XML comment to the output.  Use for debugging.
      //  Called From: "addDSColumnsFromConfigOverVis"
      //               "WHI Misc. Mgmt."::"decodeItemBarcode"
      //  Side Effect: None
      //</FUNC>

      IF( '' <> psCommentText ) THEN BEGIN
        // using a CData comment so that we can just write as is.
        pbsOutput.ADDTEXT( '<![CDATA[ ');
        pbsOutput.ADDTEXT( psCommentText );
        pbsOutput.ADDTEXT( ' ]]>'  );
      END;
    END;

    PROCEDURE addCommentDN@1000000061(psCommentText@1000000000 : Text;VAR pdnOutput@1000100001 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder");
    BEGIN
      //<FUNC>
      //  Description: Adds an XML comment to the output.  Use for debugging.
      //  Called From: "addDSColumnFromConfigOverVisDN"
      //  Side Effect: None
      //</FUNC>

      IF( '' <> psCommentText ) THEN BEGIN
        // using a CData comment so that we can just write as is.
        pdnOutput.Append( '<![CDATA[ ');
        pdnOutput.Append( psCommentText );
        pdnOutput.Append( ' ]]>'  );
      END;
    END;

    PROCEDURE formatDate@1000000024(pdtDate@1000000000 : Date) : Text[10];
    BEGIN
      //<FUNC>
      //  Description: Formats the supplied Navision date into a standardized format of: yyyy-mm-dd
      //               For null dates a blank string will be returned.
      //  Called From:
      //  Side Effect: None
      //</FUNC>

      // format the date or else return blank
      IF( pdtDate <> 0D ) THEN
        EXIT( STRSUBSTNO('%1-%2-%3',DATE2DMY(pdtDate,2),DATE2DMY(pdtDate,1)) )
      ELSE
        EXIT( '' );
    END;

    PROCEDURE escapeText@1000000002(psText@1000000000 : Text) : Text;
    BEGIN
      //<FUNC>
      //  Description: Replaces the supplied text invalid xml characters with their appropriate escape sequences.
      //  Called From: Numerous application handling codeunits.
      //  Side Effect: None
      //</FUNC>

      // escape the invalid character types
      psText := TextReplace(psText,'&','&amp;');
      psText := TextReplace(psText,'<','&lt;');
      psText := TextReplace(psText,'>','&gt;');
      psText := TextReplace(psText,'"','&quot;');
      psText := TextReplace(psText,'''','&apos;');

      EXIT(psText);
    END;

    PROCEDURE TextReplace@1000000010(ltInput@1000000000 : Text;ltWhat@1000000001 : Text;ltWith@1000000002 : Text) ltOutput : Text;
    VAR
      liInputLen@1000000003 : Integer;
      liWhatLen@1000000004 : Integer;
      liFindFirst@1000000005 : Integer;
    BEGIN
      //<FUNC>
      //  Description: String manipulation routine to perform string replacements.
      //               Finds all occurances of 'ltWhat' in string 'ltInput' and replaces them with 'ltWith'
      //  Called From: "escapeText"
      //  Side Effect: None
      //</FUNC>

      // Function returns 'ltOutput'.
      liInputLen := STRLEN(ltInput);
      liWhatLen := STRLEN(ltWhat);

      // check, if ltInput and ltWhat are not empty strings
      IF (liInputLen > 0) AND (liWhatLen > 0) THEN BEGIN
        liFindFirst := STRPOS(ltInput, ltWhat);
        WHILE (liFindFirst > 0) DO BEGIN
          ltOutput := ltOutput + COPYSTR(ltInput, 1, liFindFirst - 1);
          ltOutput := ltOutput + ltWith;
          ltInput := DELSTR(ltInput,1,liFindFirst + liWhatLen - 1);
          liFindFirst := STRPOS(ltInput, ltWhat);
        END;

        ltOutput := ltOutput + ltInput;
      END
      ELSE BEGIN
        ltOutput := ltInput;
      END;
    END;

    PROCEDURE getTrueFalse@1000000064(pbValue@1000000000 : Boolean) : Text[1];
    BEGIN
      //<FUNC>
      //  Description: Returns 1 or 0 for bool passed in.
      //               Makes conversion in C# client code less error prone.
      //  Called From: "addDSColumnWithEditor"
      //               "addDSColumnWithEditorDN"
      //  Side Effect: None
      //</FUNC>

      IF pbValue THEN
        EXIT('1');

      EXIT('0');
    END;

    PROCEDURE initializeColumns@1000000027(pbResetColumnDefinition@1000000000 : Boolean);
    BEGIN
      //<FUNC>
      //  Description: Sets the global column index and optionally clears the column arrays.
      //               Called prior to generating a dataset result.
      //  Called From: Numerous application handling codeunits.
      //  Side Effect: None
      //</FUNC>


      bWriteColumnHeader := TRUE;

      iColumnIndex := 0;

      IF ( pbResetColumnDefinition ) THEN BEGIN
        trecColumns.RESET();
        IF ( trecColumns.FIND('-') ) THEN BEGIN
          trecColumns.DELETEALL(); // temporary record, ok.
        END;

        trecColumnsVisibleOverride.RESET();
        IF ( trecColumnsVisibleOverride.FIND('-') ) THEN BEGIN
          trecColumnsVisibleOverride.DELETEALL(); // temporary record, ok.
        END;
      END;
    END;

    PROCEDURE initVariantColumnIndex@1000000014();
    BEGIN
      //<FUNC>
      //  Description: Sets the global column index back to zero.
      //               Called prior to generating a dataset result.
      //  Called From: Numerous application handling codeunits.
      //  Side Effect: None
      //</FUNC>

      initializeColumns( FALSE );
    END;

    PROCEDURE getColumnType@1000000012(pvarValue@1000000000 : Variant) lsType : Text[2];
    BEGIN
      //<FUNC>
      //  Description: Determines the column type for the dataset based on the variant.
      //  Called From: "addDSColumnWithEditor"
      //               "addDSColumnWithEditorDN"
      //  Side Effect: None
      //</FUNC>

      CASE TRUE OF
        pvarValue.ISCODE: lsType := 's';
        pvarValue.ISTEXT: lsType := 's';
        pvarValue.ISDECIMAL: lsType := 'd';
        pvarValue.ISINTEGER: lsType := 'i';
        pvarValue.ISBOOLEAN: lsType := 'b';
        pvarValue.ISDATE: lsType := 'dt';
        pvarValue.ISTIME: lsType := 'dt'; //nope not a datetime
        pvarValue.ISOPTION: lsType := 'o';
        ELSE BEGIN
          // special case for datetime since I don't know what it is or how to handle it
          lsType := 'dt';
        END;
      END;

      EXIT(lsType);
    END;

    PROCEDURE getColumnDefaultsFromDB@1000000015(piTableNo@1000000000 : Integer;piFieldNo@1000000001 : Integer;VAR pcodOUTDataType@1000000004 : Code[10];VAR ptxtOUTFieldName@1000000005 : Text;VAR ptxtOUTFieldCaption@1000000006 : Text);
    VAR
      lrrefTable@1000000002 : RecordRef;
      lfrefField@1000000003 : FieldRef;
    BEGIN
      //<FUNC>
      //  Description: Dynamics NAV column type to device column type.
      //  Called From: "WHI Auto Setup"::"addDSColumnWithEditor"
      //  Side Effect: None
      //</FUNC>

      lrrefTable.OPEN( piTableNo );
      lfrefField := lrrefTable.FIELD( piFieldNo );


      // Doing FORMAT, because the option TYPE doesn't seem to work.
      CASE FORMAT( lfrefField.TYPE ) OF
        'Code':   pcodOUTDataType := 's';
        'Text':   pcodOUTDataType := 's';
        'Decimal' : pcodOUTDataType := 'd';
        'Integer': pcodOUTDataType := 'i';
        'Boolean' : pcodOUTDataType := 'b';
        'Date' : pcodOUTDataType := 'dt';
        'Time' : pcodOUTDataType := 'dt'; //nope not a datetime
        'DateTime' : pcodOUTDataType := 'dt'; //nope not a datetime
        'Option' : pcodOUTDataType := 'o';
        'Char' : pcodOUTDataType := 's';
        ELSE
          // lsType := 'dt';
      END;

      ptxtOUTFieldName := COPYSTR( lfrefField.NAME, 1, MAXSTRLEN(ptxtOUTFieldName ) );
      ptxtOUTFieldCaption := COPYSTR( lfrefField.CAPTION, 1, MAXSTRLEN( ptxtOUTFieldCaption ) );
    END;

    PROCEDURE addDSColumnsFromConfig@1000000011(VAR pbsXMLOutput@1000000005 : BigText;piEvent@1000000000 : Integer;pcodSubCategory@1000000003 : Code[20];piTableNo@1000000001 : Integer);
    VAR
      lrecPDAColumns@1000000002 : Record 23044512;
      ltxtToUseForName@1000000004 : Text[100];
    BEGIN
      //<FUNC>
      //  Description: Builds up the table column headers for the specified event.
      //  Called From: Numerous application handling codeunits.
      //  Side Effect: None
      //</FUNC>

      addDSColumnsFromConfigOverVis(
        pbsXMLOutput,
        piEvent,
        pcodSubCategory,
        piTableNo,
        -888 );
    END;

    PROCEDURE addDSColumnsFromConfigDN@1000000059(VAR pdnOutput@1000000005 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder";piEvent@1000000000 : Integer;pcodSubCategory@1000000003 : Code[20];piTableNo@1000000001 : Integer);
    VAR
      lrecPDAColumns@1000000002 : Record 23044512;
      ltxtToUseForName@1000000004 : Text[100];
    BEGIN
      //<FUNC>
      //  Description: Builds up the table column headers for the specified event.
      //  Called From: Numerous application handling codeunits.
      //  Side Effect: None
      //</FUNC>

      addDSColumnFromConfigOverVisDN(
        pdnOutput,
        piEvent,
        pcodSubCategory,
        piTableNo,
        -888 );
    END;

    PROCEDURE addDSColumnsFromConfigOverVis@1000000026(VAR pbsXMLOutput@1000000005 : BigText;piEvent@1000000000 : Integer;pcodSubCategory@1000000003 : Code[20];piTableNo@1000000001 : Integer;piOverrideVisible@1000000006 : Integer);
    VAR
      lrecColumns@1000000002 : Record 23044512;
      lrecTranslationValue@1000000016 : Record 23044518;
      ltrecTempColumnBuffer@100000000 : TEMPORARY Record 23044512;
      ltxtToUseForName@1000000004 : Text[100];
      lbVisible@1000000007 : Boolean;
      ltxtCSVOptions@1000000008 : Text;
      lrrefValue@1000000009 : RecordRef;
      lfrefFieldValue@1000000010 : FieldRef;
      lbShowCaption@1000000013 : Boolean;
      lsCaption@1000000014 : Text[100];
      lcodRegion@1000000015 : Code[10];
    BEGIN
      //<FUNC>
      //  Description: Builds up the table column headers for the specified event.
      //               piOverrideVisible behavior:
      //                 -999 = no override visible
      //                 -888 = lookup override set with setDSFieldVisible
      //                 111 = override to true
      //                 222 = override visible to false
      //  Called From: "addDSColumnsFromConfig"
      //  Side Effect: None
      //</FUNC>


      lrecColumns.RESET();
      lrecColumns.SETRANGE("Event", piEvent );
      lrecColumns.SETRANGE("Sub Category", pcodSubCategory );
      lrecColumns.SETRANGE("Table No.", piTableNo );

      lrecColumns.SETCURRENTKEY("Event","Sub Category","Table No.","Field Order","Field No.");
      lrecColumns.ASCENDING(TRUE); // we want field order before field no.
      lrecColumns.FIND('-');

      // avoid multiple open table
      IF (  piTableNo > 0 ) THEN BEGIN
        lrrefValue.OPEN(piTableNo);
      END;

      REPEAT
        ltxtCSVOptions := '';

        // building up the temporary recordset so we can just write records
        // afterwards
        trecColumns.INIT();
        trecColumns := lrecColumns;
        IF ( trecColumns.INSERT() ) THEN; // then nothing

        ltxtToUseForName := COPYSTR( lrecColumns."Override Field Name", 1, MAXSTRLEN( ltxtToUseForName) );
        IF ( '' = ltxtToUseForName ) THEN BEGIN
          // no specific override, just use whatever is configured in NAV.
          lrecColumns.CALCFIELDS(lrecColumns."Field Name in NAV");
          ltxtToUseForName := COPYSTR( lrecColumns."Field Name in NAV", 1, MAXSTRLEN( ltxtToUseForName) );
        END;

        // check for duplicate columns since the primary key does not prevent this
        ltrecTempColumnBuffer.RESET;
        ltrecTempColumnBuffer.SETRANGE("Override Field Name", ltxtToUseForName);
        IF ltrecTempColumnBuffer.FINDFIRST THEN
          ERROR(tcDuplicateFieldNameLbl,ltxtToUseForName, lrecColumns."Event", lrecColumns."Table No.");
        ltrecTempColumnBuffer := lrecColumns;
        ltrecTempColumnBuffer.INSERT;




        lbVisible := lrecColumns."Column Visible";
        IF ( 111 =piOverrideVisible ) THEN BEGIN
          lbVisible := TRUE;
        END ELSE IF ( 222 =piOverrideVisible ) THEN BEGIN
          lbVisible := FALSE;
        END ELSE IF ( -888 = piOverrideVisible ) THEN BEGIN
          trecColumnsVisibleOverride.RESET();
          trecColumnsVisibleOverride.SETRANGE("Event", piEvent );
          trecColumnsVisibleOverride.SETRANGE("Sub Category", pcodSubCategory );
          trecColumnsVisibleOverride.SETRANGE("Table No.", piTableNo );
          trecColumnsVisibleOverride.SETRANGE("Field No.", lrecColumns."Field No." );
          IF ( trecColumnsVisibleOverride.FIND('-') ) THEN BEGIN
            lbVisible := trecColumnsVisibleOverride."Column Visible";
          END;
        END;

        lsCaption := getColumnCaption(lrecColumns);

        IF( ( lrecColumns."Device Data Type" = 'O' ) AND (piTableNo > 0 )
         AND (lrecColumns."Field No." > 0  ) )  THEN BEGIN
          lfrefFieldValue := lrrefValue.FIELD( lrecColumns."Field No." );
          ltxtCSVOptions := lfrefFieldValue.OPTIONCAPTION;
        END;

        IF( (ltxtCSVOptions='') AND (lrecColumns."Override Value" <>'') AND (lrecColumns.Editor = lrecColumns.Editor::ComboBox) ) THEN BEGIN
          ltxtCSVOptions := CalcFormulaForCSV(lrrefValue,lrecColumns."Override Value");
        END;

        IF (lrecColumns."Show Caption" = lrecColumns."Show Caption"::Yes) THEN BEGIN
          lbShowCaption := TRUE;
        END ELSE BEGIN
          lbShowCaption := FALSE;
        END;

        bIsConfigurableColumn := TRUE;
        addDSColumnWithShowCaption(
          pbsXMLOutput,
          lrecColumns."Device Data Type",
          '', // we're supplying, not infering the data type
          lbVisible,
          lrecColumns."Column Width",
          lsCaption, // caption
          ltxtToUseForName, // name of the field
           lrecColumns.Editor,
           ltxtCSVOptions,
           lbShowCaption);
        bIsConfigurableColumn := FALSE;

      UNTIL( 0 = lrecColumns.NEXT() );
    END;

    PROCEDURE addDSColumnFromConfigOverVisDN@1000000060(VAR pdnOutput@1000000005 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder";piEvent@1000000000 : Integer;pcodSubCategory@1000000003 : Code[20];piTableNo@1000000001 : Integer;piOverrideVisible@1000000006 : Integer);
    VAR
      lrecColumns@1000000002 : Record 23044512;
      ltrecTempColumnBuffer@100000000 : TEMPORARY Record 23044512;
      ltxtToUseForName@1000000004 : Text[100];
      lbVisible@1000000007 : Boolean;
      ltxtCSVOptions@1000000008 : Text;
      lrrefValue@1000000009 : RecordRef;
      lfrefFieldValue@1000000010 : FieldRef;
      lbShowCaption@1000000013 : Boolean;
      lsCaption@1000000014 : Text;
    BEGIN
      //<FUNC>
      //  Description: Builds up the table column headers for the specified event.
      //               piOverrideVisible behavior:
      //                 -999 = no override visible
      //                 -888 = lookup override set with setDSFieldVisible
      //                 111 = override to true
      //                 222 = override visible to false
      //  Called From: "addDSColumnsFromConfigDN"
      //  Side Effect: None
      //</FUNC>

      lrecColumns.RESET();
      lrecColumns.SETRANGE("Event", piEvent );
      lrecColumns.SETRANGE("Sub Category", pcodSubCategory );
      lrecColumns.SETRANGE("Table No.", piTableNo );

      lrecColumns.SETCURRENTKEY("Event","Sub Category","Table No.","Field Order","Field No.");
      lrecColumns.ASCENDING(TRUE); // we want field order before field no.
      lrecColumns.FIND('-');

      // avoid multiple open table
      IF (  piTableNo > 0 ) THEN BEGIN
        lrrefValue.OPEN(piTableNo);
      END;

      REPEAT
        ltxtCSVOptions := '';

        // building up the temporary recordset so we can just write records
        // afterwards
        trecColumns.INIT();
        trecColumns := lrecColumns;
        IF ( trecColumns.INSERT() ) THEN; // then nothing

        ltxtToUseForName := COPYSTR( lrecColumns."Override Field Name", 1, MAXSTRLEN( ltxtToUseForName) );
        IF ( '' = ltxtToUseForName ) THEN BEGIN
          // no specific override, just use whatever is configured in NAV.
          lrecColumns.CALCFIELDS(lrecColumns."Field Name in NAV");
          ltxtToUseForName := COPYSTR( lrecColumns."Field Name in NAV", 1, MAXSTRLEN( ltxtToUseForName) );
        END;

        // check for duplicate columns since the primary key does not prevent this
        ltrecTempColumnBuffer.RESET;
        ltrecTempColumnBuffer.SETRANGE("Override Field Name", ltxtToUseForName);
        IF ltrecTempColumnBuffer.FINDFIRST THEN
          ERROR(tcDuplicateFieldNameLbl,ltxtToUseForName, lrecColumns."Event", lrecColumns."Table No.");
        ltrecTempColumnBuffer := lrecColumns;
        ltrecTempColumnBuffer.INSERT;


        lbVisible := lrecColumns."Column Visible";
        IF ( 111 =piOverrideVisible ) THEN BEGIN
          lbVisible := TRUE;
        END ELSE IF ( 222 =piOverrideVisible ) THEN BEGIN
          lbVisible := FALSE;
        END ELSE IF ( -888 = piOverrideVisible ) THEN BEGIN
          trecColumnsVisibleOverride.RESET();
          trecColumnsVisibleOverride.SETRANGE("Event", piEvent );
          trecColumnsVisibleOverride.SETRANGE("Sub Category", pcodSubCategory );
          trecColumnsVisibleOverride.SETRANGE("Table No.", piTableNo );
          trecColumnsVisibleOverride.SETRANGE("Field No.", lrecColumns."Field No." );
          IF ( trecColumnsVisibleOverride.FIND('-') ) THEN BEGIN
            lbVisible := trecColumnsVisibleOverride."Column Visible";
          END;

        END;

        IF( ( lrecColumns."Device Data Type" = 'O' ) AND (piTableNo > 0 )
         AND (lrecColumns."Field No." > 0  ) )  THEN BEGIN
          lfrefFieldValue := lrrefValue.FIELD( lrecColumns."Field No." );
          ltxtCSVOptions := lfrefFieldValue.OPTIONCAPTION;
        END;

        bIsConfigurableColumn := TRUE;

        lsCaption := getColumnCaption(lrecColumns);

        IF (lrecColumns."Show Caption" = lrecColumns."Show Caption"::Yes) THEN BEGIN
          lbShowCaption := TRUE;
        END ELSE BEGIN
          lbShowCaption := FALSE;
        END;

        addDSColumnWithShowCaptionDN(
          pdnOutput,
          lrecColumns."Device Data Type",
          '', // we're supplying, not infering the data type
          lbVisible,
          lrecColumns."Column Width",
          lsCaption,
          ltxtToUseForName, // name of the field
           lrecColumns.Editor,
           ltxtCSVOptions,
           lbShowCaption);
        bIsConfigurableColumn := FALSE;

      UNTIL( 0 = lrecColumns.NEXT() );
    END;

    PROCEDURE addDSColumnTracked@1000000033(VAR pbsXMLOutput@1000000000 : BigText;pbVisible@1000000002 : Boolean;piWidth@1000000003 : Integer;psCaption@1000000004 : Text;psName@1000000005 : Text;piEvent@1000000013 : Integer;pcodSubCategory@1000000012 : Code[20];piTableNo@1000000011 : Integer;piFieldNo@1000000010 : Integer);
    BEGIN
      //<FUNC>
      //  Description: For use when you need to add a tracked column for passing in a recordref
      //               later for dumping, but are not in a position to use column configuration.
      //  Called From: "WHI Misc. Mgmt."::"genericTableLookup"
      //  Side Effect: None
      //</FUNC>

      trecColumns.INIT();
      trecColumns."Event" := piEvent;
      trecColumns."Table No." := piTableNo;
      trecColumns."Field No." := piFieldNo;

      IF ( trecColumns.INSERT() ) THEN; // then nothing

      addDSColumn(
        pbsXMLOutput,
        's',//pcodDataType,
        '', //pvarValue,
        pbVisible,
        piWidth,
        psCaption,
        psName
        );
    END;

    PROCEDURE addDSColumn@1000000008(VAR pbsXMLOutput@1000000000 : BigText;pcodDataType@1000000006 : Code[10];pvarValue@1000000001 : Variant;pbVisible@1000000002 : Boolean;piWidth@1000000003 : Integer;psCaption@1000000004 : Text;psName@1000000005 : Text);
    BEGIN
      //<FUNC>
      //  Description: Generates a standard XML format for a column based on the supplied variant.
      //               If pcodDataType is used, it will use it otherwise it will infer the datattype from pvarValue
      //  Called From: Numerous
      //  Side Effect: None
      //</FUNC>

      // addDSColumnWithEditor will return to device, what controls can be created
      // on the column, last parameter will indicate controls
       addDSColumnWithEditor(
        pbsXMLOutput,
        pcodDataType,
        pvarValue,
        pbVisible,
        piWidth,
        psCaption,
        psName,
        0, // always 0 for backwards compatibility
        '' // always blank for backwards compatibility
      );
    END;

    PROCEDURE addDSColumnDN@1000000056(VAR pdnOutput@1000000000 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder";pcodDataType@1000000006 : Code[10];pvarValue@1000000001 : Variant;pbVisible@1000000002 : Boolean;piWidth@1000000003 : Integer;psCaption@1000000004 : Text;psName@1000000005 : Text);
    BEGIN
      //<FUNC>
      //  Description: Generates a standard XML format for a column based on the supplied variant.
      //               If pcodDataType is used, it will use it otherwise it will infer the datattype from pvarValue
      //  Called From: Numerous
      //  Side Effect: None
      //</FUNC>

      // addDSColumnWithEditor will return to device, what controls can be created
      // on the column, last parameter will indicate controls
       addDSColumnWithEditorDN(
        pdnOutput,
        pcodDataType,
        pvarValue,
        pbVisible,
        piWidth,
        psCaption,
        psName,
        0, // always 0 for backwards compatibility
        '' // always blank for backwards compatibility
      );
    END;

    PROCEDURE addDSColumnWithEditor@1000000046(VAR pbsXMLOutput@1000000000 : BigText;pcodDataType@1000000006 : Code[10];pvarValue@1000000001 : Variant;pbVisible@1000000002 : Boolean;piWidth@1000000003 : Integer;psCaption@1000000004 : Text;psName@1000000005 : Text;piEditControl@1000000007 : Integer;ptxtCSVOptions@1000000008 : Text);
    BEGIN
      //<FUNC>
      //  Description: Generates a standard XML format for a column based on the supplied variant.
      //               If pcodDataType is used, it will use it otherwise it will infer the datattype from pvarValue
      //  Called From: "addDSColumnsFromConfigOverVis"
      //               "addDSColumn"
      //  Side Effect: None
      //</FUNC>

      addDSColumnWithShowCaption(
                                pbsXMLOutput,
                                pcodDataType,
                                pvarValue,
                                pbVisible,
                                piWidth,
                                psCaption,
                                psName,
                                0,  // always 0 for backwards compatibility
                                '', // always blank for backwards compatibility
                                TRUE
                                );
    END;

    PROCEDURE addDSColumnWithEditorDN@1000000058(VAR pdnOutput@1000000000 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder";pcodDataType@1000000006 : Code[10];pvarValue@1000000001 : Variant;pbVisible@1000000002 : Boolean;piWidth@1000000003 : Integer;psCaption@1000000004 : Text;psName@1000000005 : Text;piEditControl@1000000007 : Integer;ptxtCSVOptions@1000000008 : Text);
    BEGIN
      //<FUNC>
      //  Description: Generates a standard XML format for a column based on the supplied variant.
      //               If pcodDataType is used, it will use it otherwise it will infer the datattype from pvarValue
      //  Called From: "addDSColumnFromConfigOverVisDN"
      //               "addDSColumnDN"
      //  Side Effect: None
      //</FUNC>

      addDSColumnWithShowCaptionDN(
                                pdnOutput,
                                pcodDataType,
                                pvarValue,
                                pbVisible,
                                piWidth,
                                psCaption,
                                psName,
                                0,  // always 0 for backwards compatibility
                                '', // always blank for backwards compatibility
                                TRUE
                                );
    END;

    PROCEDURE addDSField@1000000020(VAR pbsXMLOutput@1000000000 : BigText;pvarValue@1000000001 : Variant);
    VAR
      lbBool@1000000002 : Boolean;
    BEGIN
      //<FUNC>
      //  Description: Generates a standard XML format for a field based on the supplied variant.
      //  Called From: Numerous
      //  Side Effect: None
      //</FUNC>

      IF ( pvarValue.ISBOOLEAN ) THEN BEGIN
        lbBool := pvarValue;
        IF ( lbBool ) THEN BEGIN
          addDSFieldText( pbsXMLOutput, '1' );
        END ELSE BEGIN
          addDSFieldText( pbsXMLOutput, '0' );
        END;
      END ELSE BEGIN
        addDSFieldText( pbsXMLOutput, FORMAT(pvarValue) );
      END;
    END;

    PROCEDURE addDSFieldDN@1000000049(VAR pdnOutput@1000000000 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder";pvarValue@1000000001 : Variant);
    VAR
      lbBool@1000000002 : Boolean;
    BEGIN
      //<FUNC>
      //  Description: Generates a standard XML format for a field based on the supplied variant.
      //  Called From: Numerous
      //  Side Effect: None
      //</FUNC>

      IF ( pvarValue.ISBOOLEAN ) THEN BEGIN
        lbBool := pvarValue;
        IF ( lbBool ) THEN BEGIN
          addDSFieldTextDN( pdnOutput, '1' );
        END ELSE BEGIN
          addDSFieldTextDN( pdnOutput, '0' );
        END;
      END ELSE BEGIN
        addDSFieldTextDN( pdnOutput, FORMAT(pvarValue) );
      END;
    END;

    PROCEDURE addDSFieldText@1000000050(VAR pbsXMLOutput@1000000001 : BigText;ptxtValue@1000000000 : Text);
    BEGIN
      //<FUNC>
      //  Description: Generates a standard XML format for a field based on the supplied variant converted to text.
      //  Called From: "addDSField"
      //               "addDSFieldsForRecord"
      //  Side Effect: None
      //</FUNC>

      pbsXMLOutput.ADDTEXT(STRSUBSTNO('<F i="%1">%2</F>', iColumnIndex, escapeText( ptxtValue )));
      iColumnIndex := iColumnIndex + 1;
    END;

    PROCEDURE addDSFieldTextDN@1000000047(VAR pdnOutput@1000000001 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder";ptxtValue@1000000000 : Text);
    BEGIN
      //<FUNC>
      //  Description: Generates a standard XML format for a field based on the supplied variant converted to text.
      //  Called From: "addDSFieldDN"
      //               "addDSFieldsForRecordDN"
      //  Side Effect: None
      //</FUNC>

      pdnOutput.Append( STRSUBSTNO('<F i="%1">', iColumnIndex ) );
      pdnOutput.Append(escapeText(ptxtValue)); //dnSecurityElement.Escape( ptxtValue)  ); // SecurityElement.Escape replaces custom escape
      pdnOutput.Append( '</F>' );

      iColumnIndex := iColumnIndex + 1;
    END;

    PROCEDURE addDSTrackingColumns@1000000025(VAR pbsXMLOutput@1000000000 : BigText);
    VAR
      lrecItemTrack@1000000001 : Record 6502;
    BEGIN
      //<FUNC>
      //  Description: Add the item tracking info columns
      //  Called From: "Inv. Inquiry Mgmt."::"getPartData"
      //               "Shipping Mgmt."::"getWhseShipment"
      //               "Reclass Mgmt."::"getWhseReclassJournal"
      //  Side Effect: None
      //</FUNC>

      //
      addDSColumn(pbsXMLOutput,'',lrecItemTrack.Code,FALSE,0,'','Item Tracking Code');
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."Lot Specific Tracking",FALSE,0,'',lrecItemTrack.FIELDNAME("Lot Specific Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."Lot Info. Inbound Must Exist",FALSE,0,'',
        lrecItemTrack.FIELDNAME("Lot Info. Inbound Must Exist"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."Lot Info. Outbound Must Exist",FALSE,0,'',
        lrecItemTrack.FIELDNAME("Lot Info. Outbound Must Exist"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."Lot Purchase Inbound Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("Lot Purchase Inbound Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."Lot Purchase Outbound Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("Lot Purchase Outbound Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."Lot Sales Inbound Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("Lot Sales Inbound Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."Lot Sales Outbound Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("Lot Sales Outbound Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."Lot Pos. Adjmt. Inb. Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("Lot Pos. Adjmt. Inb. Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."Lot Pos. Adjmt. Outb. Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("Lot Pos. Adjmt. Outb. Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."Lot Neg. Adjmt. Inb. Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("Lot Neg. Adjmt. Inb. Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."Lot Neg. Adjmt. Outb. Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("Lot Neg. Adjmt. Outb. Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."Lot Manuf. Inbound Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("Lot Manuf. Inbound Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."Lot Manuf. Outbound Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("Lot Manuf. Outbound Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."Lot Warehouse Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("Lot Warehouse Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."Lot Transfer Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("Lot Transfer Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."Lot Assembly Inbound Tracking",FALSE,0,'',lrecItemTrack.FIELDNAME("Lot Assembly Inbound Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."Lot Assembly Outbound Tracking",FALSE,0,'',lrecItemTrack.FIELDNAME("Lot Assembly Outbound Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."SN Specific Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Specific Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."SN Info. Inbound Must Exist",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Info. Inbound Must Exist"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."SN Info. Outbound Must Exist",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Info. Outbound Must Exist"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."SN Purchase Inbound Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Purchase Inbound Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."SN Purchase Outbound Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Purchase Outbound Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."SN Sales Inbound Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Sales Inbound Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."SN Sales Outbound Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Sales Outbound Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."SN Pos. Adjmt. Inb. Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Pos. Adjmt. Inb. Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."SN Pos. Adjmt. Outb. Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Pos. Adjmt. Outb. Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."SN Neg. Adjmt. Inb. Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Neg. Adjmt. Inb. Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."SN Neg. Adjmt. Outb. Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Neg. Adjmt. Outb. Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."SN Manuf. Inbound Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Manuf. Inbound Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."SN Manuf. Outbound Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Manuf. Outbound Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."SN Warehouse Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Warehouse Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."SN Transfer Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Transfer Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."SN Assembly Inbound Tracking",FALSE,0,'',lrecItemTrack.FIELDNAME("SN Assembly Inbound Tracking"));
      addDSColumn(pbsXMLOutput,'',lrecItemTrack."SN Assembly Outbound Tracking",FALSE,0,'',lrecItemTrack.FIELDNAME("SN Assembly Outbound Tracking"));
    END;

    PROCEDURE addDSTrackingColumnsDN@1000000055(VAR pdnOutput@1000000000 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder");
    VAR
      lrecItemTrack@1000000001 : Record 6502;
    BEGIN
      //<FUNC>
      //  Description: Add the item tracking info columns
      //  Called From: "Whse. Activity Mgmt."::"getWarehouseActivityDocument"
      //               "Whse. Activity Mgmt."::"getReclassJournal"
      //               "Dataset Tools"::"BuildItemTrackingTable"
      //  Side Effect: None
      //</FUNC>

      addDSColumnDN(pdnOutput,'',lrecItemTrack.Code,FALSE,0,'','Item Tracking Code');
      addDSColumnDN(pdnOutput,'',lrecItemTrack."Lot Specific Tracking",FALSE,0,'',lrecItemTrack.FIELDNAME("Lot Specific Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."Lot Info. Inbound Must Exist",FALSE,0,'',
        lrecItemTrack.FIELDNAME("Lot Info. Inbound Must Exist"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."Lot Info. Outbound Must Exist",FALSE,0,'',
        lrecItemTrack.FIELDNAME("Lot Info. Outbound Must Exist"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."Lot Purchase Inbound Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("Lot Purchase Inbound Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."Lot Purchase Outbound Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("Lot Purchase Outbound Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."Lot Sales Inbound Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("Lot Sales Inbound Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."Lot Sales Outbound Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("Lot Sales Outbound Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."Lot Pos. Adjmt. Inb. Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("Lot Pos. Adjmt. Inb. Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."Lot Pos. Adjmt. Outb. Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("Lot Pos. Adjmt. Outb. Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."Lot Neg. Adjmt. Inb. Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("Lot Neg. Adjmt. Inb. Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."Lot Neg. Adjmt. Outb. Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("Lot Neg. Adjmt. Outb. Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."Lot Manuf. Inbound Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("Lot Manuf. Inbound Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."Lot Manuf. Outbound Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("Lot Manuf. Outbound Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."Lot Warehouse Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("Lot Warehouse Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."Lot Transfer Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("Lot Transfer Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."Lot Assembly Inbound Tracking",FALSE,0,'',lrecItemTrack.FIELDNAME("Lot Assembly Inbound Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."Lot Assembly Outbound Tracking",FALSE,0,'',lrecItemTrack.FIELDNAME("Lot Assembly Outbound Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."SN Specific Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Specific Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."SN Info. Inbound Must Exist",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Info. Inbound Must Exist"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."SN Info. Outbound Must Exist",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Info. Outbound Must Exist"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."SN Purchase Inbound Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Purchase Inbound Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."SN Purchase Outbound Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Purchase Outbound Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."SN Sales Inbound Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Sales Inbound Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."SN Sales Outbound Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Sales Outbound Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."SN Pos. Adjmt. Inb. Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Pos. Adjmt. Inb. Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."SN Pos. Adjmt. Outb. Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Pos. Adjmt. Outb. Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."SN Neg. Adjmt. Inb. Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Neg. Adjmt. Inb. Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."SN Neg. Adjmt. Outb. Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Neg. Adjmt. Outb. Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."SN Manuf. Inbound Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Manuf. Inbound Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."SN Manuf. Outbound Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Manuf. Outbound Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."SN Warehouse Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Warehouse Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."SN Transfer Tracking",FALSE,0,'',
        lrecItemTrack.FIELDNAME("SN Transfer Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."SN Assembly Inbound Tracking",FALSE,0,'',lrecItemTrack.FIELDNAME("SN Assembly Inbound Tracking"));
      addDSColumnDN(pdnOutput,'',lrecItemTrack."SN Assembly Outbound Tracking",FALSE,0,'',lrecItemTrack.FIELDNAME("SN Assembly Outbound Tracking"));
    END;

    PROCEDURE addDSTrackingFields@1000000029(VAR pbsXMLOutput@1000000001 : BigText;pcodItemTrackingCode@1000000000 : Code[10]);
    VAR
      lrecItemTrackingCode@1000000002 : Record 6502;
    BEGIN
      //<FUNC>
      //  Description: Populates the incoming xml text with the item tracking configuration in standard xml format.
      //  Called From: "Inv. Inquiry Mgmt."::"getPartData"
      //               "Shipping Mgmt."::"getWhseShipment"
      //               "Reclass Mgmt."::"getWhseReclassJournal"
      //  Side Effect: None
      //</FUNC>

      IF( lrecItemTrackingCode.GET(pcodItemTrackingCode) ) THEN BEGIN
        addDSField(pbsXMLOutput,lrecItemTrackingCode.Code);

        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."Lot Specific Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."Lot Info. Inbound Must Exist"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."Lot Info. Outbound Must Exist"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."Lot Purchase Inbound Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."Lot Purchase Outbound Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."Lot Sales Inbound Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."Lot Sales Outbound Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."Lot Pos. Adjmt. Inb. Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."Lot Pos. Adjmt. Outb. Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."Lot Neg. Adjmt. Inb. Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."Lot Neg. Adjmt. Outb. Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."Lot Manuf. Inbound Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."Lot Manuf. Outbound Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."Lot Warehouse Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."Lot Transfer Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."Lot Assembly Inbound Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."Lot Assembly Outbound Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."SN Specific Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."SN Info. Inbound Must Exist"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."SN Info. Outbound Must Exist"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."SN Purchase Inbound Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."SN Purchase Outbound Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."SN Sales Inbound Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."SN Sales Outbound Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."SN Pos. Adjmt. Inb. Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."SN Pos. Adjmt. Outb. Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."SN Neg. Adjmt. Inb. Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."SN Neg. Adjmt. Outb. Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."SN Manuf. Inbound Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."SN Manuf. Outbound Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."SN Warehouse Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."SN Transfer Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."SN Assembly Inbound Tracking"));
        addDSField(pbsXMLOutput,getTrueFalse(lrecItemTrackingCode."SN Assembly Outbound Tracking"));
      END
      ELSE BEGIN
        addDSField(pbsXMLOutput,lrecItemTrackingCode.Code);

        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
        addDSField(pbsXMLOutput,'0');
      END;
    END;

    PROCEDURE addDSTrackingFieldsDN@1000000054(VAR pdnOutput@1000000001 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder";pcodItemTrackingCode@1000000000 : Code[10]);
    VAR
      lrecItemTrackingCode@1000000002 : Record 6502;
    BEGIN
      //<FUNC>
      //  Description: Populates the incoming xml text with the item tracking configuration in standard xml format.
      //  Called From: "Whse. Activity Mgmt."::"getWarehouseActivityDocument"
      //               "Whse. Activity Mgmt."::"getReclassJournal"
      //               "Dataset Tools"::"BuildItemTrackingTable"
      //  Side Effect: None
      //</FUNC>

      IF( lrecItemTrackingCode.GET(pcodItemTrackingCode) ) THEN BEGIN
        addDSFieldDN(pdnOutput,lrecItemTrackingCode.Code);

        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."Lot Specific Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."Lot Info. Inbound Must Exist"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."Lot Info. Outbound Must Exist"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."Lot Purchase Inbound Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."Lot Purchase Outbound Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."Lot Sales Inbound Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."Lot Sales Outbound Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."Lot Pos. Adjmt. Inb. Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."Lot Pos. Adjmt. Outb. Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."Lot Neg. Adjmt. Inb. Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."Lot Neg. Adjmt. Outb. Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."Lot Manuf. Inbound Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."Lot Manuf. Outbound Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."Lot Warehouse Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."Lot Transfer Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."Lot Assembly Inbound Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."Lot Assembly Outbound Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."SN Specific Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."SN Info. Inbound Must Exist"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."SN Info. Outbound Must Exist"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."SN Purchase Inbound Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."SN Purchase Outbound Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."SN Sales Inbound Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."SN Sales Outbound Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."SN Pos. Adjmt. Inb. Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."SN Pos. Adjmt. Outb. Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."SN Neg. Adjmt. Inb. Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."SN Neg. Adjmt. Outb. Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."SN Manuf. Inbound Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."SN Manuf. Outbound Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."SN Warehouse Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."SN Transfer Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."SN Assembly Inbound Tracking"));
        addDSFieldDN(pdnOutput,getTrueFalse(lrecItemTrackingCode."SN Assembly Outbound Tracking"));
      END
      ELSE BEGIN
        addDSFieldDN(pdnOutput,lrecItemTrackingCode.Code);
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
        addDSFieldDN(pdnOutput,'0');
      END;
    END;

    PROCEDURE addDSFieldsForRecord@1000000022(VAR pbsXMLOutput@1000000003 : BigText;VAR prrefRecordRef@1000000000 : RecordRef;piEventID@1000000001 : Integer;pcodSubCategory@1000000002 : Code[10]);
    VAR
      lfrefField@1000000004 : FieldRef;
      liOptionValue@1000000005 : Integer;
      lvarTempValue@1000000006 : Variant;
    BEGIN
      //<FUNC>
      //  Description: Based on the supplied record build the xml string data.
      //  Called From: Numerous
      //  Side Effect: None
      //</FUNC>


      // we're writing all of the records here, we need to initialize the column counter back to 0.
      iColumnIndex := 0;

      trecColumns.RESET();

      trecColumns.SETCURRENTKEY("Event","Sub Category","Table No.","Field Order","Field No.");
      trecColumns.ASCENDING(TRUE); // we want field order before field no.
      //
      // The sort is important, because it MUST match the order
      // of the column header definitions.

      trecColumns.FIND('-');

      // the order is important.
      REPEAT
        IF ( trecColumns."Field No." > 0 ) THEN BEGIN
          lfrefField := prrefRecordRef.FIELD( trecColumns."Field No." );
          IF ( 'FlowField' = FORMAT(lfrefField.CLASS) ) THEN BEGIN
            IF ( lfrefField.CALCFIELD() ) THEN; // don't fail
          END;

          // get the variant field value
          lvarTempValue := lfrefField.VALUE;

          // check if there is an override.
          IF ( trecColumns."Is Formula" ) THEN BEGIN
            lvarTempValue := CalcFormula( prrefRecordRef, trecColumns."Override Value" );
          END ELSE
          IF ( '' <> trecColumns."Override Value" ) THEN BEGIN
            IF( (trecColumns.Editor <> trecColumns.Editor::ComboBox) AND (trecColumns."Device Data Type"='S') )  THEN BEGIN
              lvarTempValue := trecColumns."Override Value";
            END;
          END;

          IF ( 'O' = trecColumns."Device Data Type"  ) THEN BEGIN
            // cast to an int first for option data type
            liOptionValue := lvarTempValue;
            addDSFieldText( pbsXMLOutput, FORMAT( liOptionValue )  );
          END ELSE BEGIN
            addDSField( pbsXMLOutput, lvarTempValue );
          END;
        END ELSE BEGIN
          // this is a simulated field, do not add from a record.
          IF ( trecColumns."Is Formula" ) THEN BEGIN
            addDSFieldText( pbsXMLOutput, CalcFormula( prrefRecordRef, trecColumns."Override Value" ) );
          END ELSE BEGIN
            IF trecColumns."Override Value" = 'dummy_override_value' THEN
              trecColumns."Override Value" := '';

            // this is a simulated field, do not add from a record.
            addDSFieldText( pbsXMLOutput, trecColumns."Override Value" );
          END;
        END;
      UNTIL( 0 = trecColumns.NEXT() );
    END;

    PROCEDURE addDSFieldsForRecordDN@1000000045(VAR pdnOutput@1000000003 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder";VAR prrefRecordRef@1000000000 : RecordRef;piEventID@1000000001 : Integer;pcodSubCategory@1000000002 : Code[10]);
    VAR
      lfrefField@1000000004 : FieldRef;
      liOptionValue@1000000005 : Integer;
      lvarTempValue@1000000006 : Variant;
    BEGIN
      //<FUNC>
      //  Description: Based on the supplied record build the xml string data.
      //  Called From: Numerous
      //  Side Effect: None
      //</FUNC>

      // we're writing all of the records here, we need to initialize the column counter back to 0.
      iColumnIndex := 0;

      trecColumns.RESET();

      trecColumns.SETCURRENTKEY("Event","Sub Category","Table No.","Field Order","Field No.");
      trecColumns.ASCENDING(TRUE); // we want field order before field no.
      //
      // The sort is important, because it MUST match the order
      // of the column header definitions.

      trecColumns.FIND('-');

      // the order is important.
      REPEAT
        lvarTempValue := '';

        IF ( trecColumns."Field No." > 0 ) THEN BEGIN
          lfrefField := prrefRecordRef.FIELD( trecColumns."Field No." );
          IF ( 'FlowField' = FORMAT(lfrefField.CLASS) ) THEN BEGIN
            IF ( lfrefField.CALCFIELD() ) THEN; // don't fail
          END;

          // get the variant field value
          lvarTempValue := lfrefField.VALUE;

          // all code below here must NOT use lfrefField.Value
          // check if there is an override.
          IF ( trecColumns."Is Formula" ) THEN BEGIN
            lvarTempValue := CalcFormula( prrefRecordRef, trecColumns."Override Value" );
          END ELSE
          IF ( '' <> trecColumns."Override Value" ) THEN BEGIN
            lvarTempValue := trecColumns."Override Value";
          END;

          IF ( 'O' = trecColumns."Device Data Type"  ) THEN BEGIN
            // cast to an int first for option data type
            liOptionValue := lvarTempValue;
            addDSFieldTextDN( pdnOutput, FORMAT( liOptionValue )  );
          END ELSE BEGIN
            addDSFieldDN( pdnOutput, lvarTempValue );
          END;
        END ELSE BEGIN
          // this is a simulated field, do not add from a record.
          IF ( trecColumns."Is Formula" ) THEN BEGIN
            addDSFieldTextDN( pdnOutput, CalcFormula( prrefRecordRef, trecColumns."Override Value" ) );
          END ELSE BEGIN
            IF trecColumns."Override Value" = 'dummy_override_value' THEN
              trecColumns."Override Value" := '';

            addDSFieldTextDN( pdnOutput, trecColumns."Override Value" );
          END;
        END
      UNTIL( 0 = trecColumns.NEXT() );
    END;

    PROCEDURE setDSFieldOverrideValue@1000000005(piEventID@1000000001 : Integer;pcodSubCategory@1000000000 : Code[10];piTableNo@1000000003 : Integer;piFieldNo@1000000004 : Integer;ptxtOverrideValue@1000000002 : Text);
    BEGIN
      //<FUNC>
      //  Description: Used to set temporary overrides, for cases such as calculated columns.
      //  Called From: Numerous
      //  Side Effect: None
      //</FUNC>

      trecColumns.SETRANGE("Event", piEventID );
      trecColumns.SETRANGE("Sub Category", pcodSubCategory );
      trecColumns.SETRANGE("Table No.", piTableNo );
      trecColumns.SETRANGE("Field No.", piFieldNo );
      IF ( trecColumns.FIND('-') ) THEN BEGIN
        trecColumns.VALIDATE( "Override Value", COPYSTR( ptxtOverrideValue, 1, MAXSTRLEN( trecColumns."Override Value" )  ) );
        trecColumns.MODIFY(FALSE);
      END;
      trecColumns.RESET();
    END;

    PROCEDURE setDSFieldVisible@1000000028(piEventID@1000000001 : Integer;pcodSubCategory@1000000000 : Code[10];piTableNo@1000000003 : Integer;piFieldNo@1000000004 : Integer;pbVisible@1000000002 : Boolean);
    BEGIN
      //<FUNC>
      //  Description: Used to set/override column visibility.
      //  Called From: "Shipping Mgmt."::"getWhseShipment"
      //               "Whse. Activity Mgmt."::"getWarehouseActivityDocument"
      //  Side Effect: None
      //</FUNC>

      trecColumnsVisibleOverride.RESET();
      trecColumnsVisibleOverride.SETRANGE("Event", piEventID );
      trecColumnsVisibleOverride.SETRANGE("Sub Category", pcodSubCategory );
      trecColumnsVisibleOverride.SETRANGE("Table No.", piTableNo );
      trecColumnsVisibleOverride.SETRANGE("Field No.", piFieldNo );
      IF ( trecColumnsVisibleOverride.FIND('-') ) THEN BEGIN
        trecColumnsVisibleOverride.VALIDATE( "Column Visible", pbVisible );
        trecColumnsVisibleOverride.MODIFY(FALSE);
      END ELSE BEGIN
        trecColumnsVisibleOverride.INIT();
        trecColumnsVisibleOverride."Event" := piEventID;
        trecColumnsVisibleOverride."Sub Category" := pcodSubCategory;
        trecColumnsVisibleOverride."Table No." := piTableNo;
        trecColumnsVisibleOverride."Field No." := piFieldNo;
        trecColumnsVisibleOverride."Column Visible" := pbVisible;
        trecColumnsVisibleOverride.INSERT(FALSE);
      END;
      trecColumnsVisibleOverride.RESET();
    END;

    PROCEDURE getTemplate@1000000006(piFormID@1000000000 : Integer) : Code[10];
    VAR
      lrecItemJnlTemplate@1000000001 : Record 82;
    BEGIN
      //<FUNC>
      //  Description: Returns the item journal template based on the form usage.
      //  Called From: "Inv. Inquiry Mgmt."::"addItemJournalLine"
      //  Side Effect: None
      //</FUNC>

      lrecItemJnlTemplate.SETRANGE("Page ID",piFormID);
      lrecItemJnlTemplate.SETRANGE(Recurring,FALSE);
      lrecItemJnlTemplate.FINDFIRST;
      EXIT(lrecItemJnlTemplate.Name);
    END;

    PROCEDURE getWhseTemplate@1000000068(piPageID@1000000000 : Integer) : Code[10];
    VAR
      lrecWhseJnlTemplate@1000000001 : Record 7309;
    BEGIN
      //<FUNC>
      //  Description: Returns the whse. item journal template based on the form usage.
      //  Called From:
      //  Side Effect: None
      //</FUNC>

      lrecWhseJnlTemplate.SETRANGE("Page ID",piPageID);
      lrecWhseJnlTemplate.FINDFIRST;
      EXIT(lrecWhseJnlTemplate.Name);
    END;

    PROCEDURE checkLocation@1000000019(pcodLocation@1000000000 : Code[10];pcodDocLocation@1000000001 : Code[10]);
    VAR
      lrecLocation@1000000003 : Record 14;
    BEGIN
      //<FUNC>
      //  Description: Simple function to validate the locations are the same and valid.
      //               Helps to eliminate errors where a different
      //               location tries to process a document not intended for it.
      //                 pcodLocation - the device location
      //                 pcodDocLocation - the location of the source document
      //  Called From: Numerous
      //  Side Effect: None
      //</FUNC>

      IF( pcodLocation <> pcodDocLocation ) THEN BEGIN
        lrecLocation.GET(pcodDocLocation);
        ERROR(cuTranslationMgmt.getTranslatedString('ERR_WRONG_LOCATION', ''),lrecLocation.Code,lrecLocation.Name);
      END;
    END;

    PROCEDURE getReservationEntries@1000000003(VAR pbsXMLOutput@1000000000 : BigText;pcodItemNumber@1000000002 : Text;pcodVariantCode@1000000010 : Text;pcodLocationCode@1000000003 : Code[20];pcodSourceID@1000000004 : Code[20];piSourceRefNumber@1000000005 : Integer;pbPositive@1000000006 : Boolean;piSourceType@1000000009 : Integer;psLotNo@1000000011 : Text;psSerialNo@1000000012 : Text);
    VAR
      lrecReservationEntry@1000000001 : Record 337;
      lrecItem@1000000007 : Record 27;
      lrecItemTrackingCode@1000000008 : Record 6502;
    BEGIN
      //<FUNC>
      //  Description: Will generate the standard xml string containing all the reservations entries based on the supplied params.
      //  Called From: "Shipping Mgmt."::"getShipmentLine"
      //  Side Effect: None
      //</FUNC>

      psLotNo := UPPERCASE(psLotNo);
      psSerialNo := UPPERCASE(psSerialNo);


      // Added psLotNo and psSerialNo to help resolve a problem with warehouse
      // picks and lot warehousehouse tracked items.
      //
      // These new parameters should *only* be supplied from the warehouse activity
      // requests.   These parameters will also *only* be used if the item being
      // requested is either lot warehouse tracked or serial warehouse tracked.
      //
      pbsXMLOutput.ADDTEXT('<RESERVATION_ENTRIES>');

      // make sure the item actually uses tracking information
      lrecItem.GET(pcodItemNumber);
      IF( lrecItemTrackingCode.GET(lrecItem."Item Tracking Code") ) THEN BEGIN
        // set up remaining filters
        lrecReservationEntry.SETRANGE(Positive,pbPositive);
        lrecReservationEntry.SETRANGE("Item No.", pcodItemNumber);
        IF ( '' <> pcodVariantCode ) THEN BEGIN
          lrecReservationEntry.SETRANGE("Variant Code", pcodVariantCode );
        END;
        lrecReservationEntry.SETRANGE("Location Code", pcodLocationCode);
        lrecReservationEntry.SETRANGE("Source ID", pcodSourceID);
        IF (pbPositive AND (piSourceType = DATABASE::"Transfer Line")) THEN BEGIN
          // Transfer in
          lrecReservationEntry.SETRANGE("Source Prod. Order Line", piSourceRefNumber);
        END ELSE BEGIN
          lrecReservationEntry.SETRANGE("Source Ref. No.",piSourceRefNumber);
        END;
        IF( piSourceType <> 0 ) THEN
          lrecReservationEntry.SETRANGE("Source Type",piSourceType);

        //
        // This was done to fix a problem where if the warehouse pick had many
        // lot warehouse pick lines, referring to a single sales line
        // then there would be too many reservation entries.
        //
        IF (lrecItemTrackingCode."Lot Warehouse Tracking") THEN BEGIN
          IF (psLotNo <> '') THEN BEGIN
            lrecReservationEntry.SETRANGE("Lot No.", psLotNo);
          END;
        END;

        IF (lrecItemTrackingCode."SN Warehouse Tracking") THEN BEGIN
          IF (psSerialNo <> '') THEN BEGIN
             lrecReservationEntry.SETRANGE("Serial No.", psSerialNo);
          END;
        END;


        // iterate through the reservations found and add to xml
        // Changed to Findset(false) to have a read-only cursor for performance
        // improvements.
        IF( lrecReservationEntry.FINDSET(FALSE) ) THEN BEGIN
          REPEAT
            getReservationEntry(lrecReservationEntry, pbsXMLOutput);
          UNTIL(lrecReservationEntry.NEXT=0);
        END;
      END;

      pbsXMLOutput.ADDTEXT('</RESERVATION_ENTRIES>');
    END;

    PROCEDURE getReservationEntriesDN@1000000051(pbFastDS@1000000000 : Boolean;VAR pdnOutput@1000000014 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder";pcodItemNumber@1000000002 : Text;pcodVariantCode@1000000010 : Text;pcodLocationCode@1000000003 : Code[20];pcodSourceID@1000000004 : Code[20];piSourceRefNumber@1000000005 : Integer;pbPositive@1000000006 : Boolean;piSourceType@1000000009 : Integer;psLotNo@1000000011 : Text;psSerialNo@1000000012 : Text);
    VAR
      lrecReservationEntry@1000000001 : Record 337;
      lrecItem@1000000007 : Record 27;
      lrecItemTrackingCode@1000000008 : Record 6502;
    BEGIN
      //<FUNC>
      //  Description: Will generate the standard xml string containing all the reservations entries based on the supplied params.
      //  Called From: "Whse. Activity Mgmt."::"getWarehouseActivityLine"
      //               "Dataset Tools"::"BuildSingleRowWithResSource"
      //  Side Effect: None
      //</FUNC>

      psLotNo := UPPERCASE(psLotNo);
      psSerialNo := UPPERCASE(psSerialNo);


      // Added psLotNo and psSerialNo to help resolve a problem with warehouse
      // picks and lot warehousehouse tracked items.
      //
      // These new parameters should *only* be supplied from the warehouse activity
      // requests.   These parameters will also *only* be used if the item being
      // requested is either lot warehouse tracked or serial warehouse tracked.
      //
      IF ( NOT pbFastDS ) THEN BEGIN
        pdnOutput.Append('<RESERVATION_ENTRIES>');
      END;

      // make sure the item actually uses tracking information
      lrecItem.GET(pcodItemNumber);
      IF( lrecItemTrackingCode.GET(lrecItem."Item Tracking Code") ) THEN BEGIN
        // set up remaining filters
        lrecReservationEntry.SETRANGE(Positive,pbPositive);
        lrecReservationEntry.SETRANGE("Item No.", pcodItemNumber);
        IF ( '' <> pcodVariantCode ) THEN BEGIN
          lrecReservationEntry.SETRANGE("Variant Code", pcodVariantCode );
        END;
        lrecReservationEntry.SETRANGE("Location Code", pcodLocationCode);
        lrecReservationEntry.SETRANGE("Source ID", pcodSourceID);

        IF (pbPositive AND ((piSourceType = DATABASE::"Transfer Line") OR // Transfer in
                            (piSourceType = DATABASE::"Prod. Order Line") // Production
                            )) THEN BEGIN

          lrecReservationEntry.SETRANGE("Source Prod. Order Line", piSourceRefNumber);
        END ELSE BEGIN
          lrecReservationEntry.SETRANGE("Source Ref. No.",piSourceRefNumber);
        END;


        IF( piSourceType <> 0 ) THEN
          lrecReservationEntry.SETRANGE("Source Type",piSourceType);

        //
        // This was done to fix a problem where if the warehouse pick had many
        // lot warehouse pick lines, referring to a single sales line
        // then there would be too many reservation entries.
        //
        IF (lrecItemTrackingCode."Lot Warehouse Tracking") THEN BEGIN
          IF (psLotNo <> '') THEN BEGIN
            lrecReservationEntry.SETRANGE("Lot No.", psLotNo);
          END;
        END;

        IF (lrecItemTrackingCode."SN Warehouse Tracking") THEN BEGIN
          IF (psSerialNo <> '') THEN BEGIN
             lrecReservationEntry.SETRANGE("Serial No.", psSerialNo);
          END;
        END;


        // iterate through the reservations found and add to xml
        // Changed to Findset(false) to have a read-only cursor for performance
        // improvements.
        IF( lrecReservationEntry.FINDSET(FALSE) ) THEN BEGIN
          REPEAT
            // do not add blank reservations
            IF( (lrecReservationEntry."Lot No." <> '') OR (lrecReservationEntry."Serial No." <> '') ) THEN BEGIN
              getReservationEntryDN(lrecReservationEntry, pdnOutput);
            END;
          UNTIL(lrecReservationEntry.NEXT=0);
        END;
      END;
      IF ( NOT pbFastDS ) THEN BEGIN
        pdnOutput.Append('</RESERVATION_ENTRIES>');
      END;
    END;

    PROCEDURE getReservationEntriesForTrans@1000000001(VAR pbsXMLOutput@1000000000 : BigText;precTransferLine@1000000002 : Record 5741;pbShipping@1000000003 : Boolean);
    VAR
      lrecReservationEntry@1000000001 : Record 337;
      lrecItem@1000000007 : Record 27;
      lrecItemTrackingCode@1000000008 : Record 6502;
    BEGIN
      //<FUNC>
      //  Description: Will generate the standard xml string containing all
      //               the reservations entries based on the supplied params for transfer orders.
      //  Called From:
      //  Side Effect: None
      //</FUNC>


      pbsXMLOutput.ADDTEXT('<RESERVATION_ENTRIES>');

      // make sure the item actually uses tracking information
      lrecItem.GET(precTransferLine."Item No.");
      IF( lrecItemTrackingCode.GET(lrecItem."Item Tracking Code") ) THEN BEGIN

        // set up remaining filters
        lrecReservationEntry.SETRANGE("Item No.", precTransferLine."Item No.");
        lrecReservationEntry.SETRANGE("Source ID", precTransferLine."Document No.");

        IF( pbShipping ) THEN BEGIN
          lrecReservationEntry.SETRANGE(Positive,FALSE);
          lrecReservationEntry.SETRANGE("Location Code", precTransferLine."Transfer-from Code");
          lrecReservationEntry.SETRANGE("Source Ref. No.",precTransferLine."Line No.");
        END
        ELSE BEGIN
          lrecReservationEntry.SETRANGE(Positive, TRUE);
          lrecReservationEntry.SETRANGE("Location Code", precTransferLine."Transfer-to Code");
          lrecReservationEntry.SETRANGE("Source Prod. Order Line",precTransferLine."Line No.");
        END;

        // iterate through the reservations found and add to xml
        IF( lrecReservationEntry.FIND('-') ) THEN BEGIN
          REPEAT
            IF( (lrecReservationEntry."Lot No." <> '') OR (lrecReservationEntry."Serial No." <> '') ) THEN BEGIN
              getReservationEntry(lrecReservationEntry, pbsXMLOutput);
            END;
          UNTIL(lrecReservationEntry.NEXT=0);
        END;
      END;

      pbsXMLOutput.ADDTEXT('</RESERVATION_ENTRIES>');
    END;

    PROCEDURE getReclassReservationEntries@1000000023(VAR pdnOutput@1000000000 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder";pcodItemNumber@1000000002 : Text;pcodLocationCode@1000000003 : Code[20];pcodSourceID@1000000004 : Code[20];pcodSourceBatchName@1000000009 : Code[20];piSourceRefNumber@1000000005 : Integer;pbPositive@1000000006 : Boolean);
    VAR
      lrecReservationEntry@1000000001 : Record 337;
      lrecItem@1000000007 : Record 27;
      lrecItemTrackingCode@1000000008 : Record 6502;
    BEGIN
      //<FUNC>
      //  Description: Gets Reclass Reservation entries in standard xml format.
      //  Called From: "Whse. Activity Mgmt."::"getReclassLine"
      //  Side Effect: None
      //</FUNC>

      lrecReservationEntry.SETRANGE(Positive,pbPositive);
      lrecReservationEntry.SETRANGE("Item No.", pcodItemNumber);
      lrecReservationEntry.SETRANGE("Location Code", pcodLocationCode);
      lrecReservationEntry.SETRANGE("Source ID", pcodSourceID);
      lrecReservationEntry.SETRANGE("Source Batch Name", pcodSourceBatchName);
      lrecReservationEntry.SETRANGE("Source Ref. No.",piSourceRefNumber);

      pdnOutput.Append('<RESERVATION_ENTRIES>');

      lrecItem.GET(pcodItemNumber);
      IF( lrecItemTrackingCode.GET(lrecItem."Item Tracking Code") ) THEN BEGIN

        IF( lrecReservationEntry.FINDSET(FALSE) ) THEN BEGIN
          REPEAT
            IF( (lrecReservationEntry."Lot No." <> '') OR (lrecReservationEntry."Serial No." <> '') ) THEN BEGIN
              getReservationEntryDN(lrecReservationEntry, pdnOutput );
            END;
          UNTIL(lrecReservationEntry.NEXT=0);
        END;
      END;

      pdnOutput.Append('</RESERVATION_ENTRIES>');
    END;

    PROCEDURE getReservationEntry@1000000000(precReservationEntry@1000000000 : Record 337;VAR pbsXMLOutput@1000000001 : BigText);
    VAR
      liItemTracking@1000000009 : Integer;
      lrecItemLedgerEntry@1000000002 : Record 32;
      ldtExpiryDate@1000000003 : Date;
    BEGIN
      //<FUNC>
      //  Description: Generates a standard xml reservation string based on the supplied reservation.
      //  Called From: "getReservationEntries"
      //               "getReservationEntriesForTrans"
      //               "getReclassReservationEntries"
      //  Side Effect: None
      //</FUNC>

      pbsXMLOutput.ADDTEXT('<LINE>');
      pbsXMLOutput.ADDTEXT(STRSUBSTNO('<ENTRY_NUMBER>%1</ENTRY_NUMBER>',precReservationEntry."Entry No."));
      pbsXMLOutput.ADDTEXT(STRSUBSTNO('<ITEM_NUMBER>%1</ITEM_NUMBER>',escapeText( precReservationEntry."Item No." ) ));
      pbsXMLOutput.ADDTEXT(STRSUBSTNO('<SERIAL_NUMBER>%1</SERIAL_NUMBER>',escapeText(precReservationEntry."Serial No.")));
      pbsXMLOutput.ADDTEXT(STRSUBSTNO('<SOURCE_ID>%1</SOURCE_ID>',precReservationEntry."Source ID"));
      pbsXMLOutput.ADDTEXT(STRSUBSTNO('<SOURCE_REF_NUMBER>%1</SOURCE_REF_NUMBER>',precReservationEntry."Source Ref. No."));
      pbsXMLOutput.ADDTEXT(STRSUBSTNO('<POSITIVE>%1</POSITIVE>',precReservationEntry.Positive));
      pbsXMLOutput.ADDTEXT(STRSUBSTNO('<QTY_BASE>%1</QTY_BASE>',precReservationEntry."Quantity (Base)"));
      pbsXMLOutput.ADDTEXT(STRSUBSTNO('<LOT_NUMBER>%1</LOT_NUMBER>',escapeText(precReservationEntry."Lot No.")));
      pbsXMLOutput.ADDTEXT(STRSUBSTNO('<QTY_HANDLE_BASE>%1</QTY_HANDLE_BASE>',precReservationEntry."Qty. to Handle (Base)"));
      pbsXMLOutput.ADDTEXT(STRSUBSTNO('<QTY_PER_UOM>%1</QTY_PER_UOM>',precReservationEntry."Qty. per Unit of Measure"));


      liItemTracking := precReservationEntry."Item Tracking";
      pbsXMLOutput.ADDTEXT(STRSUBSTNO('<ITEM_TRACKING>%1</ITEM_TRACKING>',liItemTracking));

      ldtExpiryDate := precReservationEntry."Expiration Date";

      // expiry date was blank and it's a negative entry for a sales or transfer
      // try to get from the item ledger entry then
      IF( (ldtExpiryDate = 0D) AND (NOT precReservationEntry.Positive) AND (precReservationEntry."Lot No."<>'') AND
        ((precReservationEntry."Source Type" = DATABASE::"Sales Line") OR
                 (precReservationEntry."Source Type" = DATABASE::"Transfer Line"))) THEN
      BEGIN
          lrecItemLedgerEntry.SETCURRENTKEY("Item No.",Open,"Variant Code",Positive,"Expiration Date","Lot No.","Serial No.");
          lrecItemLedgerEntry.SETRANGE("Item No.", precReservationEntry."Item No.");
          lrecItemLedgerEntry.SETRANGE("Location Code", precReservationEntry."Location Code");
          lrecItemLedgerEntry.SETRANGE(Open,TRUE);
          lrecItemLedgerEntry.SETRANGE("Variant Code",precReservationEntry."Variant Code");
          lrecItemLedgerEntry.SETRANGE("Lot No.",precReservationEntry."Lot No.");
          IF( lrecItemLedgerEntry.FINDLAST ) THEN BEGIN
            ldtExpiryDate := lrecItemLedgerEntry."Expiration Date";
          END;
      END;

      pbsXMLOutput.ADDTEXT(STRSUBSTNO('<EXP>%1</EXP>',ldtExpiryDate));
      pbsXMLOutput.ADDTEXT('</LINE>');
    END;

    PROCEDURE getReservationEntryDN@1000000053(precReservationEntry@1000000000 : Record 337;VAR pdnOutput@1000000001 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder");
    VAR
      liItemTracking@1000000009 : Integer;
      lrecItemLedgerEntry@1000000002 : Record 32;
      ldtExpiryDate@1000000003 : Date;
    BEGIN
      //<FUNC>
      //  Description: Generates a standard xml reservation string based on the supplied reservation.
      //  Called From: "getReservationEntriesDN"
      //               "getReclassReservationEntries"
      //  Side Effect: None
      //</FUNC>

      pdnOutput.Append('<LINE>');
      pdnOutput.Append(STRSUBSTNO('<ENTRY_NUMBER>%1</ENTRY_NUMBER>',precReservationEntry."Entry No."));
      pdnOutput.Append(STRSUBSTNO('<ITEM_NUMBER>%1</ITEM_NUMBER>',escapeText( precReservationEntry."Item No." ) ));
      pdnOutput.Append(STRSUBSTNO('<SERIAL_NUMBER>%1</SERIAL_NUMBER>',escapeText(precReservationEntry."Serial No.")));
      pdnOutput.Append(STRSUBSTNO('<SOURCE_ID>%1</SOURCE_ID>',precReservationEntry."Source ID"));
      pdnOutput.Append(STRSUBSTNO('<SOURCE_REF_NUMBER>%1</SOURCE_REF_NUMBER>',precReservationEntry."Source Ref. No."));
      pdnOutput.Append(STRSUBSTNO('<POSITIVE>%1</POSITIVE>',precReservationEntry.Positive));
      pdnOutput.Append(STRSUBSTNO('<QTY_BASE>%1</QTY_BASE>',precReservationEntry."Quantity (Base)"));
      pdnOutput.Append(STRSUBSTNO('<LOT_NUMBER>%1</LOT_NUMBER>',escapeText(precReservationEntry."Lot No.")));
      pdnOutput.Append(STRSUBSTNO('<QTY_HANDLE_BASE>%1</QTY_HANDLE_BASE>',precReservationEntry."Qty. to Handle (Base)"));
      pdnOutput.Append(STRSUBSTNO('<QTY_PER_UOM>%1</QTY_PER_UOM>',precReservationEntry."Qty. per Unit of Measure"));

      liItemTracking := precReservationEntry."Item Tracking";
      pdnOutput.Append(STRSUBSTNO('<ITEM_TRACKING>%1</ITEM_TRACKING>',liItemTracking));

      ldtExpiryDate := precReservationEntry."Expiration Date";

      // expiry date was blank and it's a negative entry for a sales or transfer
      // try to get from the item ledger entry then
      IF( (ldtExpiryDate = 0D) AND (NOT precReservationEntry.Positive) AND (precReservationEntry."Lot No."<>'') AND
        ((precReservationEntry."Source Type" = DATABASE::"Sales Line") OR
                 (precReservationEntry."Source Type" = DATABASE::"Transfer Line"))) THEN
      BEGIN
          lrecItemLedgerEntry.SETCURRENTKEY("Item No.",Open,"Variant Code",Positive,"Expiration Date","Lot No.","Serial No.");
          lrecItemLedgerEntry.SETRANGE("Item No.", precReservationEntry."Item No.");
          lrecItemLedgerEntry.SETRANGE("Location Code", precReservationEntry."Location Code");
          lrecItemLedgerEntry.SETRANGE(Open,TRUE);
          lrecItemLedgerEntry.SETRANGE("Variant Code",precReservationEntry."Variant Code");
          lrecItemLedgerEntry.SETRANGE("Lot No.",precReservationEntry."Lot No.");
          IF( lrecItemLedgerEntry.FINDLAST ) THEN BEGIN
            ldtExpiryDate := lrecItemLedgerEntry."Expiration Date";
          END;
      END;

      IF ((ldtExpiryDate = 0D) AND (precReservationEntry."Source Type" = DATABASE::"Item Journal Line")) THEN BEGIN
        ldtExpiryDate := precReservationEntry."New Expiration Date";
      END;

      pdnOutput.Append(STRSUBSTNO('<EXP>%1</EXP>',ldtExpiryDate));
      pdnOutput.Append('</LINE>');
    END;

    PROCEDURE setPrinterSelection@1000000016(psPrinterName@1000000000 : Text;piReportID@1000000001 : Integer) prtxtPreviousPrinter : Text;
    VAR
      lrecPrinterSelections@1000000002 : Record 78;
    BEGIN
      //<FUNC>
      //  Description: Will update or create the appropriate printer selection.
      //  Called From: "Printing Management"::"printDirectly"
      //  Side Effect: None
      //</FUNC>

      lrecPrinterSelections.LOCKTABLE;

      prtxtPreviousPrinter := '';
      IF( psPrinterName <> '' ) THEN BEGIN
        // change the printer selections
        lrecPrinterSelections.SETRANGE("Report ID",piReportID);
        lrecPrinterSelections.SETRANGE("User ID",USERID);

        IF( lrecPrinterSelections.FIND('-') ) THEN BEGIN

          prtxtPreviousPrinter := COPYSTR( lrecPrinterSelections."Printer Name", 1, MAXSTRLEN( prtxtPreviousPrinter ) );

          lrecPrinterSelections."Printer Name" := psPrinterName;
          lrecPrinterSelections.MODIFY;
        END
        ELSE BEGIN
          CLEAR(lrecPrinterSelections);
          lrecPrinterSelections.VALIDATE("User ID",USERID);
          lrecPrinterSelections.VALIDATE("Report ID",piReportID);
          lrecPrinterSelections."Printer Name" := psPrinterName;
          lrecPrinterSelections.INSERT;
        END;
      END
      ELSE
        ERROR(cuTranslationMgmt.getTranslatedString('ERR_PRINTER_NOT_SET', ''));
    END;

    PROCEDURE setWriteColumnHeader@1000000030(pbWriteColumnHeader@1000000000 : Boolean);
    BEGIN
      //<FUNC>
      //  Description: Flag indicates whether or not the <C> columns are written.
      //  Called From: Numerous
      //  Side Effect: None
      //</FUNC>


      bWriteColumnHeader := pbWriteColumnHeader;
    END;

    PROCEDURE fillDefaultLookup@1000000034(VAR precMenu@1000000000 : Record 23044510);
    VAR
      ltxtSubType@1000000001 : Text[1];
      ltcMenuCaptionLicense@1000000005 : TextConst 'ENU=License;ESM=Licencia;FRC=Licence;ENC=License';
      ltcMenuCaptionLPStart@1000000006 : TextConst 'ENU=" LP";ESM=Placa;FRC=Plaque;ENC=" LP"';
      ltcMenuCaptionLPEnd@1000000018 : TextConst 'ENU="LP ";ESM=Placa;FRC=Plaque;ENC="LP "';
      ltcMenuCaptionPallet@1000000007 : TextConst 'ENU=Pallet;ESM=Paleta;FRC=Palette;ENC=Pallet';
      ltcMenuCaptionPurchase@1000000008 : TextConst 'ENU=Purchase;ESM=Compra;FRC=Achat;ENC=Purchase';
      ltcMenuCaptionSales@1000000009 : TextConst 'ENU=Sales;ESM=Ventas;FRC=Ventes;ENC=Sales';
      ltcMenuCaptionTransfer@1000000010 : TextConst 'ENU=Transfer;ESM=Transferir;FRC=Transfert;ENC=Transfer';
      ltcMenuCaptionProduction@1000000011 : TextConst 'ENU=Production;ESM=Produccin;FRC=Production;ENC=Production';
      ltcMenuCaptionCountSheet@1000000012 : TextConst 'ENU=Count Sheet;ESM=recuento de hojas;FRC=Count Sheet;ENC=Count Sheet';
      ltcMenuCaptionPick@1000000013 : TextConst 'ENU=Pick;ESM=Recoger;FRC=Choisir;ENC=Pick';
      ltcMenuCaptionPutAway@1000000014 : TextConst 'ENU=Putaway;ESM=Entrada en stock;FRC=Ranger;ENC=Putaway';
      ltcMenuCaptionMove@1000000015 : TextConst 'ENU=Move;ESM=Movimiento;FRC=Dplacer;ENC=Move';
      ltcMenuCaptionReceipt@1000000016 : TextConst 'ENU=Receipt;ESM=Recibo;FRC=Reu;ENC=Receipt';
      ltcMenuCaptionShip@1000000017 : TextConst 'ENU=Ship;ESM=Enviar;FRC=Navire;ENC=Ship';
      lrecItem@1000000019 : Record 27;
      lrecBin@1000000004 : Record 7354;
      lrecLocation@1000000020 : Record 14;
    BEGIN
      //<FUNC>
      //  Description: Set the initial lookup table based menu.
      //  Called From:
      //  Side Effect: None
      //</FUNC>

      IF ((( precMenu."Standard Action"::LookupToBarcode = precMenu."Standard Action" )
          OR
          ( precMenu."Standard Action"::PromptToBarcode = precMenu."Standard Action" ) )
          AND
           ( '' = precMenu.WebService ) ) THEN BEGIN

        IF ( 0 = precMenu.NavEventGenID ) THEN BEGIN
          IF ( precMenu."Standard Action"::LookupToBarcode = precMenu."Standard Action" ) THEN BEGIN
            // 412 is in the Misc Data broker management for lookup
            // it will be the most common event gen id for generic lookups
            precMenu.VALIDATE(NavEventGenID, 412 );
          END ELSE IF ( precMenu."Standard Action"::PromptToBarcode = precMenu."Standard Action" ) THEN BEGIN
            // 413 is in the Misc Data broker management for prompt to barcode
            precMenu.VALIDATE(NavEventGenID, 413 );
          END;
        END;



        // the rest is common between lookup to barcode and prompt
        // to barcode

        IF ( 0 = precMenu."Lookup Table" )  THEN BEGIN
          IF ( 0 <> STRPOS( precMenu.Caption, lrecBin.TABLECAPTION) ) THEN BEGIN
            precMenu.VALIDATE("Lookup Table", DATABASE::Bin );
          END ELSE IF ( 0 <> STRPOS( precMenu.Caption, lrecLocation.TABLECAPTION) ) THEN BEGIN
            precMenu.VALIDATE("Lookup Table", DATABASE::Location );
          END ELSE IF ( 0 <> STRPOS( precMenu.Caption, lrecItem.TABLECAPTION) ) THEN BEGIN
            precMenu.VALIDATE("Lookup Table", DATABASE::Item );
          END ELSE IF ( 0 <> STRPOS( precMenu.Caption, ltcMenuCaptionPurchase) ) THEN BEGIN
            precMenu.VALIDATE("Lookup Table", DATABASE::"Purchase Header" );
          END ELSE IF ( 0 <> STRPOS( precMenu.Caption, ltcMenuCaptionSales) ) THEN BEGIN
            precMenu.VALIDATE("Lookup Table", DATABASE::"Sales Header" );
          END ELSE IF ( 0 <> STRPOS( precMenu.Caption, ltcMenuCaptionTransfer) ) THEN BEGIN
            precMenu.VALIDATE("Lookup Table", DATABASE::"Transfer Header" );
          END ELSE IF ( 0 <> STRPOS( precMenu.Caption, ltcMenuCaptionProduction) ) THEN BEGIN
            precMenu.VALIDATE("Lookup Table", DATABASE::"Prod. Order Line" );
          END ELSE IF ( 0 <> STRPOS( precMenu.Caption, ltcMenuCaptionCountSheet) ) THEN BEGIN
            precMenu.VALIDATE("Lookup Table", 23044300 );    // count sheet configuration
          END ELSE IF ( 0 <> STRPOS( precMenu.Caption, ltcMenuCaptionPick) ) THEN BEGIN
            precMenu.VALIDATE("Lookup Table", DATABASE::"Warehouse Activity Header" );
            ltxtSubType := '1';
          END ELSE IF ( 0 <> STRPOS( precMenu.Caption, ltcMenuCaptionPutAway) ) THEN BEGIN
            precMenu.VALIDATE("Lookup Table", DATABASE::"Warehouse Activity Header" );
            ltxtSubType := '2';
          END ELSE IF ( 0 <> STRPOS( precMenu.Caption, ltcMenuCaptionMove) ) THEN BEGIN
            precMenu.VALIDATE("Lookup Table", DATABASE::"Warehouse Activity Header" );
            ltxtSubType := '3';
          END ELSE IF ( 0 <> STRPOS( precMenu.Caption, ltcMenuCaptionReceipt) ) THEN BEGIN
            precMenu.VALIDATE("Lookup Table", DATABASE::"Warehouse Receipt Header" );
          END ELSE IF ( 0 <> STRPOS( precMenu.Caption, ltcMenuCaptionShip) ) THEN BEGIN
            // good enough for a default, we allow the users to override.
            precMenu.VALIDATE("Lookup Table", DATABASE::"Warehouse Shipment Header" );
          END;

          // could also try and be clever by looking up the table name
          // let's see if anybody requests that type of feature.

          IF ( 0 = precMenu."Lookup Table" ) THEN BEGIN
            // if it's still not set then our most common lookup scenario is bin.
            precMenu.VALIDATE("Lookup Table", DATABASE::Bin );
          END;
        END;

        // fill in standard helpers for known tables.
        IF ( DATABASE::Bin = precMenu."Lookup Table" ) THEN BEGIN
          precMenu.VALIDATE(WebService,'Code Description' );
          precMenu.VALIDATE("WebService Method",'%B%%1' );
        END ELSE IF ( DATABASE::Location = precMenu."Lookup Table" ) THEN BEGIN
          precMenu.VALIDATE(WebService,'Code Name' );
          precMenu.VALIDATE("WebService Method",'%LOC%%1' );
        END ELSE IF ( DATABASE::Item = precMenu."Lookup Table" ) THEN BEGIN
          precMenu.VALIDATE(WebService,'No.  Description' );
          // really depends on configured barcode rules
          // for now just assume it's the item code directly.
          precMenu.VALIDATE("WebService Method",'%1' );
        END ELSE IF ( DATABASE::"Sales Header" = precMenu."Lookup Table" ) THEN BEGIN
          precMenu.VALIDATE(WebService,'No. Sell-to Customer Name' );
          precMenu.VALIDATE("WebService Method",'%S%%1' );
          precMenu.VALIDATE("Lookup Filter", 'WHERE(Document Type=FILTER(Order))' );
        END ELSE IF ( DATABASE::"Transfer Header" = precMenu."Lookup Table" ) THEN BEGIN
          precMenu.VALIDATE(WebService,'No. Transfer-from Code Transfer-to Code' );
          precMenu.VALIDATE("WebService Method",'%T%%1' );
        END ELSE IF ( DATABASE::"Prod. Order Line" = precMenu."Lookup Table" ) THEN BEGIN
          precMenu.VALIDATE(WebService,'Prod. Order No. Line No' );
          precMenu.VALIDATE("WebService Method",'%P%%1 %2' );
        END ELSE IF ( 23044300 = precMenu."Lookup Table" ) THEN BEGIN  // count sheet configuration
          precMenu.VALIDATE(WebService,'Sheet Name' );
          precMenu.VALIDATE("WebService Method",'%C%%1' );
        END ELSE IF ( DATABASE::"Warehouse Activity Header" = precMenu."Lookup Table" ) THEN BEGIN
          precMenu.VALIDATE(WebService,'No. Location Code' );
          precMenu.VALIDATE("WebService Method",'%A%%1 '+ ltxtSubType );
        END ELSE IF ( DATABASE::"Warehouse Receipt Header" = precMenu."Lookup Table" ) THEN BEGIN
          precMenu.VALIDATE(WebService,'No.' );
          precMenu.VALIDATE("WebService Method",'%WR%%1' );
        END ELSE IF ( DATABASE::"Warehouse Shipment Header" = precMenu."Lookup Table" ) THEN BEGIN
          precMenu.VALIDATE(WebService,'No.' );
          precMenu.VALIDATE("WebService Method",'%WS%%1' );
        END;

      END;
    END;

    PROCEDURE getIsAnyLotOrSerialTracked@1000000038(pcodItemNo@1000000000 : Text;VAR pbIsAnySerialTracked@1000000001 : Boolean;VAR pbIsAnyLotTracked@1000000002 : Boolean);
    VAR
      lrecItem@1000000003 : Record 27;
      lrecItemTrackingCode@1000000004 : Record 6502;
    BEGIN
      //<FUNC>
      //  Description: Returns true if any item tracking requirement exists.
      //  Called From: "Whse. Activity Mgmt."::"setItemTrackingLines"
      //               "License Plate Mgmt."::"getLPLine"
      //  Side Effect: None
      //</FUNC>


      // Added for use with license plating.
      //
      pbIsAnySerialTracked := FALSE;
      pbIsAnyLotTracked := FALSE;

      IF ( lrecItem.GET( pcodItemNo ) ) THEN BEGIN
        IF (  lrecItemTrackingCode.GET( lrecItem."Item Tracking Code" ) ) THEN BEGIN
          pbIsAnySerialTracked :=
            lrecItemTrackingCode."SN Specific Tracking" OR
            lrecItemTrackingCode."SN Warehouse Tracking" OR
            lrecItemTrackingCode."SN Sales Outbound Tracking" OR
            lrecItemTrackingCode."SN Sales Inbound Tracking" OR
            lrecItemTrackingCode."SN Manuf. Outbound Tracking" OR
            lrecItemTrackingCode."SN Manuf. Inbound Tracking" OR
            lrecItemTrackingCode."SN Transfer Tracking" OR
            lrecItemTrackingCode."SN Purchase Inbound Tracking";


          pbIsAnyLotTracked :=
            lrecItemTrackingCode."Lot Specific Tracking" OR
            lrecItemTrackingCode."Lot Warehouse Tracking" OR
            lrecItemTrackingCode."Lot Sales Outbound Tracking" OR
            lrecItemTrackingCode."Lot Sales Inbound Tracking" OR
            lrecItemTrackingCode."Lot Manuf. Outbound Tracking" OR
            lrecItemTrackingCode."Lot Manuf. Inbound Tracking" OR
            lrecItemTrackingCode."Lot Transfer Tracking" OR
            lrecItemTrackingCode."Lot Purchase Inbound Tracking";

        END;
      END;
    END;

    PROCEDURE getWhseReclassTrackingLines@1000000039(VAR pbsXMLOutput@1000000000 : BigText;pcodItemNumber@1000000002 : Text;pcodLocationCode@1000000003 : Code[20];pcodSourceID@1000000004 : Code[20];pcodSourceBatchName@1000000009 : Code[20];piSourceRefNumber@1000000005 : Integer);
    VAR
      lrecItem@1000000007 : Record 27;
      lrecItemTrackingCode@1000000008 : Record 6502;
      lrecWhseItemTrackingLine@1000000010 : Record 6550;
    BEGIN
      //<FUNC>
      //  Description: Gets Warehouse Reclass tracking lines.
      //  Called From: "Reclass Mgmt."::"getWhseReclassLine"
      //  Side Effect: None
      //</FUNC>

      lrecWhseItemTrackingLine.SETRANGE("Item No.", pcodItemNumber);
      lrecWhseItemTrackingLine.SETRANGE("Location Code", pcodLocationCode);
      lrecWhseItemTrackingLine.SETRANGE("Source ID", pcodSourceID);
      lrecWhseItemTrackingLine.SETRANGE("Source Batch Name", pcodSourceBatchName);
      lrecWhseItemTrackingLine.SETRANGE("Source Ref. No.",piSourceRefNumber);

      pbsXMLOutput.ADDTEXT('<RESERVATION_ENTRIES>');

      lrecItem.GET(pcodItemNumber);
      IF( lrecItemTrackingCode.GET(lrecItem."Item Tracking Code") ) THEN BEGIN

        IF( lrecWhseItemTrackingLine.FINDSET(FALSE) ) THEN BEGIN
          REPEAT
            IF( (lrecWhseItemTrackingLine."Lot No." <> '') OR (lrecWhseItemTrackingLine."Serial No." <> '') ) THEN BEGIN

              getWhseTrackingLine(lrecWhseItemTrackingLine, pbsXMLOutput);
            END;
          UNTIL(lrecWhseItemTrackingLine.NEXT=0);
        END;
      END;

      pbsXMLOutput.ADDTEXT('</RESERVATION_ENTRIES>');
    END;

    PROCEDURE getWhseTrackingLine@1000000041(precWhseItemTrackingLine@1000000000 : Record 6550;VAR pbsXMLOutput@1000000001 : BigText);
    VAR
      ldtExpirationDate@1000000002 : Date;
    BEGIN
      //<FUNC>
      //  Description: Generates a standard xml reservation string based on the supplied tracking line.
      //  Called From: "getWhseReclassTrackingLines"
      //  Side Effect: None
      //</FUNC>

      pbsXMLOutput.ADDTEXT('<LINE>');

      pbsXMLOutput.ADDTEXT(STRSUBSTNO('<ENTRY_NUMBER>%1</ENTRY_NUMBER>',escapeText( STRSUBSTNO('%1', precWhseItemTrackingLine.
        "Entry No.")) ));
      pbsXMLOutput.ADDTEXT(STRSUBSTNO('<ITEM_NUMBER>%1</ITEM_NUMBER>',escapeText( STRSUBSTNO('%1',precWhseItemTrackingLine."Item No.")))
      );
      pbsXMLOutput.ADDTEXT(STRSUBSTNO('<SERIAL_NUMBER>%1</SERIAL_NUMBER>',escapeText( STRSUBSTNO('%1',precWhseItemTrackingLine.
        "Serial No."))));
      pbsXMLOutput.ADDTEXT(STRSUBSTNO('<SOURCE_ID>%1</SOURCE_ID>',escapeText( STRSUBSTNO('%1',precWhseItemTrackingLine."Source ID"))));
      pbsXMLOutput.ADDTEXT(STRSUBSTNO('<SOURCE_REF_NUMBER>%1</SOURCE_REF_NUMBER>',escapeText( STRSUBSTNO('%1',precWhseItemTrackingLine.
        "Source Ref. No."))));
      pbsXMLOutput.ADDTEXT(STRSUBSTNO('<POSITIVE>%1</POSITIVE>',TRUE));
      pbsXMLOutput.ADDTEXT(STRSUBSTNO('<QTY_BASE>%1</QTY_BASE>',escapeText( STRSUBSTNO('%1',precWhseItemTrackingLine."Quantity (Base)"))
        ));
      pbsXMLOutput.ADDTEXT(STRSUBSTNO('<LOT_NUMBER>%1</LOT_NUMBER>',escapeText( STRSUBSTNO('%1',precWhseItemTrackingLine."Lot No."))));
      pbsXMLOutput.ADDTEXT(STRSUBSTNO('<QTY_HANDLE_BASE>%1</QTY_HANDLE_BASE>',escapeText( STRSUBSTNO('%1',precWhseItemTrackingLine.
        "Qty. to Handle (Base)"))));

      pbsXMLOutput.ADDTEXT(STRSUBSTNO('<QTY_PER_UOM>%1</QTY_PER_UOM>',escapeText( STRSUBSTNO('%1',precWhseItemTrackingLine.
        "Qty. per Unit of Measure"))));

      pbsXMLOutput.ADDTEXT(STRSUBSTNO('<ITEM_TRACKING>%1</ITEM_TRACKING>',0));

      ldtExpirationDate := precWhseItemTrackingLine."Expiration Date";
      IF ((ldtExpirationDate = 0D) AND (precWhseItemTrackingLine."Source Type" = DATABASE::"Warehouse Journal Line")) THEN BEGIN
        ldtExpirationDate := precWhseItemTrackingLine."New Expiration Date";
      END;

      pbsXMLOutput.ADDTEXT(STRSUBSTNO('<EXP>%1</EXP>',escapeText( STRSUBSTNO('%1', ldtExpirationDate))));
      pbsXMLOutput.ADDTEXT('</LINE>');
    END;

    PROCEDURE getBoolFromText@1000000044(ptxtValue@1000000000 : Text[20]) : Boolean;
    BEGIN
      //<FUNC>
      //  Description: Converts a text string to boolean - string can be 1,0,Y[es],N[o],T[rue],F[alse]
      //  Called From:
      //  Side Effect: None
      //</FUNC>

      EXIT(UPPERCASE(COPYSTR(ptxtValue,1,1)) IN ['1','Y','T']);
    END;

    PROCEDURE getOptionFromText@1000000043(ptxtValue@1000000000 : Text;pfrFieldRef@1000000001 : FieldRef) rnOptionVal : Integer;
    VAR
      ltxtOptionStr@1000000002 : Text;
      lnStrPos@1000000004 : Integer;
      lnCharPos@1000000006 : Integer;
    BEGIN
      //<FUNC>
      //  Description: Gets an option value (i.e., ordninal value) based on import text
      //  Called From: "Misc. Mgmt."::"setRecordValue"
      //  Side Effect: None
      //</FUNC>


      IF NOT EVALUATE(rnOptionVal, ptxtValue) THEN BEGIN
        ltxtOptionStr := UPPERCASE(pfrFieldRef.OPTIONCAPTION) +',';
        lnStrPos := STRPOS(ltxtOptionStr, UPPERCASE(ptxtValue)+',');
        IF lnStrPos = 0 THEN BEGIN
          ERROR( cuTranslationMgmt.getTranslatedString('ERR_NOT_ALLOWED_OPTION', ''), ptxtValue, ltxtOptionStr );
        END;

        WHILE lnCharPos<lnStrPos DO BEGIN
          lnCharPos += 1;
          IF ltxtOptionStr[lnCharPos]=',' THEN
            rnOptionVal += 1;
        END;//if
      END;//if
    END;

    PROCEDURE CalcFormula@1000000065(VAR prrefRecord@1000000000 : RecordRef;ptxtExpression@1000000003 : Text) ptxtOutput : Text;
    VAR
      lrecField@1000000009 : Record 2000000041;
      liLookupTable@1000000001 : Integer;
      liLookupField@1000000002 : Integer;
      ltxtLookupFilter@1000000004 : Text;
      lrrefLookupRec@1000000005 : RecordRef;
      ltxtLookupValue@1000000006 : Text;
      lfrefLookupValue@1000000007 : FieldRef;
      liWherePostion@1000000008 : Integer;
      varType@100000000 : Variant;
    BEGIN
      //<FUNC>
      //  Description: Calculates an expression
      //  Called From: "addDSFieldsForRecord"
      //               "addDSFieldsForRecordDN"
      //               "Dataset Tools"::"CalcRowFormulas"
      //  Side Effect: None
      //</FUNC>

      IF ( ptxtExpression = '' ) THEN EXIT;
      // check for lookup formula
      IF ( EVALUATE( liLookupTable, SELECTSTR(1, ptxtExpression ) )) THEN BEGIN
        IF ( EVALUATE( liLookupField, SELECTSTR(2, ptxtExpression ) )) THEN BEGIN
          liWherePostion := STRPOS(ptxtExpression, 'WHERE');
          ltxtLookupFilter := COPYSTR(ptxtExpression, liWherePostion);
          ltxtLookupFilter := cuLinksAndDocs.getTokenFilterRec( ltxtLookupFilter, prrefRecord );
          lrrefLookupRec.OPEN( liLookupTable );
          lrrefLookupRec.SETVIEW( ltxtLookupFilter );
          IF ( lrrefLookupRec.FINDFIRST() ) THEN BEGIN
            lfrefLookupValue := lrrefLookupRec.FIELD( liLookupField );

            EVALUATE(lrecField.Class,FORMAT(lfrefLookupValue.CLASS));
            IF lrecField.Class = lrecField.Class::FlowField THEN
              lfrefLookupValue.CALCFIELD;

            varType := lfrefLookupValue.VALUE;
            IF varType.ISBOOLEAN THEN BEGIN
              IF lfrefLookupValue.VALUE THEN
                ptxtOutput := '1'
              ELSE
                ptxtOutput := '0';
            END
            ELSE
              ptxtOutput := FORMAT( lfrefLookupValue.VALUE );


          END ELSE BEGIN
            ptxtOutput := '';
          END;

          lrrefLookupRec.CLOSE();
        END; // if we have a valid lookup field
      END // if we have a valid lookup table.
      ELSE IF ( STRPOS( ptxtExpression, 'STRREPL:' ) = 1) THEN BEGIN
        // simple string replacement
        ltxtLookupValue :=COPYSTR( ptxtExpression, STRLEN('STRREPL:')+1 );
        ptxtOutput := cuLinksAndDocs.getTokenFilterRec(
          ltxtLookupValue,
          prrefRecord );
      END; // end if it's a string replacement
    END;

    PROCEDURE CalcFormulaForCSV@1000000086(VAR prrefRecord@1000000000 : RecordRef;ptxtExpression@1000000003 : Text) ptxtOutput : Text;
    VAR
      liLookupTable@1000000001 : Integer;
      liLookupField@1000000002 : Integer;
      ltxtLookupFilter@1000000004 : Text;
      lrrefLookupRec@1000000005 : RecordRef;
      ltxtLookupValue@1000000006 : Text;
      lfrefLookupValue@1000000007 : FieldRef;
      liWherePostion@1000000008 : Integer;
    BEGIN
      //<FUNC>
      //  Description: Calculates an expression and returns the results as a csv
      //  Called From: "addDSFieldsForRecord"
      //               "addDSFieldsForRecordDN"
      //               "Dataset Tools"::"CalcRowFormulas"
      //  Side Effect: None
      //</FUNC>

      IF ( ptxtExpression = '' ) THEN EXIT;
      // check for lookup formula
      IF ( EVALUATE( liLookupTable, SELECTSTR(1, ptxtExpression ) )) THEN BEGIN
        IF ( EVALUATE( liLookupField, SELECTSTR(2, ptxtExpression ) )) THEN BEGIN
          liWherePostion := STRPOS(ptxtExpression, 'WHERE');
          ltxtLookupFilter := COPYSTR(ptxtExpression, liWherePostion);
          ltxtLookupFilter := cuLinksAndDocs.getTokenFilterRec( ltxtLookupFilter, prrefRecord );
          lrrefLookupRec.OPEN( liLookupTable );
          lrrefLookupRec.SETVIEW( ltxtLookupFilter );
          IF ( lrrefLookupRec.FINDSET(FALSE) ) THEN BEGIN
            REPEAT
              lfrefLookupValue := lrrefLookupRec.FIELD( liLookupField );
              IF(ptxtOutput <> '')THEN
                ptxtOutput += ',';
              ptxtOutput += FORMAT( lfrefLookupValue.VALUE );
            UNTIL(lrrefLookupRec.NEXT=0);
          END ELSE BEGIN
            ptxtOutput := '';
          END;

          lrrefLookupRec.CLOSE();
        END; // if we have a valid lookup field
      END // if we have a valid lookup table.
      ELSE IF ( STRPOS( ptxtExpression, 'STRREPL:' ) = 1) THEN BEGIN
        // simple string replacement
        ltxtLookupValue :=COPYSTR( ptxtExpression, STRLEN('STRREPL:')+1 );
        ptxtOutput := cuLinksAndDocs.getTokenFilterRec(
          ltxtLookupValue,
          prrefRecord );
      END; // end if it's a string replacement
    END;

    PROCEDURE showSourceDocument@1000000063(psCompanyName@1000000008 : Text[30];poptSourceDocument@1000000009 : ' ,Purchase Order,Sales Order,Inbound Transfer,Outbound Transfer,Prod. Order,Put-away,Pick,Movement,Invt. Put-away,Invt. Pick,Receipt,Shipment,Reclass,LP';pcodSourceNo@1000000010 : Code[20]);
    VAR
      ltrecEventParams@1000000000 : TEMPORARY Record 23044511;
      lrecLicensePlateHeader@1000000002 : Record 23044505;
      lcodLicensePlateNo@1000000001 : Code[20];
    BEGIN
      //<FUNC>
      //  Description: Opens the appropriate source document that the License Plate is currently on.
      //  Called From:
      //  Side Effect: None
      //</FUNC>

      CASE poptSourceDocument OF
        poptSourceDocument::LP:
          BEGIN
            IF (lrecLicensePlateHeader.GET(pcodSourceNo)) THEN
              PAGE.RUN(PAGE::"IWX License Plate",lrecLicensePlateHeader);
          END;
        ELSE
          cuCommonBase.showSourceDocument(psCompanyName,poptSourceDocument,pcodSourceNo);
      END;
    END;

    PROCEDURE isWHILocation@1000000066(pcodLocationCode@1000000000 : Code[10]) : Boolean;
    VAR
      lrecConfig@1000000001 : Record 23044504;
    BEGIN
      //<FUNC>
      //  Description: Wrapper function for determining if a location is using WHI.
      //  Called From: Base NAV modifications
      //  Side Effect: None
      //</FUNC>

      lrecConfig.SETRANGE("Location Code",pcodLocationCode);
      EXIT(lrecConfig.FINDFIRST);
    END;

    PROCEDURE isAutoShip@1000000067(pcodConfig@1000000002 : Code[20];pcodLocationCode@1000000000 : Code[10]) : Boolean;
    VAR
      lrecConfig@1000000001 : Record 23044504;
    BEGIN
      //<FUNC>
      //  Description: Wrapper function for determining if a location is using the auto-ship feature.
      //               NOTE: This function does not account for multiple device configurations unless explicity specified.
      //  Called From: "Whse.-Activity-Register"::"UpdateWhseShptLine"
      //               "Whse.-Activity-Register"::"RegisterWhseItemTrkgLine"
      //  Side Effect: None
      //</FUNC>

      IF( lrecConfig.GET(pcodConfig) ) THEN
        EXIT( lrecConfig."Update Shipment on Pick" );

      IF lrecConfig.GET(getFirstConfigByLocation(pcodLocationCode)) THEN
        EXIT( lrecConfig."Update Shipment on Pick" );

      EXIT(FALSE);
    END;

    PROCEDURE getFirstConfigByLocation@1000000069(pcodLocation@1000000000 : Code[10]) : Code[20];
    VAR
      lrecConfig@1000000001 : Record 23044504;
    BEGIN
      //<FUNC>
      //  Description: Gets the first 'default' configuration for the location.
      //               This method should be only called from RTC, only thing from the device, use session helper.
      //  Called From:
      //  Side Effect: None
      //</FUNC>

      lrecConfig.SETRANGE("Location Code", pcodLocation);
      lrecConfig.SETRANGE("Default for Location", TRUE);
      IF (NOT lrecConfig.FINDFIRST) THEN BEGIN
        lrecConfig.SETRANGE("Default for Location");
        IF (lrecConfig.FINDFIRST) THEN;
      END;

      EXIT(lrecConfig.Code);
    END;

    PROCEDURE showSourceDocumentByType@1000000071(piSourceType@1000000009 : Integer;pcodSourceNo@1000000010 : Code[20]);
    VAR
      lrecPurchHeader@1000000001 : Record 38;
      lrecTransHeader@1000000002 : Record 5740;
      lrecSalesHeader@1000000003 : Record 36;
      lrecProdOrder@1000000004 : Record 5405;
      lrecWhseActivityHeader@1000000005 : Record 5766;
      lrecWhseReceipt@1000000006 : Record 7316;
      lrecWhseShipment@1000000007 : Record 7320;
      ltrecEventParams@1000000000 : TEMPORARY Record 23044511;
      lrecLPHeader@1000000008 : Record 23044505;
      lrecCountSheetLine@1000000011 : Record 23044301;
    BEGIN
      //<FUNC>
      //  Description: Show the document based on the source type and no
      //  Called From: "Device Activity Entries"::"Show Document::"OnAction"
      //  Side Effect: None
      //</FUNC>

      CASE piSourceType OF
        DATABASE::"Purchase Header", DATABASE::"Purchase Line":
          BEGIN
            lrecPurchHeader.GET(lrecPurchHeader."Document Type"::Order, pcodSourceNo);
            PAGE.RUN(PAGE::"Purchase Order",lrecPurchHeader);
          END;
         DATABASE::"Sales Header", DATABASE::"Sales Line":
          BEGIN
            lrecSalesHeader.GET(lrecSalesHeader."Document Type"::Order, pcodSourceNo);
            PAGE.RUN(PAGE::"Sales Order",lrecSalesHeader);
          END;
         DATABASE::"Transfer Header", DATABASE::"Transfer Line":
          BEGIN
            lrecTransHeader.GET(pcodSourceNo);
            PAGE.RUN(PAGE::"Transfer Order",lrecTransHeader);
          END;
         DATABASE::"Production Order", DATABASE::"Prod. Order Line", DATABASE::"Prod. Order Component", DATABASE::"Prod. Order Routing Line", DATABASE::"WMDM Consumption Entry":
          BEGIN
            lrecProdOrder.GET(lrecProdOrder.Status::Released,pcodSourceNo);
            PAGE.RUN(PAGE::"Released Production Order",lrecProdOrder);
          END;
         DATABASE::"Warehouse Activity Header", DATABASE::"Warehouse Activity Line":
          BEGIN
            lrecWhseActivityHeader.SETRANGE("No.", pcodSourceNo);
            IF (lrecWhseActivityHeader.FINDFIRST) THEN BEGIN
              IF (lrecWhseActivityHeader.Type = lrecWhseActivityHeader.Type::"Put-away") THEN BEGIN
                PAGE.RUN(PAGE::"Warehouse Put-away",lrecWhseActivityHeader);
              END ELSE IF (lrecWhseActivityHeader.Type = lrecWhseActivityHeader.Type::Pick) THEN BEGIN
                PAGE.RUN(PAGE::"Warehouse Pick",lrecWhseActivityHeader);
              END ELSE IF (lrecWhseActivityHeader.Type = lrecWhseActivityHeader.Type::Movement) THEN BEGIN
                PAGE.RUN(PAGE::"Warehouse Movement",lrecWhseActivityHeader);
              END ELSE IF (lrecWhseActivityHeader.Type = lrecWhseActivityHeader.Type::"Invt. Put-away") THEN BEGIN
                PAGE.RUN(PAGE::"Inventory Put-away",lrecWhseActivityHeader);
              END ELSE IF (lrecWhseActivityHeader.Type = lrecWhseActivityHeader.Type::"Invt. Pick") THEN BEGIN
                PAGE.RUN(PAGE::"Inventory Pick",lrecWhseActivityHeader);
              END;
            END;
          END;
        DATABASE::"Warehouse Receipt Header", DATABASE::"Warehouse Receipt Line":
          BEGIN
            lrecWhseReceipt.GET(pcodSourceNo);
            PAGE.RUN(PAGE::"Warehouse Receipt",lrecWhseReceipt);
          END;
        DATABASE::"Warehouse Shipment Header", DATABASE::"Warehouse Shipment Line":
          BEGIN
            lrecWhseShipment.GET(pcodSourceNo);
            PAGE.RUN(PAGE::"Warehouse Shipment",lrecWhseShipment);
          END;
        DATABASE::"IWX License Plate Header", DATABASE::"IWX License Plate Line":
          BEGIN
            lrecLPHeader.GET(pcodSourceNo);
            PAGE.RUN(PAGE::"IWX License Plate",lrecLPHeader);
          END;
        DATABASE::"IWX Count Sheet Line":
          BEGIN
            lrecCountSheetLine.SETRANGE("Count No.", pcodSourceNo);
            IF (lrecCountSheetLine.FIND('-')) THEN BEGIN
              PAGE.RUN(0, lrecCountSheetLine);
            END;
          END;
      END;
    END;

    PROCEDURE getStdText@1000000074(ptxtTextInput@1000000000 : Text) : Text;
    VAR
      lrecStdtext@1000000001 : Record 7;
      lcodStdTextCode@1000000004 : Code[10];
      lnPos@1000000003 : Integer;
    BEGIN
      //<FUNC>
      //  Description: Returns standard text code if it exists, otherwise returns supplied text.
      //  Called From: "Misc. Mgmt."::"addNote"
      //  Side Effect: None
      //</FUNC>

      lnPos := STRPOS(ptxtTextInput, ' ');

      IF (lnPos>0) AND (lnPos<=11) THEN BEGIN
        lcodStdTextCode :=   COPYSTR(ptxtTextInput, 1, lnPos-1);
      END ELSE IF STRLEN(ptxtTextInput) <= 10  THEN BEGIN
        lcodStdTextCode := ptxtTextInput;
        lnPos := 11;
      END;

      IF( lcodStdTextCode <> '' ) THEN BEGIN
        IF lrecStdtext.GET(lcodStdTextCode) THEN
          EXIT(lrecStdtext.Description + COPYSTR(ptxtTextInput, lnPos));

      END;

      EXIT(ptxtTextInput);
    END;

    PROCEDURE getCustomConfigValue@1000000073(precPDAConfig@1000000001 : Record 23044504;psKey@1000000000 : Text) : Text;
    VAR
      lrecCustomConfigValue@1000000002 : Record 23044391;
      lrrefRecord@1000000003 : RecordRef;
    BEGIN
      //<FUNC>
      //  Description: Wrapper for quickly returning custom config settings.
      //  Called From: "Misc. Mgmt."::"addNote"
      //  Side Effect: None
      //</FUNC>

      lrrefRecord.GETTABLE(precPDAConfig);
      lrecCustomConfigValue.SETRANGE("Record ID",lrrefRecord.RECORDID);
      lrecCustomConfigValue.SETRANGE("Template Key",psKey);
      IF( lrecCustomConfigValue.FINDFIRST ) THEN
        EXIT(lrecCustomConfigValue.Value);
    END;

    PROCEDURE ConvertUnitOfMeasure@1000000040(precItem@1000000000 : Record 27;pdInput@1000000001 : Decimal;pcodFromUom@1000000015 : Code[20];pcodToUom@1000000016 : Code[20]) pdOutput : Decimal;
    VAR
      lrecItem@1000000006 : Record 27;
      lrecItemTracking@1000000003 : Record 6502;
      lrecItemUnitOfMeasure@1000000004 : Record 5404;
      ldConvertedValue@1000000005 : Decimal;
      lcuNAVUOM@1000000007 : Codeunit 5402;
      ldBaseQuantity@1000000014 : Decimal;
    BEGIN
      //<FUNC>
      //  Description: Convert from one unit of measure to another.  This is used to help
      //               work with the new changes for alt/scanned/catch quantity work.
      //  Called From: Numerous
      //  Side Effect: None
      //</FUNC>

      IF ( ( pcodFromUom = '' ) OR ( pcodToUom = '' ) OR ( pcodToUom = pcodFromUom ) ) THEN BEGIN
        pdOutput := pdInput;
      END ELSE BEGIN
        pdOutput  := lcuNAVUOM.GetQtyPerUnitOfMeasure(
          precItem,
          pcodFromUom) *
          pdInput / lcuNAVUOM.GetQtyPerUnitOfMeasure(precItem,pcodToUom);

      END;
    END;

    PROCEDURE ConvertToBaseUomQuantity@1000000042(pcodItemNumber@1000000003 : Text;pdInput@1000000002 : Decimal;pcodFromUom@1000000001 : Code[20]) pdOutput : Decimal;
    VAR
      lrecItem@1000000000 : Record 27;
    BEGIN
      //<FUNC>
      //  Description: Convert from supplied UOM to item base UOM.
      //  Called From: Numerous
      //  Side Effect: None
      //</FUNC>

      lrecItem.GET( pcodItemNumber );
      pdOutput := ConvertUnitOfMeasure( lrecItem, pdInput, pcodFromUom,  lrecItem."Base Unit of Measure" );
    END;

    PROCEDURE GetQuantityConvertedToUom@1000000048(precItem@1000000004 : Record 27;VAR precEventParams@1000000000 : Record 23044511;pcodDesiredUom@1000000003 : Code[20]) pdOutput : Decimal;
    VAR
      ldScannedQuantity@1000000002 : Decimal;
    BEGIN
      //<FUNC>
      //  Description: Converts UOM from scanned params to requested UOM
      //  Called From: "GetQuantityConvertedToBaseUom"
      //  Side Effect: None
      //</FUNC>

      // more typical case, no unit of measure is needed
      pdOutput := precEventParams.getValueAsDecimal('quantity');

      IF ( precEventParams.getHasKey('scanned_uom') AND precEventParams.getHasKey('scanned_qty') ) THEN BEGIN
        //
        // In this situation we need to convert to a specific unit of measure.
        ldScannedQuantity := precEventParams.getValueAsDecimal('scanned_qty');

        pdOutput := ConvertUnitOfMeasure(
          precItem,
          ldScannedQuantity,
          precEventParams.getValue('scanned_uom'),
          pcodDesiredUom );

      END;
    END;

    PROCEDURE GetQuantityConvertedToBaseUom@1000000052(precItem@1000000004 : Record 27;VAR precEventParams@1000000000 : Record 23044511) pdOutput : Decimal;
    VAR
      ldScannedQuantity@1000000002 : Decimal;
    BEGIN
      //<FUNC>
      //  Description: Converts UOM from scanned params to item base UOM.
      //  Called From: "License Plate Mgmt."::"addLine"
      //               "License Plate Mgmt.'::"updateLine"
      //  Side Effect: None
      //</FUNC>

      pdOutput := GetQuantityConvertedToUom( precItem, precEventParams, precItem."Base Unit of Measure" );
    END;

    PROCEDURE debugEventParams@1000000004(VAR ptrecEventParams@1000000000 : TEMPORARY Record 23044511;pbShowMessage@1000000003 : Boolean);
    VAR
      lsKey@1000000001 : Text;
      lsValue@1000000002 : Text;
    BEGIN
      //<FUNC>
      //  Description: Simple routine to see event parameters.  Used during debugging.
      //  Called From:
      //  Side Effect: None
      //</FUNC>
      IF ptrecEventParams.FINDSET(FALSE) THEN BEGIN
        REPEAT
          lsKey := ptrecEventParams.Key;
          lsValue := ptrecEventParams.Value;
          IF( pbShowMessage ) THEN
            MESSAGE('Key: %1 \ Value: %2',lsKey,lsValue);
        UNTIL(ptrecEventParams.NEXT=0);
      END;
    END;

    PROCEDURE addDSColumnWithShowCaption@1000000070(VAR pbsXMLOutput@1000000000 : BigText;pcodDataType@1000000006 : Code[10];pvarValue@1000000001 : Variant;pbVisible@1000000002 : Boolean;piWidth@1000000003 : Integer;psCaption@1000000004 : Text;psName@1000000005 : Text;piEditControl@1000000007 : Integer;ptxtCSVOptions@1000000008 : Text;pbShowCaption@1000000009 : Boolean);
    BEGIN
      //<FUNC>
      //  Description: Generates a standard XML format for a column based on the supplied variant.
      //               If pcodDataType is used, it will use it otherwise it will infer the datattype from pvarValue
      //  Called From: "addDSColumnsFromConfigOverVis"
      //               "addDSColumn"
      //  Side Effect: None
      //</FUNC>

      // if left at 0 column ends up as a thick bar instead of being hidden
      IF( piWidth = 0 ) THEN
        piWidth := -1;

      IF ( '' = pcodDataType ) THEN BEGIN
        pcodDataType := getColumnType(pvarValue);
      END;

      IF ( bWriteColumnHeader ) THEN BEGIN

        pbsXMLOutput.ADDTEXT(
          STRSUBSTNO(
            '<C t="%1" n="%2" c="%3" v="%4" w="%5" i="%6" u="%7" e="%8" eo="%9" sc="%10"></C>',
            pcodDataType, //  getColumnType(pvarValue), // 1        //
            psName,                   // 2
            escapeText(psCaption),    // 3
            getTrueFalse(pbVisible),  // 4
            piWidth,                  // 5
            iColumnIndex,             // 6
            bIsConfigurableColumn,    // 7
            piEditControl,            // 8 //
            ptxtCSVOptions,           // 9 //
            getTrueFalse(pbShowCaption) // 10
            ) );

      END; // write column header

      iColumnIndex := iColumnIndex + 1;
    END;

    PROCEDURE addDSColumnWithShowCaptionDN@1000000062(VAR pdnOutput@1000000010 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder";pcodDataType@1000000006 : Code[10];pvarValue@1000000001 : Variant;pbVisible@1000000002 : Boolean;piWidth@1000000003 : Integer;psCaption@1000000004 : Text;psName@1000000005 : Text;piEditControl@1000000007 : Integer;ptxtCSVOptions@1000000008 : Text;pbShowCaption@1000000000 : Boolean);
    BEGIN
      //<FUNC>
      //  Description: Generates a standard XML format for a column based on the supplied variant.
      //               If pcodDataType is used, it will use it otherwise it will infer the datattype from pvarValue
      //  Called From: "addDSColumnFromConfigOverVisDN"
      //               "addDSColumnDN"
      //  Side Effect: None
      //</FUNC>

      // if left at 0 column ends up as a thick bar instead of being hidden
      IF( piWidth = 0 ) THEN
        piWidth := -1;

      IF ( '' = pcodDataType ) THEN BEGIN
        pcodDataType := getColumnType(pvarValue);
      END;

      IF ( bWriteColumnHeader ) THEN BEGIN
        pdnOutput.Append(
          STRSUBSTNO(
            '<C t="%1" n="%2" c="%3" v="%4" w="%5" i="%6" u="%7" e="%8" eo="%9" sc="%10"></C>',
            pcodDataType, //  getColumnType(pvarValue), // 1        //
            psName,                   // 2
            escapeText(psCaption),    // 3
            getTrueFalse(pbVisible),  // 4
            piWidth,                  // 5
            iColumnIndex,             // 6
            bIsConfigurableColumn,    // 7
            piEditControl,            // 8 //
            ptxtCSVOptions,            // 9 //
            getTrueFalse(pbShowCaption) // 10

            ) );

      END; // write column header

      iColumnIndex := iColumnIndex + 1;
    END;

    PROCEDURE getDeviceConfig@1000000007(VAR precOutDeviceConfig@1000000000 : Record 23044504;VAR ptrecEventParams@1000000003 : TEMPORARY Record 23044511);
    VAR
      lsValue@1000000001 : Text[250];
      lsUserName@1000000002 : Text[250];
    BEGIN
      // Returns the Device Configuration, either cached from any previous calls with
      // this record, or it will attempt to fetch anew.

      IF ( recDeviceConfig.Code = '' ) THEN BEGIN
        lsValue := ptrecEventParams.getValue('config_id');
        IF lsValue = '' THEN BEGIN
          lsValue := ptrecEventParams.getValue('pda_config');
          IF ( '' = lsValue ) THEN BEGIN
            lsValue :=ptrecEventParams.getValue('pda_code'); // backwards compatibility.
          END;
          IF ( '' = lsValue ) THEN BEGIN
            lsValue := ptrecEventParams.getValue('pda_id');
          END;
        END;

        // if no pda_code was supplied, then
        // use the user_name given.
        IF ( '' = lsValue ) THEN BEGIN
          lsUserName := ptrecEventParams.getValue('user_name');
          lsUserName := COPYSTR( lsUserName, 1, MAXSTRLEN( recDeviceConfig.Code ) ) ;
          lsValue := lsUserName;
        END;

        IF ( lsValue <> '' ) THEN BEGIN
          lsValue := COPYSTR( lsValue, 1, MAXSTRLEN( recDeviceConfig.Code) );
          IF ( lsValue = lsUserName ) THEN BEGIN
            // in the scenario of trying to use a username for a configuration
            // do not error
            IF ( recDeviceConfig.GET( lsValue ) ) THEN;
          END ELSE BEGIN
            // for every other scenario, error if the config does not exist.
            recDeviceConfig.GET( lsValue );
          END;
        END;
      END;

      precOutDeviceConfig := recDeviceConfig;
    END;

    PROCEDURE getValueAsDateTime@1000000013(psKey@1000000000 : Text;VAR ptrecEventParams@1000000014 : TEMPORARY Record 23044511) ldtResult : DateTime;
    VAR
      lrecWHISetup@1000000002 : Record 23044502;
    BEGIN

      lrecWHISetup.GET;
      EXIT(ptrecEventParams.getValueAsDateTime(psKey,lrecWHISetup."Default Date Format"));
    END;

    PROCEDURE getValueAsDate@1000000057(psKey@1000000000 : Text;VAR ptrecEventParams@1000000003 : TEMPORARY Record 23044511) ldtResult : Date;
    VAR
      lrecWHISetup@1000000001 : Record 23044502;
    BEGIN
      lrecWHISetup.GET;
      EXIT(ptrecEventParams.getValueAsDate(psKey));
    END;

    PROCEDURE getExpirationDate@1000000075(VAR ptrecEventParams@1000000000 : TEMPORARY Record 23044511) ldtResult : Date;
    VAR
      ldtDateTimeValue@1000000001 : DateTime;
    BEGIN
      ldtDateTimeValue := ptrecEventParams.getValueAsDateTime('exp_date', '');
      IF (ldtDateTimeValue <> 0DT) THEN BEGIN
        ldtResult := DT2DATE(ldtDateTimeValue);
      END ELSE BEGIN
        ldtResult := 0D;
      END;

      EXIT(ldtResult);
    END;

    PROCEDURE GetLocationCode@1000000080(VAR ptrecEventParams@1000000000 : TEMPORARY Record 23044511) : Text;
    VAR
      lrecConfig@1000000002 : Record 23044504;
      lsLocationCode@1000000001 : Text;
    BEGIN
      //<FUNC>
      //  Description: Returns the location code from event params and if not set then the device configuration
      //</FUNC>

      lsLocationCode := ptrecEventParams.getLocationCode();
      IF lsLocationCode = '' THEN BEGIN
        getDeviceConfig(lrecConfig,ptrecEventParams);
        lsLocationCode := lrecConfig."Location Code";
      END;


      EXIT(lsLocationCode);
    END;

    PROCEDURE setDefaultShipBin@1000000076(pcodItemNo@1000000000 : Code[20];pcodLocationCode@1000000001 : Code[10];VAR pcodBinCode@1000000002 : Code[20]);
    VAR
      lrecLocation@1000000003 : Record 14;
    BEGIN
      //<FUNC>
      //  Description: Sets shipping bin for sales/transfer line.
      //               Creates bin content if it doesn't exist.
      //  Called From: Sales Line and transfer line table
      //  Side Effect: None
      //</FUNC>

      IF NOT lrecLocation.GET(pcodLocationCode) THEN
        EXIT;

      IF lrecLocation."Shipment Bin Code" = '' THEN
        EXIT;

      createBinContent(pcodItemNo, pcodLocationCode, lrecLocation."Shipment Bin Code");
      pcodBinCode := lrecLocation."Shipment Bin Code";
    END;

    PROCEDURE createBinContent@1000000077(pcodItemNo@1000000002 : Code[20];pcodLocationCode@1000000001 : Code[10];pcodBinCode@1000000000 : Code[20]);
    VAR
      lrecBinContent@1000000003 : Record 7302;
    BEGIN
      //<FUNC>
      //  Description: Creates bin content record to ship from if it doesn't exist.
      //  Called From: This codeunit
      //  Side Effect: None
      //</FUNC>

      lrecBinContent."Item No." := pcodItemNo;
      lrecBinContent."Location Code" := pcodLocationCode;
      lrecBinContent."Bin Code" := pcodBinCode;
      lrecBinContent.Fixed := FALSE;
      IF NOT lrecBinContent.INSERT THEN ;
    END;

    PROCEDURE getUserNameWithDomain@1000000078(VAR ptrecEventParams@1000000000 : TEMPORARY Record 23044511) : Code[50];
    VAR
      lcodDomain@1000000001 : Code[50];
      lcodUserName@1000000002 : Code[50];
      ltxtUserAndDomain@1000000003 : Text;
    BEGIN
      //<FUNC>
      //  Description: Return user name and domain if domain exists.
      //  Called From:
      //  Side Effect: None
      //</FUNC>

      lcodDomain := ptrecEventParams.getValue('default_domain');
      lcodUserName := ptrecEventParams.getValue('user_name');
      IF (lcodDomain <> '') THEN BEGIN
        ltxtUserAndDomain := lcodDomain + '\\' + lcodUserName;
        lcodUserName := COPYSTR(ltxtUserAndDomain, 1, MAXSTRLEN(lcodUserName));
      END;

      EXIT(lcodUserName);
    END;

    PROCEDURE getColumnCaption@1000000084(precColumn@1000000002 : Record 23044512) lsCaption : Text;
    VAR
      lrecTranslationValue@1000000000 : Record 23044518;
      lrrefRecRef@1000000003 : RecordRef;
      lfrefFieldRef@1000000004 : FieldRef;
      lcodRegion@1000000001 : Code[10];
    BEGIN
      //<FUNC>
      // Get the column caption
      //</FUNC>
      lsCaption := precColumn."Column Caption";
      IF((precColumn."Table No." > 0) AND (precColumn."Field No." > 0) AND (precColumn."Use Field Caption" = precColumn."Use Field Caption"::Yes))
        THEN BEGIN
          lrrefRecRef.OPEN(precColumn."Table No.");
          lfrefFieldRef := lrrefRecRef.FIELD(precColumn."Field No.");
          lsCaption := lfrefFieldRef.CAPTION;
      END ELSE BEGIN
        lcodRegion := cuTranslationMgmt.getRegionCode();
        lsCaption := cuTranslationMgmt.GetTranslation(lcodRegion,precColumn."Column Caption");
      END;

      EXIT(lsCaption);
    END;

    PROCEDURE getPageCaptionFromRecSearch@1000000079(precRecordSearchRule@1000000000 : Record 23044529) : Text;
    VAR
      lrecObjWithCaption@1000000001 : Record 2000000058;
    BEGIN

      IF precRecordSearchRule.Page <> 0 THEN BEGIN
        lrecObjWithCaption.SETRANGE("Object Type",lrecObjWithCaption."Object Type"::Page);
        lrecObjWithCaption.SETRANGE("Object ID",precRecordSearchRule.Page);
        IF(lrecObjWithCaption.FINDFIRST) THEN BEGIN
      //    lrecObjWithCaption.CALCFIELDS("Object Caption");
          EXIT(lrecObjWithCaption."Object Caption");
        END;
      END;
      EXIT('');
    END;

    PROCEDURE GetTextFromBlob@1000000021(VAR ptrecTempBlob@1000000000 : TEMPORARY Record 99008535) : Text;
    VAR
      losInStream@1000000003 : InStream;
      ldnStreamReader@1000000002 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.StreamReader";
      ldnTextEncoder@1000000001 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.Encoding";
    BEGIN
      ptrecTempBlob.CALCFIELDS(Blob);
      ptrecTempBlob.Blob.CREATEINSTREAM(losInStream);
      ldnStreamReader := ldnStreamReader.StreamReader(losInStream, ldnTextEncoder.UTF8);
      EXIT(ldnStreamReader.ReadToEnd());
    END;

    PROCEDURE GetTextFromImage@1000000082(VAR ptrecTempBlob@1000000004 : TEMPORARY Record 99008535;pdImageWidth@1000000006 : Decimal;pdImageHeight@1000000007 : Decimal) : Text;
    VAR
      ldnMemStream@1000000003 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.MemoryStream";
      ldnBytes@1000000002 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Array";
      ldnConvert@1000000001 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Convert";
      ldtOriginalImage@1000000013 : DotNet "'System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'.System.Drawing.Image";
      ldtResizedBitmap@1000000012 : DotNet "'System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'.System.Drawing.Bitmap";
      ldtResizedMemStream@1000000011 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.MemoryStream";
      ldtImageFormat@1000000010 : DotNet "'System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'.System.Drawing.Imaging.ImageFormat";
      lisPictureStream@1000000000 : InStream;
      liResizedImageWidth@1000000009 : Integer;
      liResizedImageHeight@1000000008 : Integer;
      ldResizeRatio@1000000005 : Decimal;
      ldRatioWidth@1000000015 : Decimal;
      ldRatioHeight@1000000014 : Decimal;
    BEGIN
      ptrecTempBlob.CALCFIELDS(Blob);
      ptrecTempBlob.Blob.CREATEINSTREAM( lisPictureStream );
      ldnMemStream := ldnMemStream.MemoryStream();
      COPYSTREAM( ldnMemStream, lisPictureStream );

      ldResizeRatio := 1;

      IF (pdImageHeight>0) AND (pdImageWidth>0) THEN BEGIN
        ldtOriginalImage := ldtOriginalImage.FromStream(ldnMemStream);
        ldRatioWidth := pdImageWidth / ldtOriginalImage.Width();
        ldRatioHeight := pdImageHeight / ldtOriginalImage.Height();
        IF ( ldRatioWidth >= ldRatioHeight) THEN
          ldResizeRatio := ldRatioHeight
        ELSE
          ldResizeRatio := ldRatioWidth;
      END;

      IF (ldResizeRatio < 1) THEN BEGIN // we want to make image smaller
        liResizedImageWidth := (ldtOriginalImage.Width() * ldResizeRatio) DIV 1;
        liResizedImageHeight := (ldtOriginalImage.Height() * ldResizeRatio) DIV 1;
        ldtResizedBitmap := ldtResizedBitmap.Bitmap(ldtOriginalImage, liResizedImageWidth, liResizedImageHeight);
        ldtImageFormat := ldtImageFormat.Png();  // convert to png format
        ldtResizedMemStream := ldtResizedMemStream.MemoryStream();
        ldtResizedBitmap.Save(ldtResizedMemStream, ldtImageFormat);
        ldnBytes := ldtResizedMemStream.GetBuffer();
      END ELSE BEGIN
        ldnBytes := ldnMemStream.GetBuffer();
      END;

      EXIT(ldnConvert.ToBase64String(ldnBytes));
    END;

    PROCEDURE WriteTextToBlob@1000000072(psValue@1000000000 : Text;pbUTF8@1000000003 : Boolean;VAR ptrecTempBlob@1000000001 : TEMPORARY Record 99008535);
    VAR
      losOut@1000000002 : OutStream;
      ldnStreamWriter@1000000005 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.StreamWriter";
      ldnTextEncoder@1000000004 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.Encoding";
    BEGIN
      ptrecTempBlob.CALCFIELDS(Blob);
      ptrecTempBlob.Blob.CREATEOUTSTREAM( losOut );
      IF pbUTF8  THEN BEGIN
        ldnStreamWriter := ldnStreamWriter.StreamWriter(losOut, ldnTextEncoder.UTF8);
        ldnStreamWriter.Write(psValue);
        ldnStreamWriter.Flush();
      END ELSE BEGIN
        losOut.WRITETEXT( psValue );
      END;
      IF ptrecTempBlob.INSERT THEN ;
    END;

    PROCEDURE WriteFileToBlob@1000000081(psFileName@1000000001 : Text;VAR ptrecTempBlob@1000000000 : TEMPORARY Record 99008535);
    VAR
      losOut@1000000004 : OutStream;
      lfileBlobReader@1000000003 : File;
      lisBlobInStream@1000000002 : InStream;
    BEGIN
      lfileBlobReader.OPEN(psFileName);
      lfileBlobReader.CREATEINSTREAM(lisBlobInStream);
      ptrecTempBlob.Blob.CREATEOUTSTREAM( losOut );
      COPYSTREAM(losOut,lisBlobInStream);
      IF ptrecTempBlob.INSERT THEN ;
    END;

    PROCEDURE EscapeURIDataString@1000000032(psValue@1000000000 : Text) : Text;
    VAR
      ldnURI@1000000001 : DotNet "'System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Uri";
    BEGIN
      EXIT(ldnURI.EscapeDataString(psValue));
    END;

    PROCEDURE OpenURL@1000000036(psURL@1000000001 : Text);
    VAR
      laoShell@1000000000 : Automation "{50A7E9B0-70EF-11D1-B75A-00A0C90564FE} 1.0:{13709620-C279-11CE-A49E-444553540000}:'Microsoft Shell Controls And Automation'.Shell";
    BEGIN
      CREATE( laoShell, TRUE, TRUE); // create on the RTC client, not the server
      laoShell.Open( psURL );
    END;

    BEGIN
    {
      ************************
      Copyright Notice
      This objects content is copyright of Insight Works 2011.  All rights reserved.
      Any redistribution or reproduction of part or all of the contents in any form is prohibited.
      ************************
    }
    END.
  }
}

