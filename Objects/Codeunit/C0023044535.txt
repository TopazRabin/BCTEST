OBJECT Codeunit 23044535 WHI Dataset Tools
{
  OBJECT-PROPERTIES
  {
    Date=10/26/20;
    Time=[ 4:30:31 PM];
    Version List=WHI2.4.7684.0;
  }
  PROPERTIES
  {
    OnRun=BEGIN
          END;

  }
  CODE
  {
    VAR
      cuCommonFuncs@1000000000 : Codeunit 23044501;
      trecColFormula@1000000001 : TEMPORARY Record 23044512;
      cuTranslationMgmt@1000000011 : Codeunit 23044526;
      bHasRowFormulas@1000000003 : Boolean;
      bEmbedLineReservationEntries@1000000004 : Boolean;
      bBuildingHeader@1000000005 : Boolean;
      frefFieldDocument@1000000006 : FieldRef;
      frefFieldItem@1000000007 : FieldRef;
      frefFieldVariant@1000000008 : FieldRef;
      frefFieldLocation@1000000009 : FieldRef;
      frefFieldLine@1000000010 : FieldRef;
      bCouldFindReferenceFields@1000000012 : Boolean;
      bHasCalculateFields@1000000013 : Boolean;
      iFieldNumberNeedToCalculate@1000000014 : Integer;
      bPositiveFlag@1000000015 : Boolean;
      frefFieldSourceID@1000000017 : FieldRef;
      frefFieldSourceLineNo@1000000018 : FieldRef;
      frefFieldSourceType@1000000019 : FieldRef;
      codLocationCode@1000000020 : Code[10];
      bHasOverrideValue@1000000021 : Boolean;
      iSubCategoryFieldNo@1000000022 : Integer;

    PROCEDURE BuildHeaderLineDataset@1000000004(piEventID@1000000003 : Integer;VAR prrefHeader@1000000002 : RecordRef;VAR prrefLines@1000000001 : RecordRef;pbIncludeItemTrackingTable@1000000004 : Boolean;VAR pdnOutput@1000000005 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder");
    BEGIN
      //
      // Builds a dataset XML for a typical header/lines table for WHI  (most documents).
      //
      BuildHeaderLineDatasetEmbedRes(
        piEventID,
        prrefHeader,
        prrefLines,
        pbIncludeItemTrackingTable,
        FALSE, // pbEmbedLineReservationEntries
        pdnOutput) ;
    END;

    PROCEDURE BuildHeaderLineDatasetEmbedRes@1000000015(piEventID@1000000003 : Integer;VAR prrefHeader@1000000002 : RecordRef;VAR prrefLines@1000000001 : RecordRef;pbIncludeItemTrackingTable@1000000004 : Boolean;pbEmbedLineReservationEntries@1000000005 : Boolean;VAR pdnOutput@1000000006 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder");
    BEGIN
      BuildHeaderLineWithLocation(piEventID, prrefHeader, prrefLines, pbIncludeItemTrackingTable, pbEmbedLineReservationEntries, pdnOutput, '');
    END;

    PROCEDURE BuildHeaderLineWithLocation@1000000024(piEventID@1000000005 : Integer;VAR prrefHeader@1000000004 : RecordRef;VAR prrefLines@1000000003 : RecordRef;pbIncludeItemTrackingTable@1000000002 : Boolean;pbEmbedLineReservationEntries@1000000001 : Boolean;VAR pdnOutput@1000000007 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder";pcodLocationCode@1000000006 : Code[10]);
    BEGIN
      //
      // Builds a dataset XML for a typical header/lines table for WHI  (most documents).
      //

      codLocationCode := pcodLocationCode;
      bEmbedLineReservationEntries := pbEmbedLineReservationEntries;
      pdnOutput.Append('<DATASET>');;
      BuildHeaderTable( piEventID, prrefHeader, pdnOutput );
      BuildLineTable( piEventID, prrefLines, pdnOutput );
      IF ( pbIncludeItemTrackingTable ) THEN BEGIN
        BuildItemTrackingTable( pdnOutput );
      END;
      pdnOutput.Append('</DATASET>');
    END;

    PROCEDURE BuildLinesOnlyDataset@1000000000(piEventID@1000000003 : Integer;VAR prrefLines@1000000001 : RecordRef;pbIncludeItemTrackingTable@1000000004 : Boolean;VAR pdnOutput@1000000002 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder");
    BEGIN
      //
      // Builds a dataset XML for a typical lines or LIST only table for WHI (such as lookup lists)
      //

      pdnOutput.Append('<DATASET>');
      BuildLineTable( piEventID, prrefLines, pdnOutput );
      IF ( pbIncludeItemTrackingTable ) THEN BEGIN
        BuildItemTrackingTable( pdnOutput );
      END;
      pdnOutput.Append('</DATASET>');
    END;

    PROCEDURE BuildHeaderTable@1000000006(piEventID@1000000002 : Integer;VAR prrefHeader@1000000001 : RecordRef;VAR pdnOutput@1000000003 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder");
    BEGIN
      bBuildingHeader := TRUE;
      BuildTable( piEventID,'header',prrefHeader, pdnOutput );
    END;

    PROCEDURE BuildLineTable@1000000007(piEventID@1000000003 : Integer;VAR prrefLines@1000000000 : RecordRef;VAR pdnOutput@1000000001 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder");
    BEGIN
      BuildLineTableWithMax(piEventID, prrefLines, pdnOutput,0 );
    END;

    PROCEDURE BuildLineTableEmbedRes@1000000016(piEventID@1000000002 : Integer;VAR prrefLines@1000000001 : RecordRef;pbEmbedLineReservationEntries@1000000003 : Boolean;VAR pdnOutput@1000000004 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder");
    BEGIN
      BuildLineTableWithLocation(piEventID, prrefLines, pbEmbedLineReservationEntries, pdnOutput, '');
    END;

    PROCEDURE BuildLineTableWithLocation@1000000031(piEventID@1000000003 : Integer;VAR prrefLines@1000000002 : RecordRef;pbEmbedLineReservationEntries@1000000001 : Boolean;VAR pdnOutput@1000000005 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder";pcodLocationCode@1000000004 : Code[10]);
    BEGIN
      bEmbedLineReservationEntries := pbEmbedLineReservationEntries;
      codLocationCode := pcodLocationCode;
      BuildLineTable(piEventID, prrefLines, pdnOutput);
    END;

    PROCEDURE BuildTable@1000000008(piEventID@1000000003 : Integer;ptxtTableName@1000000001 : Text;VAR prrefRecords@1000000000 : RecordRef;VAR pdnOutput@1000000004 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder");
    BEGIN
      BuildTableWithMax( piEventID, ptxtTableName, prrefRecords, pdnOutput, 0 );
    END;

    PROCEDURE BuildTableWithMax@1000000013(piEventID@1000000003 : Integer;ptxtTableName@1000000001 : Text;VAR prrefRecords@1000000000 : RecordRef;VAR pdnOutput@1000000005 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder";piMaxRecordCount@1000000004 : Integer);
    BEGIN
      IF ( prrefRecords.NUMBER <> 0) AND (piEventID <> 0 ) THEN BEGIN
        WriteTableBegin( piEventID, ptxtTableName, prrefRecords, pdnOutput );
        BuildRowsWithMax( piEventID, FALSE, prrefRecords, pdnOutput, piMaxRecordCount );
        WriteTableEnd( pdnOutput );
      END;
    END;

    PROCEDURE SetFormulaCalcEachRow@1000000010(piEventID@1000000003 : Integer;VAR prrefLines@1000000002 : RecordRef;piFieldNumber@1000000004 : Integer;piLookupTable@1000000000 : Integer;piLookupField@1000000005 : Integer;ptxtLookupTextFilter@1000000001 : Text);
    BEGIN
      //
      // Sets a lookup calculate formula
      //

      SetOverrideValueEachRow(piEventID,
                              prrefLines.NUMBER,
                              piFieldNumber,
                              '',
                              STRSUBSTNO('%1,%2,%3', piLookupTable, piLookupField, ptxtLookupTextFilter),
                              TRUE,    // HasRowFormulas
                              FALSE,    // Has override value
                              0);
    END;

    PROCEDURE SetFormulaCalcEachRowString@1000000018(piEventID@1000000003 : Integer;VAR prrefLines@1000000002 : RecordRef;piFieldNumber@1000000004 : Integer;ptxtLookupTextFilter@1000000001 : Text);
    BEGIN
      //
      // Sets a string replacement calculate formula.
      //
      trecColFormula.RESET();
      trecColFormula.SETRANGE("Event", piEventID );
      trecColFormula.SETRANGE("Sub Category", '' );
      trecColFormula.SETRANGE("Table No.", prrefLines.NUMBER );
      trecColFormula.SETRANGE("Field No.", piFieldNumber );
      IF ( NOT trecColFormula.FIND('-') ) THEN BEGIN
        trecColFormula.INIT();
        trecColFormula."Event" := piEventID;
        trecColFormula."Sub Category" := '';
        trecColFormula."Table No." := prrefLines.NUMBER;
        trecColFormula."Field No." := piFieldNumber;
        trecColFormula.INSERT(FALSE);
      END;
      trecColFormula."Override Value" := STRSUBSTNO('%1%2','STRREPL:', ptxtLookupTextFilter );
      trecColFormula.MODIFY(FALSE);
      bHasRowFormulas := TRUE;
    END;

    PROCEDURE WriteTableBegin@1000000003(piEventID@1000000003 : Integer;ptxtTableName@1000000001 : Text;VAR prrefRecords@1000000000 : RecordRef;VAR pdnOutput@1000000007 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder");
    VAR
      lrecDocuSearchRule@1000000004 : Record 23044529;
      lbWasFound@1000000005 : Boolean;
      lbIsRightRecord@1000000006 : Boolean;
    BEGIN
      IF ( prrefRecords.NUMBER <> 0) AND (piEventID <> 0 ) THEN BEGIN
        pdnOutput.Append('<TABLE id="');
        pdnOutput.Append( ptxtTableName );
        pdnOutput.Append('"><COLS>');
        cuCommonFuncs.initializeColumns( TRUE );
        cuCommonFuncs.addDSColumnsFromConfigDN( pdnOutput, piEventID,'', prrefRecords.NUMBER);
        pdnOutput.Append('</COLS>');

        IF ( bEmbedLineReservationEntries AND NOT bBuildingHeader ) THEN BEGIN
          // this needs to occur after fields, but before ending of /R
          lrecDocuSearchRule.SETRANGE("Table No.", prrefRecords.NUMBER);
          lrecDocuSearchRule.SETFILTER("Doc. Field No.", '<>0');
          lrecDocuSearchRule.SETFILTER("Line Field No.", '<>0');
          lrecDocuSearchRule.SETFILTER("Item Field No.", '<>0');
          lrecDocuSearchRule.SETFILTER("Location Field No.", '<>0');
          lrecDocuSearchRule.SETFILTER("Variant Field No.", '<>0');
          bCouldFindReferenceFields := FALSE;

          lrecDocuSearchRule.SETRANGE("Specific Event", piEventID );
          lbWasFound := lrecDocuSearchRule.FINDSET(FALSE);
          IF ( NOT lbWasFound  ) THEN BEGIN
            lrecDocuSearchRule.SETRANGE("Specific Event",0 );
            lbWasFound := lrecDocuSearchRule.FINDSET(FALSE);
          END;

          IF (lbWasFound) THEN BEGIN
            bCouldFindReferenceFields := TRUE;
            REPEAT
              lbIsRightRecord := TRUE;

              IF (lrecDocuSearchRule."Location Field No." > 0) THEN BEGIN
                frefFieldLocation := prrefRecords.FIELD(lrecDocuSearchRule."Location Field No.");
              END;
              IF (codLocationCode <> '') THEN BEGIN
                IF (codLocationCode <> FORMAT(frefFieldLocation)) THEN BEGIN
                  lbIsRightRecord := FALSE;
                END;
              END;

              IF (lbIsRightRecord) THEN BEGIN
                IF (lrecDocuSearchRule."Doc. Field No." > 0) THEN BEGIN
                  frefFieldDocument := prrefRecords.FIELD(lrecDocuSearchRule."Doc. Field No.");
                END;
                IF (lrecDocuSearchRule."Line Field No." > 0) THEN BEGIN
                  frefFieldLine := prrefRecords.FIELD(lrecDocuSearchRule."Line Field No.");
                END;
                IF (lrecDocuSearchRule."Item Field No." > 0) THEN BEGIN
                  frefFieldItem := prrefRecords.FIELD(lrecDocuSearchRule."Item Field No.");
                END;
                IF (lrecDocuSearchRule."Variant Field No." > 0) THEN BEGIN
                  frefFieldVariant := prrefRecords.FIELD(lrecDocuSearchRule."Variant Field No.");
                END;
                IF (lrecDocuSearchRule."Source No. Field No." > 0) THEN BEGIN
                  frefFieldSourceID := prrefRecords.FIELD(lrecDocuSearchRule."Source No. Field No.");
                END;
                IF (lrecDocuSearchRule."Source Line Field No." > 0) THEN BEGIN
                  frefFieldSourceLineNo := prrefRecords.FIELD(lrecDocuSearchRule."Source Line Field No.");
                END;
                IF (lrecDocuSearchRule."Source Type Field No." > 0) THEN BEGIN
                  frefFieldSourceType := prrefRecords.FIELD(lrecDocuSearchRule."Source Type Field No.");
                END;
              END;
            UNTIL ((lrecDocuSearchRule.NEXT = 0) OR (lbIsRightRecord));
          END ELSE BEGIN
            ERROR(cuTranslationMgmt.getTranslatedString('ERR_UNKNOWN_EVENT', ''), prrefRecords.NAME);
          END;
        END;
      END;
    END;

    PROCEDURE WriteTableEnd@1000000005(VAR pdnOutput@1000000000 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder");
    BEGIN
      pdnOutput.Append('</TABLE>');
    END;

    PROCEDURE BuildRows@1000000001(piEventID@1000000003 : Integer;pbSetupColumns@1000000001 : Boolean;VAR prrefRecords@1000000000 : RecordRef;VAR pdnOutput@1000000004 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder");
    BEGIN
      BuildRowsWithMax( piEventID, pbSetupColumns, prrefRecords, pdnOutput, 0 );
    END;

    PROCEDURE BuildRowsWithMax@1000000012(piEventID@1000000003 : Integer;pbSetupColumns@1000000001 : Boolean;VAR prrefRecords@1000000000 : RecordRef;VAR pdnOutput@1000000005 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder";piMaxRecordCount@1000000004 : Integer);
    BEGIN
      //
      // Can be used as part of a table **OR**, if it's in update mode
      // then only the ROWS are necessary.
      //
      IF ( pbSetupColumns ) THEN BEGIN

        // this is only needed if no column
        // definitions have been added.
        cuCommonFuncs.initializeColumns( TRUE );
        cuCommonFuncs.setWriteColumnHeader( FALSE ); // do not write the <c> definitions
        cuCommonFuncs.addDSColumnsFromConfigDN(pdnOutput, piEventID, '', prrefRecords.NUMBER );
        cuCommonFuncs.setWriteColumnHeader( TRUE ); // the update in this case will not use them.
      END;

      IF (piMaxRecordCount = 0) THEN BEGIN
        // IF not passed in max record count
        // set to the max
        piMaxRecordCount := 5000;   // an arbitrary big number, this is just to indicate
                                    // 'some big' number if none is specified.
                                    // after this point NAV starts to experience
      END;

      pdnOutput.Append('<ROWS>');
      IF ( NOT prrefRecords.ISEMPTY() ) THEN BEGIN
        REPEAT
          BuildSingleRow(piEventID, prrefRecords, pdnOutput );
          piMaxRecordCount := piMaxRecordCount - 1;
        UNTIL(( prrefRecords.NEXT() = 0 ) OR (piMaxRecordCount = 0));
      END; // if there are records.
      pdnOutput.Append('</ROWS>');
    END;

    PROCEDURE BuildSingleRow@1000000009(piEventID@1000000003 : Integer;VAR prrefRecord@1000000000 : RecordRef;VAR pdnOutput@1000000006 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder");
    VAR
      liSourceLineNo@1000000005 : Integer;
      lcodSourceDocumentNo@1000000004 : Code[20];
      liSourceType@1000000001 : Integer;
    BEGIN
      IF ( bEmbedLineReservationEntries AND bCouldFindReferenceFields AND NOT bBuildingHeader ) THEN BEGIN
        IF (FORMAT(frefFieldSourceID) <> '') THEN BEGIN
          lcodSourceDocumentNo := frefFieldSourceID.VALUE;
        END ELSE BEGIN
          lcodSourceDocumentNo := frefFieldDocument.VALUE;
        END;

        IF (FORMAT(frefFieldSourceLineNo) <> '') THEN BEGIN
          liSourceLineNo := frefFieldSourceLineNo.VALUE;
        END ELSE BEGIN
          liSourceLineNo := frefFieldLine.VALUE;
        END;

        IF (FORMAT(frefFieldSourceType) <> '') THEN BEGIN
          liSourceType := frefFieldSourceType.VALUE;
        END ELSE BEGIN
          liSourceType := prrefRecord.NUMBER;
        END;
      END;

      BuildSingleRowWithResSource(piEventID, prrefRecord, pdnOutput, lcodSourceDocumentNo, liSourceLineNo, liSourceType);
    END;

    PROCEDURE BuildSingleRowWithResSource@1000000020(piEventID@1000000002 : Integer;VAR prrefRecord@1000000001 : RecordRef;VAR pdnOutput@1000000006 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder";pcodSourceDocumentNo@1000000005 : Code[20];piSourceLineNo@1000000013 : Integer;piSourceType@1000000011 : Integer);
    VAR
      lcodVariantCode@1000000010 : Text;
      lcodItemNumber@1000000009 : Text;
      lcodLocation@1000000008 : Code[10];
      ltxtTempFieldValue@1000000004 : Text[250];
      lrecItem@1000000003 : Record 27;
    BEGIN
      //<FUNC>
      // Build sing row with source id, source type, source line no for reservation entry
      //</FUNC>

      pdnOutput.Append('<R><FIELDS>');
      IF ( bHasRowFormulas ) THEN BEGIN
        CalcRowFormulas( piEventID, prrefRecord );
      END;

      IF (bHasCalculateFields) THEN BEGIN
        CalculateFields(piEventID, prrefRecord);
      END;

      IF (bHasOverrideValue) THEN BEGIN
        GetOverrideValueFields(piEventID, prrefRecord);
      END;

      cuCommonFuncs.addDSFieldsForRecordDN(pdnOutput, prrefRecord, piEventID, '');
      pdnOutput.Append('</FIELDS>');

      IF ( bEmbedLineReservationEntries AND bCouldFindReferenceFields AND NOT bBuildingHeader ) THEN BEGIN
        // this needs to occur after fields, but before ending of /R
        lcodItemNumber := frefFieldItem.VALUE;
        lcodLocation := frefFieldLocation.VALUE;
        lcodVariantCode := frefFieldVariant.VALUE;

        IF lrecItem.GET(lcodItemNumber) THEN BEGIN
          IF (lrecItem."Item Tracking Code" <> '') THEN BEGIN
            cuCommonFuncs.getReservationEntriesDN(
                   TRUE, // pbFastDS
                   pdnOutput,
                   lcodItemNumber,
                   lcodVariantCode,
                   lcodLocation,
                   pcodSourceDocumentNo,
                   piSourceLineNo,
                   bPositiveFlag,
                   piSourceType,
                   '',  // Lot No. //
                   ''   // Serial No. //
                   );
          END;
        END;
      END;

      pdnOutput.Append('</R>');
    END;

    PROCEDURE CalcRowFormulas@1000000014(piEventID@1000000003 : Integer;VAR prrefRecord@1000000000 : RecordRef);
    VAR
      liLookupTable@1000000001 : Integer;
      liLookupField@1000000002 : Integer;
      ltxtLookupFilter@1000000004 : Text;
      lrrefLookupRec@1000000005 : RecordRef;
      ltxtLookupValue@1000000006 : Text;
      lfrefLookupValue@1000000007 : FieldRef;
    BEGIN
      //
      // Calculate row formulas.
      //
      //
      trecColFormula.RESET();
      trecColFormula.SETRANGE("Event", piEventID );
      trecColFormula.SETRANGE("Table No.", prrefRecord.NUMBER );
      trecColFormula.SETFILTER("Field No.", '<0');

      // For Formula, do not set sub category when create
      trecColFormula.SETFILTER("Sub Category", '=%1', '');

      IF ( trecColFormula.FIND('-') ) THEN BEGIN
        REPEAT
          IF ( trecColFormula."Override Value" <> '' ) THEN BEGIN
            //
            // Hello developer.  There are two different ways that CalcFormula
            // can be called.
            // This is one of them, but as of the October 2015 release, you can also
            // just predefine the formula itself on Device columns, which will be faster.
            // This mechanism remains in here to support legacy integration.
            //
            ltxtLookupValue := cuCommonFuncs.CalcFormula( prrefRecord, trecColFormula."Override Value" );

            //Removed check for blank to improve flexibility of calculations.
            //This allows formulas to return blank values.
            cuCommonFuncs.setDSFieldOverrideValue(
                piEventID,
                '',
                prrefRecord.NUMBER,
                trecColFormula."Field No.",
                ltxtLookupValue );
          END;// if it's not blank
        UNTIL( trecColFormula.NEXT() = 0 );
      END; // if there are row formulas
    END;

    PROCEDURE BuildItemTrackingTable@1000000021(VAR pdnOutput@1000000002 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder");
    VAR
      lrecItemTrackingCode@1000000001 : Record 6502;
    BEGIN
      //
      // Adds an item tracking table.  Note, this is a 'special' table, because the
      // columns are not configurable.
      //
      pdnOutput.Append('<TABLE id="itemtrackingcodes"><COLS>');
      cuCommonFuncs.initializeColumns( TRUE );
      cuCommonFuncs.addDSTrackingColumnsDN(pdnOutput);
      pdnOutput.Append('</COLS><ROWS>');
      lrecItemTrackingCode.RESET();
      // special condition of always needing a '' blank item tracking code.
      pdnOutput.Append('<R><FIELDS>');
      cuCommonFuncs.initializeColumns( FALSE );
      cuCommonFuncs.addDSTrackingFieldsDN(pdnOutput, '' );
      pdnOutput.Append('</FIELDS></R>');
      IF ( lrecItemTrackingCode.FIND('-') ) THEN BEGIN
        REPEAT
          pdnOutput.Append('<R><FIELDS>');
          cuCommonFuncs.initializeColumns( FALSE );
          cuCommonFuncs.addDSTrackingFieldsDN(pdnOutput, lrecItemTrackingCode.Code );
          pdnOutput.Append('</FIELDS></R>');
        UNTIL ( lrecItemTrackingCode.NEXT() = 0 );
      END;
      pdnOutput.Append('</ROWS></TABLE>')
    END;

    PROCEDURE BuildLineTableWithMax@1000000011(piEventID@1000000003 : Integer;VAR prrefLines@1000000000 : RecordRef;VAR pdnOutput@1000000004 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder";piMaxRecordCount@1000000001 : Integer);
    BEGIN
      bBuildingHeader := FALSE;
      BuildTableWithMax( piEventID,'line',prrefLines, pdnOutput, piMaxRecordCount  );
    END;

    PROCEDURE SetCalculateFields@1000000017(piEventID@1000000002 : Integer;VAR prrefLines@1000000001 : RecordRef;piFieldNumberNeedToCalculate@1000000000 : Integer;piFieldNumberQuantity@1000000004 : Integer;piFieldNumberQuantiyToHandle@1000000005 : Integer;piFieldNumberQuantityHandled@1000000006 : Integer);
    BEGIN
      //<FUNC>
      // Set need to calculate fields
      //</FUNC>

      trecColFormula.RESET();
      trecColFormula.SETRANGE("Event", piEventID );
      trecColFormula.SETRANGE("Sub Category", '' );
      trecColFormula.SETRANGE("Table No.", prrefLines.NUMBER );
      trecColFormula.SETRANGE("Field No.", piFieldNumberNeedToCalculate );
      IF ( NOT trecColFormula.FIND('-') ) THEN BEGIN
        trecColFormula.INIT();
        trecColFormula."Event" := piEventID;
        trecColFormula."Sub Category" := '';
        trecColFormula."Table No." := prrefLines.NUMBER;
        trecColFormula."Field No." := piFieldNumberNeedToCalculate;
        trecColFormula.INSERT(FALSE);
      END;

      trecColFormula."Override Value" := STRSUBSTNO('%1,%2,%3',
                                                    piFieldNumberQuantity,
                                                    piFieldNumberQuantiyToHandle,
                                                    piFieldNumberQuantityHandled );
      trecColFormula.MODIFY(FALSE);

      iFieldNumberNeedToCalculate := piFieldNumberNeedToCalculate;
      bHasCalculateFields := TRUE;
    END;

    PROCEDURE CalculateFields@1000000022(piEventID@1000000001 : Integer;VAR prrefRecord@1000000000 : RecordRef);
    VAR
      liFieldNumberQuantity@1000000004 : Integer;
      liFieldNumberQuantiyToHandle@1000000003 : Integer;
      liFieldNumberQuantityHandled@1000000002 : Integer;
      lreffQuantityField@1000000005 : FieldRef;
      lreffQuantiyToHandleField@1000000006 : FieldRef;
      lreffQuantityHandledField@1000000007 : FieldRef;
      ltxtCalculatedFieldValue@1000000008 : Text[100];
      ldQuantity@1000000009 : Decimal;
      ldQuantityToHandle@1000000010 : Decimal;
      ldQuantityHandled@1000000011 : Decimal;
    BEGIN
      //<FUNC>
      // Calculate fields
      //</FUNC>

      trecColFormula.RESET();
      trecColFormula.SETRANGE("Event", piEventID );
      trecColFormula.SETRANGE("Table No.", prrefRecord.NUMBER );
      trecColFormula.SETRANGE("Field No.", iFieldNumberNeedToCalculate );

      IF ( trecColFormula.FIND('-') ) THEN BEGIN
        REPEAT
          IF ( trecColFormula."Override Value" <> '' ) THEN BEGIN
            IF ( EVALUATE( liFieldNumberQuantity, SELECTSTR(1, trecColFormula."Override Value" ) )) THEN BEGIN
              IF ( EVALUATE( liFieldNumberQuantiyToHandle, SELECTSTR(2, trecColFormula."Override Value" ) )) THEN BEGIN
                EVALUATE(liFieldNumberQuantityHandled, SELECTSTR(3, trecColFormula."Override Value" ));
                IF (liFieldNumberQuantity > 0) THEN BEGIN
                  lreffQuantityField := prrefRecord.FIELD(liFieldNumberQuantity);
                  EVALUATE(ldQuantity, FORMAT(lreffQuantityField.VALUE));
                END;

                IF (liFieldNumberQuantiyToHandle > 0) THEN BEGIN
                  lreffQuantiyToHandleField := prrefRecord.FIELD(liFieldNumberQuantiyToHandle);
                  EVALUATE(ldQuantityToHandle, FORMAT(lreffQuantiyToHandleField.VALUE));
                END;

                IF (liFieldNumberQuantityHandled > 0) THEN BEGIN
                  lreffQuantityHandledField := prrefRecord.FIELD(liFieldNumberQuantityHandled);
                  EVALUATE(ldQuantityHandled, FORMAT(lreffQuantityHandledField.VALUE));
                END;

                ltxtCalculatedFieldValue := STRSUBSTNO('%1', (ldQuantity - ldQuantityToHandle - ldQuantityHandled));
                cuCommonFuncs.setDSFieldOverrideValue(
                  piEventID,
                  '',
                  prrefRecord.NUMBER,
                  trecColFormula."Field No.",
                  ltxtCalculatedFieldValue );
              END; // if we have a valid lookup field
            END; // if we have a valid lookup table.
          END;// if it's not blank
        UNTIL( trecColFormula.NEXT() = 0 );
      END; // if there are row formulas
    END;

    PROCEDURE SetPositiveFlag@1000000019(pbPositiveFlag@1000000000 : Boolean);
    BEGIN
      //<FUNC>
      // Set positive flag for reservation entries
      //</FUNC>

      bPositiveFlag := pbPositiveFlag;
    END;

    PROCEDURE SetOverrideValueEachRow@1000000025(piEventID@1000000005 : Integer;piTableNumber@1000000004 : Integer;piFieldNumber@1000000003 : Integer;pcodSubCategory@1000000002 : Code[20];ptxtOverrideValue@1000000001 : Text;pbHasRowFormulas@1000000000 : Boolean;pbHasOverrideValue@1000000006 : Boolean;piSubCategoryFieldNo@1000000007 : Integer);
    BEGIN
      //<FUNC>
      // will set a over value for a specific row
      //</FUNC>

      IF ptxtOverrideValue='' THEN
        ptxtOverrideValue := 'dummy_override_value';

      trecColFormula.RESET();
      trecColFormula.SETRANGE("Event", piEventID );
      trecColFormula.SETRANGE("Sub Category", pcodSubCategory );
      trecColFormula.SETRANGE("Table No.", piTableNumber );
      trecColFormula.SETRANGE("Field No.", piFieldNumber );
      IF ( NOT trecColFormula.FIND('-') ) THEN BEGIN
        trecColFormula.INIT();
        trecColFormula."Event" := piEventID;
        trecColFormula."Sub Category" := pcodSubCategory;
        trecColFormula."Table No." := piTableNumber;
        trecColFormula."Field No." := piFieldNumber;
        trecColFormula.INSERT(FALSE);
      END;
      trecColFormula."Override Value" := ptxtOverrideValue;
      trecColFormula.MODIFY(FALSE);
      bHasRowFormulas := pbHasRowFormulas;
      bHasOverrideValue := pbHasOverrideValue;

      iSubCategoryFieldNo := piSubCategoryFieldNo;
    END;

    PROCEDURE GetOverrideValueFields@1000000039(piEventID@1000000003 : Integer;VAR prrefRecord@1000000000 : RecordRef);
    VAR
      liLookupTable@1000000001 : Integer;
      liLookupField@1000000002 : Integer;
      ltxtLookupFilter@1000000004 : Text;
      lrrefLookupRec@1000000005 : RecordRef;
      ltxtLookupValue@1000000006 : Text;
      lrefSubCategoryField@1000000008 : FieldRef;
    BEGIN
      //
      // set override value to the row
      //
      //
      trecColFormula.RESET();
      trecColFormula.SETRANGE("Event", piEventID );
      trecColFormula.SETRANGE("Table No.", prrefRecord.NUMBER );
      trecColFormula.SETFILTER("Field No.", '<0');

      IF ((iSubCategoryFieldNo > 0) AND (prrefRecord.FIELDEXIST(iSubCategoryFieldNo))) THEN BEGIN
        lrefSubCategoryField := prrefRecord.FIELD(iSubCategoryFieldNo);
        trecColFormula.SETRANGE("Sub Category", COPYSTR(STRSUBSTNO('%1', lrefSubCategoryField.VALUE), 1, MAXSTRLEN(trecColFormula."Sub Category")));
      END;

      IF ( trecColFormula.FIND('-') ) THEN BEGIN
        REPEAT
          IF ( trecColFormula."Override Value" <> '' ) THEN BEGIN
            //
            // Hello developer.  There are two different ways that CalcFormula
            // can be called.
            // This is one of them, but as of the October 2015 release, you can also
            // just predefine the formula itself on Device columns, which will be faster.
            // This mechanism remains in here to support legacy integration.
            //
            ltxtLookupValue := trecColFormula."Override Value";

            //Removed check for blank to improve flexibility of calculations.
            //This allows formulas to return blank values.
            cuCommonFuncs.setDSFieldOverrideValue(
                piEventID,
                '',
                prrefRecord.NUMBER,
                trecColFormula."Field No.",
                ltxtLookupValue );
          END;// if it's not blank
        UNTIL( trecColFormula.NEXT() = 0 );
      END; // if there are row formulas
    END;

    BEGIN
    {
      ************************
      Copyright Notice
      This objects content is copyright of Insight Works 2011.  All rights reserved.
      Any redistribution or reproduction of part or all of the contents in any form is prohibited.
      ************************
    }
    END.
  }
}

