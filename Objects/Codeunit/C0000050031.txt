OBJECT Codeunit 50031 WMDM Topaz Extension
{
  OBJECT-PROPERTIES
  {
    Date=03/04/21;
    Time=[ 5:44:48 AM];
    Modified=Yes;
    Version List=WHI2.4.7684.0,001;
  }
  PROPERTIES
  {
    TableNo=23044511;
    OnRun=BEGIN
            //////////////////////////////////////////////
            //<Summary>
            // The entry point for WMDM extensibility.
            // Basic function use stubbed out for various usage scenarios.
            // For more complete information on the WMDM Extensibility options
            // see the appropriate WMDM documentation guides.
            //</Summary>
            //<Author>R.Trudeau</Author>
            //<Date>05/26/2016</Date>
            //<Issue></Issue>
            //<Version>DMS16.05</Version>
            //////////////////////////////////////////////


            trecEventParams.COPY(Rec, TRUE);  //make Rec data global

            //
            // The Event ID being called
            // The event is either set in the WMDM menu configuration or pre-defined
            // for the WMDM normal operation.
            // For pre-defined values consult the WMDM documentation.
            //liEventID := Rec.getEvent();


            //
            // Events that can be triggered by the WMDM.
            // OnPrint -
            // OnBeforeProcessEvent
            // OnAfterProcessEvent
            // OnAssignLP
            // OnBeforeModify
            // OnChangeTracking
            // OnSetup
            // OnRemoveUsage
            // OnReportRun

            CASE getExtensibilityEvent OF
              "Extensibility Event"::OnBeforeProcessEvent: onBeforeProcessEvent;
              "Extensibility Event"::OnAfterProcessEvent:  onAfterProcessEvent;
            END; // case

            COPY(trecEventParams, TRUE);
          END;

  }
  CODE
  {
    VAR
      trecEventParams@1000000000 : TEMPORARY Record 23044511;
      cuWMDMCommon@1000000001 : Codeunit 23044501;
      iEventID@1000000005 : Integer;
      cuWMDMSetup@1000000004 : Codeunit 23044590;
      cuWMDMShip@1000000003 : Codeunit 23044510;
      recWMDMSetup@1000000002 : Record 23044502;
      cuRcptMgmt@1000000007 : Codeunit 23044509;
      cuWMDMActivityLogMgt@1000000006 : Codeunit 23044537;
      ptrecEventParamsTest@1000000008 : TEMPORARY Record 23044511;
      LicensePlateMgmt@1000000009 : Codeunit 23044520;

    LOCAL PROCEDURE onBeforeProcessEvent@1000000002();
    BEGIN
      //
      // Use this function to override or extend existing events or when creating new
      // requests.
      //

      iEventID := trecEventParams.getEvent;
      recWMDMSetup.GET();

      CASE trecEventParams.getEvent OF
        50004: onBeforePostWhseReceipt;
      //  50010 : getDocumentList_bak(trecEventParams);
        50010:  onGetReceivingDocumentList;
        23044000: getItemCommentsForPick;//<IW author="R.Letts" date="12/12/18" version="IW18.12" issue="4550">
        10001: getPartData;//<IW author="E.Li" date="01/30/19" issue="4570">
        23044001: getNextBin; //<IW author="R.Letts" date="10/7/19" issue="5037">
      END;
    END;

    LOCAL PROCEDURE onAfterProcessEvent@1000000003();
    BEGIN
      //
      // Use this function to add additional functionality to existing events after they
      // have completed.
      //

      CASE trecEventParams.getEvent OF
        50004: onAfterPostWhseReceipt;
      END;
    END;

    LOCAL PROCEDURE sendSuccessResult@1000000014(psResultMessage@1000000001 : Text;pbOverrideEvent@1000000002 : Boolean);
    VAR
      lcuWMDMCommon@1000000003 : Codeunit 23044501;
      lbtTemp@1000000004 : BigText;
      losTemp@1000000005 : OutStream;
    BEGIN
      //
      // Wrapper function to abstract some of the boiler plate code required by the WMDM
      // when using the extensibility framework.
      //
      lcuWMDMCommon.generateSuccessReturnWithMsg(1, psResultMessage,lbtTemp);
      trecEventParams."Extensibility Blob".CREATEOUTSTREAM( losTemp );
      trecEventParams.setExtensibilityOverride(pbOverrideEvent);
      lbtTemp.WRITE( losTemp );
      trecEventParams.MODIFY();
    END;

    LOCAL PROCEDURE sendStandardResult@1000000009(pbtResult@1000000001 : BigText;pbOverrideEvent@1000000000 : Boolean);
    VAR
      losTemp@1000000003 : OutStream;
    BEGIN
      //
      // Wrapper function to abstract some of the boiler plate code required by the WMDM
      // when using the extensibility framework.
      //
      trecEventParams."Extensibility Blob".CREATEOUTSTREAM( losTemp );
      trecEventParams.setExtensibilityOverride(pbOverrideEvent);
      pbtResult.WRITE( losTemp );
      trecEventParams.MODIFY();
    END;

    LOCAL PROCEDURE runReport@1000000005(piCodeunit@1000000000 : Integer);
    VAR
      liSessionID@1000000002 : Integer;
    BEGIN
      STARTSESSION(liSessionID,piCodeunit,COMPANYNAME,trecEventParams);
    END;

    PROCEDURE checkPrinters@1000000072(precPDAConfig@1000000000 : Record 23044504);
    VAR
      ltcPrinterNotFound@1000000002 : TextConst 'ENU=Printer: ''%1'' was not found for User: ''%2'' on the server: ''%3''.  Please verify that the printer has been configured.;ESM=Impresora: ''%1'' no se encontr¢ para el usuario: ''%2'' en el servidor: ''%3''. Por favor, compruebe que la impresora se ha configurado.;FRC=Imprimante: ''%1'' n''a pas ‚t‚ trouv‚e pour l''utilisateur: ''%2'' sur le serveur: ''%3''. S''il vous plaŒt v‚rifier que l''imprimante a ‚t‚ configur‚.;ENC=Printer: ''%1'' was not found for User: ''%2'' on the server: ''%3''.  Please verify that the printer has been configured.';
      dnPrinterSettings@1000000003 : DotNet "'System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'.System.Drawing.Printing.PrinterSettings";
      lrecActiveSession@1000000001 : Record 2000000110;
    BEGIN
      dnPrinterSettings := dnPrinterSettings.PrinterSettings();

      lrecActiveSession.SETRANGE("User ID",USERID);
      IF lrecActiveSession.FINDLAST THEN ;

      IF( precPDAConfig."Regular Printer Name" <> '' ) THEN BEGIN
        dnPrinterSettings.PrinterName := precPDAConfig."Regular Printer Name";
        IF( NOT dnPrinterSettings.IsValid ) THEN
          ERROR(ltcPrinterNotFound,precPDAConfig."Regular Printer Name",USERID,lrecActiveSession."Server Computer Name");
      END;

      IF( precPDAConfig."Label Printer Name" <> '' ) THEN BEGIN
        dnPrinterSettings.PrinterName := precPDAConfig."Label Printer Name";
        IF( NOT dnPrinterSettings.IsValid ) THEN
          ERROR(ltcPrinterNotFound,precPDAConfig."Label Printer Name",USERID, lrecActiveSession."Server Computer Name");
      END;
    END;

    LOCAL PROCEDURE onBeforePostWhseReceipt@1000000001();
    VAR
      lrecPDAConfig@1000000000 : Record 23044504;
      lrecWhseRcptHeader@1000000005 : Record 7316;
      lrecCrossDockOpp@1000000004 : Record 5768;
      lrecLocation@1000000003 : Record 14;
      lcuCrossDockMgt@1000000002 : Codeunit 5780;
      lcodReceiptNumber@1000000001 : Code[20];
    BEGIN
      // get the configuration currently being used on the device
      //trecEventParams.getPDAConfig(lrecPDAConfig);

      // checks both the 'Regular' and 'Label' printer on the PDA Configuration
      // Errors will be bubbled up to the user
      //cuWMDMCommon.checkPrinters(lrecPDAConfig);


      //<IW author="R.Trudeau" date="03/23/17" issue="24431">
      lcodReceiptNumber := trecEventParams.getValue('No.');
      lrecWhseRcptHeader.GET(lcodReceiptNumber);
      lrecLocation.GET(lrecWhseRcptHeader."Location Code");
      IF( lrecLocation."Cross-Dock Bin Code" <> '' ) THEN
        lcuCrossDockMgt.CalculateCrossDockLines(lrecCrossDockOpp,'',lrecWhseRcptHeader."No.",lrecWhseRcptHeader."Location Code");
      //</IW>
    END;

    LOCAL PROCEDURE onAfterPostWhseReceipt@1000000006();
    VAR
      xx@1000000000 : Record 50019;
    BEGIN
      // Force the printing to another session
      runReport(CODEUNIT::"WMDM Topaz Print Extension");
    END;

    LOCAL PROCEDURE getDocumentList_bak@1000000016(VAR ptrecEventParams@1000000014 : TEMPORARY Record 23044511);
    VAR
      ltcXMLType@1000000001 : TextConst 'ENU=<TYPE>%1</TYPE>;ENC=<TYPE>%1</TYPE>';
      ltcXMLNumber@1000000002 : TextConst 'ENU=<NUMBER>%1</NUMBER>;ENC=<NUMBER>%1</NUMBER>';
      ltcXMLLocation@1000000003 : TextConst 'ENU=<LOCATION>%1</LOCATION>;ENC=<LOCATION>%1</LOCATION>';
      ltcXMLUserID@1000000004 : TextConst 'ENU=<USER_ID>%1</USER_ID>;ENC=<USER_ID>%1</USER_ID>';
      ltcXMLDate@1000000005 : TextConst 'ENU=<DATE>%1</DATE>;ENC=<DATE>%1</DATE>';
      ltcUnknownDocument@1000000026 : TextConst 'ENC=Unknown Activity Document: %1.';
      lcodUser@1000000006 : Code[50];
      lsFilter@1000000009 : Text[250];
      lrecPDAConfig@1000000000 : Record 23044504;
      ltrecDocList@1000000011 : TEMPORARY Record 23044535;
      lcuWMDMDataset@1000000015 : Codeunit 23044535;
      lrrefDocListRef@1000000016 : RecordRef;
      ldnOutput@1000000017 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder";
      lbOnlyAssignedDocs@1000000019 : Boolean;
      liDocCounter@1000000023 : Integer;
      lcodOptionalItem@1000000007 : Code[20];
      lbsOutput@1000000008 : BigText;
      WMDMSetup@1000000010 : Record 23044502;
    BEGIN
      // Returns the lookup lists.
      // Will generate entries for
      // Warehouse Receipts
      // Purchase Orders (not currently on whse. rcpts)
      // Transfer Orders (not currently on whse. rcpts)
      //
      // Note: filter will be what the user types in.
      //       if they scanned an item barcode it will be available in lcodOptionalItem
      //
      WMDMSetup.GET;
      ldnOutput := ldnOutput.StringBuilder();
      lcodUser := ptrecEventParams.getValue('user_name');
      lsFilter := ptrecEventParams.getValue('filter');
      cuWMDMCommon.getDeviceConfig( lrecPDAConfig,ptrecEventParams );

      //<DMS author="R.Trudeau" date="17/03/2016" issue="TFS1974">
      IF( lsFilter <> '' ) THEN BEGIN
        lsFilter := '*' + lsFilter + '*';
      END;
      //</DMS>



      lrrefDocListRef.GETTABLE( ltrecDocList  );
      //IF ( NOT lcuWMDMDataset.GetHasColumnsDefinedWithVer( iEventID, '', lrrefDocListRef.NUMBER, '1.5.1511') ) THEN BEGIN
        //cuWMDMSetup.configReceivingColumnsWithVer('1.5.1511');
      //END;

      lcodOptionalItem := ptrecEventParams.getItemNo();

      IF (( lcodUser<>'' ) AND ( NOT lrecPDAConfig."Show All Documents") )THEN BEGIN
        // We have a username *and* we've been asked not to show all documents
        lbOnlyAssignedDocs := TRUE;
      END ELSE BEGIN
        lbOnlyAssignedDocs := FALSE;
      END;

      // first search whse receipts
      // this will be the typical case is a receipt is printed and there is a barcode
      // or possibly user entered partial search
      searchWarehouseReceipts_bak(
        ltrecDocList,
        liDocCounter,
        lrecPDAConfig,
        lbOnlyAssignedDocs,
        lcodUser,
        lsFilter,
        lcodOptionalItem,
        '' );

      // look for purchase orders if no match yet
      IF( lsFilter = '' ) OR ( ltrecDocList.ISEMPTY ) THEN BEGIN
        // there is no filter (so show anything)
        // *or* there is a filter, and we haven't yet found something so keep looking.
        searchPurchaseOrders_bak(
          ltrecDocList,
          liDocCounter,
          lrecPDAConfig,
          lbOnlyAssignedDocs,
          lcodUser,
          lsFilter,
          lcodOptionalItem,
          '' );
      END;

      // look for transfer orders if no match yet
      IF( lsFilter = '' ) OR ( ltrecDocList.ISEMPTY ) THEN BEGIN
        // there is no filter (so show anything)
        // *or* there is a filter, and we haven't yet found something so keep looking.
        searchTransferOrders_bak(
          ltrecDocList,
          liDocCounter,
          lrecPDAConfig,
          lbOnlyAssignedDocs,
          lcodUser,
          lsFilter,
          lcodOptionalItem,
          '' );
      END;

      //<IW author="R.Letts" date="3/23/2017" issue="3580">
      // look for return orders if no match yet
      IF( lsFilter = '' ) OR ( ltrecDocList.ISEMPTY ) THEN BEGIN
        // there is no filter (so show anything)
        // *or* there is a filter, and we haven't yet found something so keep looking.
        searchSalesReturn_bak(
          ltrecDocList,
          liDocCounter,
          lrecPDAConfig,
          lbOnlyAssignedDocs,
          lcodUser,
          lsFilter,
          lcodOptionalItem,
          '' );

      //</IW>

      END;


      IF ( lrrefDocListRef.FINDFIRST() ) THEN;

      lcuWMDMDataset.BuildLinesOnlyDataset(
        iEventID,
        lrrefDocListRef,
        FALSE,
        ldnOutput);

      lbsOutput.ADDTEXT( ldnOutput.ToString() );

      sendStandardResult(lbsOutput, TRUE);
    END;

    PROCEDURE searchWarehouseReceipts_bak@1000000032(VAR ptrecDocList@1000000000 : Record 23044535;VAR piLineCounter@1000000001 : Integer;VAR precConfig@1000000002 : Record 23044504;pbOnlyAssignedDocs@1000000003 : Boolean;pcodUser@1000000004 : Code[50];ptxtFilter@1000000007 : Text;pcodOptionalItem@1000000010 : Code[20];pcodForceSource@1000000012 : Code[20]);
    VAR
      lrecRcvHeader@1000000005 : Record 7316;
      lbFoundDoc@1000000006 : Boolean;
      lbIncludeResult@1000000008 : Boolean;
      liMaxDocList@1000000009 : Integer;
      lrecWhseRcptLine@1000000011 : Record 7317;
      lcodTempSource@1000000013 : Code[20];
    BEGIN
      // get the warehouse receipts
      lrecRcvHeader.SETRANGE("Location Code", precConfig."Location Code");
      IF( ptxtFilter <> '' ) THEN BEGIN
        lrecRcvHeader.SETFILTER("No.", ptxtFilter);
      END;
      liMaxDocList := recWMDMSetup."Document Max List";

      // first warehouse receipts that match the name
      lbFoundDoc :=lrecRcvHeader.FINDSET(FALSE);
      IF ( NOT lbFoundDoc ) AND ( ptxtFilter <> '' ) THEN BEGIN
        // try ending with, this is slower, but allows them to type in a partial doc
        lrecRcvHeader.SETFILTER("No.",'*%1',ptxtFilter);
        lbFoundDoc :=lrecRcvHeader.FINDSET(FALSE);
      END;

      IF ( NOT lbFoundDoc ) THEN BEGIN
        // if we still haven't found a whse receipt, then look at the vendor shipment no.
        lrecRcvHeader.SETRANGE("No."); // clear previous filters.
        lrecRcvHeader.SETRANGE("Vendor Shipment No.", ptxtFilter );
        lbFoundDoc :=lrecRcvHeader.FINDSET(FALSE);
      END;

      IF ( NOT lbFoundDoc ) AND ( ptxtFilter <> '' ) AND ( pcodOptionalItem = '' ) THEN BEGIN
        // they might have just typed in an item
        // number, but not scanned it, and we haven't found anything with
        // that warehouse receipt...
        // so... try it as an item, but only after first trying
        // ptxt filter as a document reference.
        pcodOptionalItem := ptxtFilter;
      END;

      IF ( NOT lbFoundDoc ) AND  ( pcodOptionalItem <> '' ) THEN BEGIN
        // if the filter clearly isn't a document
        // search for whse receipt lines that might match as well
        // in this scenario, if we do find potentially matching lines
        // run it through this same function recursively, except swapping the filter wiht the document no.
        // This will do any other validations required (not fully received, assigned to user, etc... ).
        lrecWhseRcptLine.RESET();
        lrecWhseRcptLine.SETRANGE("Location Code",  precConfig."Location Code" );
        lrecWhseRcptLine.SETRANGE("Item No.", pcodOptionalItem );
        lrecWhseRcptLine.SETFILTER("Qty. Outstanding", '>0' );
        IF ( lrecWhseRcptLine.FINDSET(FALSE) ) THEN BEGIN
          REPEAT
            lcodTempSource := lrecWhseRcptLine."Source No.";
            IF ( lcodTempSource = '' ) THEN BEGIN
              lcodTempSource := pcodOptionalItem;
            END;
            searchWarehouseReceipts_bak(
              ptrecDocList,
              piLineCounter,
              precConfig,
              pbOnlyAssignedDocs,
              pcodUser,
              lrecWhseRcptLine."No.", // specifying the document as the example
              '', // force the item to be blank
              lcodTempSource // supply the forced source since we know it
               );
          UNTIL ( (lrecWhseRcptLine.NEXT() = 0) OR ( piLineCounter >= liMaxDocList ) );
        END;
      END; // if an optional item was supplied to purchase orders

      IF( lbFoundDoc ) THEN BEGIN
        REPEAT
          IF ( pbOnlyAssignedDocs) THEN BEGIN
            lbIncludeResult := ( STRPOS( lrecRcvHeader."Assigned User ID" , pcodUser ) > 0 );
          END ELSE BEGIN
            lbIncludeResult := TRUE;
          END;
          IF ( lbIncludeResult) THEN BEGIN
            ptrecDocList.INIT;
            piLineCounter += 1;
            ptrecDocList."Entry No." := piLineCounter;
            ptrecDocList."Source Table" := DATABASE::"Warehouse Receipt Header";

            //<DMS author="Howie Zhao" date="01/06/2016" issue="TFS2615" >
            lrecWhseRcptLine.RESET();
            lrecWhseRcptLine.SETRANGE("No.", lrecRcvHeader."No.");
            lrecWhseRcptLine.SETFILTER("Qty. Outstanding",'>%1', 0);
            IF ( lrecWhseRcptLine.FINDSET(FALSE) ) THEN BEGIN
              IF (precConfig."Use Source Doc. - Receiving" = precConfig."Use Source Doc. - Receiving"::Yes) THEN BEGIN
                ptrecDocList."Document No." := lrecWhseRcptLine."Source No.";
                ptrecDocList."Reference No." := lrecRcvHeader."No.";
              END ELSE BEGIN
                ptrecDocList."Document No." := lrecRcvHeader."No.";
                IF ( pcodForceSource <> '' ) THEN BEGIN
                  ptrecDocList."Reference No." := pcodForceSource;
                END ELSE BEGIN
                  ptrecDocList."Reference No." := lrecRcvHeader."Vendor Shipment No.";
                END;
              END;
            END;
            //</DMS>

            ptrecDocList."Assigned User ID" := lrecRcvHeader."Assigned User ID";
            ptrecDocList.Barcode := '%R%' + lrecRcvHeader."No.";
            ptrecDocList.INSERT;
          END;
        UNTIL ( (lrecRcvHeader.NEXT = 0) OR ( piLineCounter >= liMaxDocList ) );
      END; // if we found whse receipts to show.
    END;

    PROCEDURE searchPurchaseOrders_bak@1000000036(VAR ptrecDocList@1000000000 : Record 23044535;VAR piLineCounter@1000000001 : Integer;VAR precConfig@1000000002 : Record 23044504;pbOnlyAssignedDocs@1000000003 : Boolean;pcodUser@1000000004 : Code[50];ptxtFilter@1000000007 : Text;pcodOptionalItem@1000000010 : Code[20];pcodForceSource@1000000013 : Code[20]);
    VAR
      lrecPurchHeader@1000000005 : Record 38;
      lbFoundDoc@1000000006 : Boolean;
      lbIncludeResult@1000000008 : Boolean;
      liMaxDocList@1000000009 : Integer;
      lrecPurchLine@1000000011 : Record 39;
      lrecWhseRcptLine@1000000012 : Record 7317;
    BEGIN
      // search purchase orders
      // can be recursive *if* an item no. is supplied
      lrecPurchHeader.SETRANGE("Location Code", precConfig."Location Code");
      lrecPurchHeader.SETRANGE("Completely Received",FALSE);
      lrecPurchHeader.SETRANGE("Document Type", lrecPurchHeader."Document Type"::Order);
      lrecPurchHeader.SETRANGE(Status,lrecPurchHeader.Status::Released);

      IF( ptxtFilter <> '' ) THEN BEGIN
        lrecPurchHeader.SETFILTER("No.", ptxtFilter);
      END;
      liMaxDocList := recWMDMSetup."Document Max List";

      // first purchase ordres that match the name
      lbFoundDoc :=lrecPurchHeader.FINDSET(FALSE);
      IF ( NOT lbFoundDoc ) AND ( ptxtFilter <> '' ) THEN BEGIN
        // try ending with, this is slower, but allows them to type in a partial doc
        lrecPurchHeader.SETFILTER("No.",'*%1',ptxtFilter);
        lbFoundDoc :=lrecPurchHeader.FINDSET(FALSE);
      END;

      IF ( NOT lbFoundDoc ) THEN BEGIN
        // if we still haven't found a whse receipt, then look at the vendor shipment no.
        lrecPurchHeader.SETRANGE("No."); // clear previous filters.
        lrecPurchHeader.SETRANGE("Vendor Shipment No.", ptxtFilter );
        lbFoundDoc :=lrecPurchHeader.FINDSET(FALSE);
      END;

      IF ( NOT lbFoundDoc ) AND ( ptxtFilter <> '' ) AND ( pcodOptionalItem = '' ) THEN BEGIN
        // they might have just typed in an item
        // number, but not scanned it, and we haven't found anything with
        // that purchase order...
        // so... try it as an item, but only after first trying
        // ptxt filter as a document reference.
        pcodOptionalItem := ptxtFilter;
      END;


      IF ( NOT lbFoundDoc ) AND  ( pcodOptionalItem <> '' ) THEN BEGIN
        // if the filter clearly isn't a document
        // search for purchase lines that might match as well
        // in this scenario, if we do find potentially matching lines
        // run it through this same function recursively, except swapping the filter wiht the document no.
        // This will do any other validations required (not fully received, assigned to user, etc... ).
        lrecPurchLine.RESET();
        lrecPurchLine.SETRANGE("Location Code",  precConfig."Location Code" );
        lrecPurchLine.SETRANGE(Type, lrecPurchLine.Type::Item );
        lrecPurchLine.SETRANGE("No.", pcodOptionalItem );
        lrecPurchLine.SETFILTER("Outstanding Quantity", '>0' );
        IF ( lrecPurchLine.FINDSET(FALSE) ) THEN BEGIN
          REPEAT
            searchPurchaseOrders_bak(
              ptrecDocList,
              piLineCounter,
              precConfig,
              pbOnlyAssignedDocs,
              pcodUser,
              lrecPurchLine."Document No.", // specifying the document as the example
              '', // force the item to be blank.
              pcodOptionalItem // use the item number as the source.
               );
          UNTIL ( (lrecPurchLine.NEXT() = 0) OR ( piLineCounter >= liMaxDocList ) );
        END;
      END; // if an optional item was supplied to purchase orders

      IF( lbFoundDoc ) THEN BEGIN
        REPEAT
          IF ( pbOnlyAssignedDocs) THEN BEGIN
            lbIncludeResult := ( STRPOS( lrecPurchHeader."Assigned User ID" , pcodUser ) > 0 );
          END ELSE BEGIN
            lbIncludeResult := TRUE;
          END;
          //<TPZ1775> Allow to receive with PO # when warehouse receipt already been created.
          {
          IF ( lbIncludeResult ) THEN BEGIN
            lrecWhseRcptLine.RESET();
            lrecWhseRcptLine.SETRANGE("Source Type", DATABASE::"Purchase Line" );
            lrecWhseRcptLine.SETRANGE("Source Subtype", 1);
            lrecWhseRcptLine.SETRANGE("Source No.",  lrecPurchHeader."No." );
            lbIncludeResult := NOT lrecWhseRcptLine.FINDFIRST();
          END;
          }
          //</TPZ1775>

          // check to make sure there is 1 line at least still valid
          // if you don't do this check you can get 'g/l lines' that fit the bill
          // but cannot be converted to receipts or opened
          IF( lbIncludeResult ) THEN BEGIN
            lrecPurchLine.RESET();
            lrecPurchLine.SETRANGE("Document Type",lrecPurchHeader."Document Type");
            lrecPurchLine.SETRANGE("Document No.",lrecPurchHeader."No.");
            lrecPurchLine.SETRANGE("Location Code",  precConfig."Location Code" );
            lrecPurchLine.SETRANGE(Type, lrecPurchLine.Type::Item );
            lrecPurchLine.SETFILTER("Outstanding Quantity", '>0' );
            lbIncludeResult := lrecPurchLine.FINDFIRST;
          END;

          IF ( lbIncludeResult) THEN BEGIN
            ptrecDocList.INIT;
            piLineCounter += 1;
            ptrecDocList."Entry No." := piLineCounter;
            ptrecDocList."Document No." := lrecPurchHeader."No.";
            ptrecDocList."Source Table" := DATABASE::"Purchase Header";
            IF ( pcodForceSource <> '' ) THEN BEGIN
              ptrecDocList."Reference No." := pcodForceSource;
            END ELSE BEGIN
              ptrecDocList."Reference No." := lrecPurchHeader."Vendor Shipment No.";
            END;
            ptrecDocList."Assigned User ID" := lrecPurchHeader."Assigned User ID";
            ptrecDocList.Barcode := '%PO%' + lrecPurchHeader."No.";
            ptrecDocList.INSERT;
          END;
        UNTIL ( (lrecPurchHeader.NEXT() = 0) OR ( piLineCounter >= liMaxDocList ) );
      END; // if we found purchase orders to show.
    END;

    PROCEDURE searchTransferOrders_bak@1000000038(VAR ptrecDocList@1000000000 : Record 23044535;VAR piLineCounter@1000000001 : Integer;VAR precConfig@1000000002 : Record 23044504;pbOnlyAssignedDocs@1000000003 : Boolean;pcodUser@1000000004 : Code[50];ptxtFilter@1000000007 : Text;pcodOptionalItem@1000000011 : Code[20];pcodForceSource@1000000012 : Code[20]);
    VAR
      lrecTransHeader@1000000005 : Record 5740;
      lbFoundDoc@1000000006 : Boolean;
      lbIncludeResult@1000000008 : Boolean;
      liMaxDocList@1000000009 : Integer;
      lrecTransLine@1000000010 : Record 5741;
    BEGIN
      // search transfer orders

      lrecTransHeader.SETRANGE("Transfer-to Code",precConfig."Location Code");
      lrecTransHeader.SETRANGE("Completely Received",FALSE);
      lrecTransHeader.SETRANGE(Status,lrecTransHeader.Status::Released);
      IF( ptxtFilter <> '' ) THEN BEGIN
        lrecTransHeader.SETFILTER("No.",ptxtFilter);
      END;

      liMaxDocList := recWMDMSetup."Document Max List";

      // first purchase ordres that match the name
      lbFoundDoc :=lrecTransHeader.FINDSET(FALSE);
      IF ( NOT lbFoundDoc ) AND ( ptxtFilter <> '' ) THEN BEGIN
        // try ending with, this is slower, but allows them to type in a partial doc
        lrecTransHeader.SETFILTER("No.",'*%1',ptxtFilter);
        lbFoundDoc :=lrecTransHeader.FINDSET(FALSE);
      END;

      IF ( NOT lbFoundDoc ) THEN BEGIN
        // if we still haven't found a transfer then look at the external doc
        lrecTransHeader.SETRANGE("No."); // clear previous filters.
        lrecTransHeader.SETRANGE("External Document No.", ptxtFilter );
        lbFoundDoc :=lrecTransHeader.FINDSET(FALSE);
      END;

      IF ( NOT lbFoundDoc ) AND  ( pcodOptionalItem <> '' ) THEN BEGIN
        // if the filter clearly isn't a document
        // search for purchase lines that might match as well
        // in this scenario, if we do find potentially matching lines
        // run it through this same function recursively, except swapping the filter wiht the document no.
        // This will do any other validations required (not fully received, assigned to user, etc... ).
        lrecTransLine.RESET();
        lrecTransLine.SETRANGE("Transfer-to Code",  precConfig."Location Code" );
        lrecTransLine.SETRANGE("Item No.", pcodOptionalItem );
        lrecTransLine.SETFILTER("Outstanding Quantity", '>0' );
        IF ( lrecTransLine.FIND('-') ) THEN BEGIN
          REPEAT
            searchTransferOrders_bak(
              ptrecDocList,
              piLineCounter,
              precConfig,
              pbOnlyAssignedDocs,
              pcodUser,
              lrecTransLine."Document No.", // specifying the document as the example
              '', // force the item to be blank.
              pcodOptionalItem // make the optional item the source
               );
          UNTIL ( (lrecTransLine.NEXT() = 0) OR ( piLineCounter >= liMaxDocList ) );
        END;
      END; // if an optional item was supplied to purchase orders



      IF( lbFoundDoc ) THEN BEGIN
        REPEAT
          IF ( pbOnlyAssignedDocs) THEN BEGIN
            lbIncludeResult := ( STRPOS( lrecTransHeader."Assigned User ID" , pcodUser ) > 0 );
          END ELSE BEGIN
            lbIncludeResult := TRUE;
          END;
          IF ( lbIncludeResult) THEN BEGIN
            ptrecDocList.INIT;
            piLineCounter += 1;
            ptrecDocList."Entry No." := piLineCounter;
            ptrecDocList."Document No." := lrecTransHeader."No.";
            ptrecDocList."Source Table" := DATABASE::"Transfer Header";
            IF ( pcodForceSource <> '' ) THEN BEGIN
              ptrecDocList."Reference No." := pcodForceSource;
            END ELSE BEGIN
              ptrecDocList."Reference No." := lrecTransHeader."External Document No.";
            END;
            ptrecDocList."Assigned User ID" := lrecTransHeader."Assigned User ID";
            ptrecDocList.Barcode := '%T%' + lrecTransHeader."No.";

            ptrecDocList.INSERT;
          END;
        UNTIL ( (lrecTransHeader.NEXT = 0) OR ( piLineCounter >= liMaxDocList ) );
      END; // if we found transfer orders to show.
    END;

    PROCEDURE searchSalesReturn_bak@1000000012(VAR ptrecDocList@1000000000 : Record 23044535;VAR piLineCounter@1000000001 : Integer;VAR precConfig@1000000002 : Record 23044504;pbOnlyAssignedDocs@1000000003 : Boolean;pcodUser@1000000004 : Code[50];ptxtFilter@1000000007 : Text;pcodOptionalItem@1000000010 : Code[20];pcodForceSource@1000000013 : Code[20]);
    VAR
      lrecSalesHeader@1000000005 : Record 36;
      lbFoundDoc@1000000006 : Boolean;
      lbIncludeResult@1000000008 : Boolean;
      liMaxDocList@1000000009 : Integer;
      lrecSalesLine@1000000011 : Record 37;
      lrecWhseRcptLine@1000000012 : Record 7317;
    BEGIN
      //<FUNC author="R.Letts" date="3/23/17" issue="3580">
      //  Description: copy of the searchSalesOrder function converted to work with retun orders
      //  Called From: getDocumentList
      //  Side Effect:
      //</FUNC>

      // search sales returns
      // can be recursive *if* an item no. is supplied
      lrecSalesHeader.SETRANGE("Location Code", precConfig."Location Code");
      lrecSalesHeader.SETRANGE("Document Type", lrecSalesHeader."Document Type"::"Return Order");
      lrecSalesHeader.SETRANGE(Status,lrecSalesHeader.Status::Released);

      IF( ptxtFilter <> '' ) THEN BEGIN
        lrecSalesHeader.SETFILTER("No.", ptxtFilter);
      END;
      liMaxDocList := recWMDMSetup."Document Max List";

      // first purchase ordres that match the name
      lbFoundDoc :=lrecSalesHeader.FINDSET(FALSE);
      IF ( NOT lbFoundDoc ) AND ( ptxtFilter <> '' ) THEN BEGIN
        // try ending with, this is slower, but allows them to type in a partial doc
        lrecSalesHeader.SETFILTER("No.",'*%1',ptxtFilter);
        lbFoundDoc :=lrecSalesHeader.FINDSET(FALSE);
      END;


      IF ( NOT lbFoundDoc ) AND ( ptxtFilter <> '' ) AND ( pcodOptionalItem = '' ) THEN BEGIN
        // they might have just typed in an item
        // number, but not scanned it, and we haven't found anything with
        // that purchase order...
        // so... try it as an item, but only after first trying
        // ptxt filter as a document reference.
        pcodOptionalItem := ptxtFilter;
      END;


      IF ( NOT lbFoundDoc ) AND  ( pcodOptionalItem <> '' ) THEN BEGIN
        // if the filter clearly isn't a document
        // search for purchase lines that might match as well
        // in this scenario, if we do find potentially matching lines
        // run it through this same function recursively, except swapping the filter wiht the document no.
        // This will do any other validations required (not fully received, assigned to user, etc... ).
        lrecSalesLine.RESET();
        lrecSalesLine.SETRANGE("Location Code",  precConfig."Location Code" );
        lrecSalesLine.SETRANGE(Type, lrecSalesLine.Type::Item );
        lrecSalesLine.SETRANGE("No.", pcodOptionalItem );
        lrecSalesLine.SETFILTER("Outstanding Quantity", '>0' );
        IF ( lrecSalesLine.FINDSET(FALSE) ) THEN BEGIN
          REPEAT
            {searchSalesRetrun(
              ptrecDocList,
              piLineCounter,
              precConfig,
              pbOnlyAssignedDocs,
              pcodUser,
              lrecSalesLine."Document No.", // specifying the document as the example
              '', // force the item to be blank.
              pcodOptionalItem // use the item number as the source.
               );
               }
          UNTIL ( (lrecSalesLine.NEXT() = 0) OR ( piLineCounter >= liMaxDocList ) );
        END;
      END; // if an optional item was supplied to purchase orders

      IF( lbFoundDoc ) THEN BEGIN
        REPEAT
          IF ( pbOnlyAssignedDocs) THEN BEGIN
            lbIncludeResult := ( STRPOS( lrecSalesHeader."Assigned User ID" , pcodUser ) > 0 );
          END ELSE BEGIN
            lbIncludeResult := TRUE;
          END;
          //<TPZ1775> Allow to receive with PO # when warehouse receipt already been created.
          {
          IF ( lbIncludeResult ) THEN BEGIN
            lrecWhseRcptLine.RESET();
            lrecWhseRcptLine.SETRANGE("Source Type", DATABASE::"Purchase Line" );
            lrecWhseRcptLine.SETRANGE("Source Subtype", 1);
            lrecWhseRcptLine.SETRANGE("Source No.",  lrecPurchHeader."No." );
            lbIncludeResult := NOT lrecWhseRcptLine.FINDFIRST();
          END;
          }
          //</TPZ1775>

          // check to make sure there is 1 line at least still valid
          // if you don't do this check you can get 'g/l lines' that fit the bill
          // but cannot be converted to receipts or opened
          IF( lbIncludeResult ) THEN BEGIN
            lrecSalesLine.RESET();
            lrecSalesLine.SETRANGE("Document Type",lrecSalesHeader."Document Type");
            lrecSalesLine.SETRANGE("Document No.",lrecSalesHeader."No.");
            lrecSalesLine.SETRANGE("Location Code",  precConfig."Location Code" );
            lrecSalesLine.SETRANGE(Type, lrecSalesLine.Type::Item );
            lrecSalesLine.SETFILTER("Outstanding Quantity", '>0' );
            lbIncludeResult := lrecSalesLine.FINDFIRST;
          END;

          IF ( lbIncludeResult) THEN BEGIN
            ptrecDocList.INIT;
            piLineCounter += 1;
            ptrecDocList."Entry No." := piLineCounter;
            ptrecDocList."Document No." := lrecSalesHeader."No.";
            ptrecDocList."Source Table" := DATABASE::"Sales Header";
            IF ( pcodForceSource <> '' ) THEN BEGIN
              ptrecDocList."Reference No." := pcodForceSource;
            END ELSE BEGIN
              ptrecDocList."Reference No." := '';
            END;
            ptrecDocList."Assigned User ID" := lrecSalesHeader."Assigned User ID";
            ptrecDocList.Barcode := '%SO%' + lrecSalesHeader."No.";
            ptrecDocList.INSERT;
          END;
        UNTIL ( (lrecSalesHeader.NEXT() = 0) OR ( piLineCounter >= liMaxDocList ) );
      END; // if we found Sales returns to show.
    END;

    PROCEDURE onGetReceivingDocumentList@1000000008();
    VAR
      lcodUser@1000000010 : Code[50];
      lsFilter@1000000009 : Text[250];
      lrecPDAConfig@1000000008 : Record 23044504;
      ltrecDocList@1000000007 : TEMPORARY Record 23044535;
      lcuWMDMDataset@1000000006 : Codeunit 23044535;
      lrrefDocListRef@1000000005 : RecordRef;
      ldnOutput@1000000004 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.StringBuilder";
      liDocCounter@1000000003 : Integer;
      lcodOptionalItem@1000000002 : Code[20];
      lbOnlyAssignedDocs@1000000001 : Boolean;
      liMaxDocList@1000000000 : Integer;
      lbsOutput@1000000012 : BigText;
    BEGIN
      //<FUNC author="R.Trudeau" date="10/10/17" issue="3580">
      //  Description: Override of receiving lookup to include sales return orders.
      //  Called From: onBeforeProcessEvent
      //  Side Effect: None
      //</FUNC>


      ldnOutput := ldnOutput.StringBuilder();
      lcodUser := trecEventParams.getValue('user_name');
      lsFilter := trecEventParams.getValue('filter');
      lcodOptionalItem := trecEventParams.getItemNo();

      //-->TPZ2781 PSHUKLA
      IF UPPERCASE(lsFilter) = 'STOP' THEN BEGIN
        ptrecEventParamsTest := trecEventParams;
        ptrecEventParamsTest."Event" := 99001;
        LicensePlateMgmt.updatePausePicking(ptrecEventParamsTest,lbsOutput);
        COMMIT;
        ERROR('Receiving Stopped')
      END;
      //<--
      //>>001 TPZ2886
      IF UPPERCASE(lsFilter) = 'START' THEN BEGIN
        ptrecEventParamsTest := trecEventParams;
        ptrecEventParamsTest."Event" := 99004;
        LicensePlateMgmt.updatePausePicking(ptrecEventParamsTest,lbsOutput);
        COMMIT;
        ERROR('Receiving Started')
      END;
      //<<001 TPZ2886
      IF( lsFilter <> '' ) THEN BEGIN
        lsFilter := '*' + lsFilter + '*';
      END;

      IF( lcodOptionalItem <> '' ) THEN
        lsFilter := '';

      cuWMDMCommon.getDeviceConfig(lrecPDAConfig,trecEventParams);

      lbOnlyAssignedDocs := ( lcodUser<>'' ) AND ( NOT lrecPDAConfig."Show All Documents");

      recWMDMSetup.GET;
      liMaxDocList := recWMDMSetup."Document Max List";
      IF liMaxDocList = 0 THEN
        liMaxDocList := 999999;


      cuRcptMgmt.searchWhseReceipts(
        ltrecDocList,
        liDocCounter,
        lrecPDAConfig,
        lbOnlyAssignedDocs,
        lcodUser,
        lsFilter,
        liMaxDocList,
        lcodOptionalItem
        );

      cuRcptMgmt.searchPurchaseOrders(
          ltrecDocList,
          liDocCounter,
          lrecPDAConfig,
          lbOnlyAssignedDocs,
          lcodUser,
          lsFilter,
          liMaxDocList,
          lcodOptionalItem
          );

      cuRcptMgmt.searchTransferOrders(
          ltrecDocList,
          liDocCounter,
          lrecPDAConfig,
          lbOnlyAssignedDocs,
          lcodUser,
          lsFilter,
          liMaxDocList,
          lcodOptionalItem
          );

      searchSalesReturnOrders(
          ltrecDocList,
          liDocCounter,
          lrecPDAConfig,
          lbOnlyAssignedDocs,
          lcodUser,
          lsFilter,
          liMaxDocList,
          lcodOptionalItem
      );


      ltrecDocList.RESET;
      lrrefDocListRef.GETTABLE( ltrecDocList  );
      IF ( lrrefDocListRef.FINDFIRST() ) THEN;


      lcuWMDMDataset.BuildLinesOnlyDataset(
        iEventID,
        lrrefDocListRef,
        FALSE,
        ldnOutput);

      lbsOutput.ADDTEXT( ldnOutput.ToString() );

      cuWMDMActivityLogMgt.logActivity(trecEventParams);
      sendStandardResult(lbsOutput,TRUE);
    END;

    PROCEDURE searchSalesReturnOrders@1000000011(VAR ptrecDocList@1000000000 : Record 23044535;VAR piLineCounter@1000000001 : Integer;VAR precConfig@1000000002 : Record 23044504;pbOnlyAssignedDocs@1000000003 : Boolean;pcodUser@1000000004 : Code[50];ptxtFilter@1000000007 : Text;piMaxDocCount@1000000013 : Integer;pcodItemNumber@1000000010 : Text);
    VAR
      lrecSalesHeader@1000000005 : Record 36;
      lrecSalesLine@1000000012 : Record 37;
      lrecSalesHeaderTemp@1000000011 : Record 36;
      lrecLocation@1000000014 : Record 14;
      lbIncludeResult@1000000008 : Boolean;
    BEGIN
      //<FUNC author="R.Trudeau" date="10/10/17" issue="3580">
      //  Description: Builds up a list of sales return orders for the lookup list
      //  Called From: onGetReceivingDocumentList
      //  Side Effect: None
      //</FUNC>

      lrecLocation.GET(precConfig."Location Code");

      lrecSalesHeader.SETFILTER("Location Code",'%1|%2','',precConfig."Location Code");
      lrecSalesHeader.SETRANGE("Completely Shipped",FALSE);
      lrecSalesHeader.SETRANGE("Document Type", lrecSalesHeader."Document Type"::"Return Order");

      IF( pbOnlyAssignedDocs ) THEN
        lrecSalesHeader.SETFILTER("Assigned User ID",'%1|%2','','*'+ pcodUser);

      IF( precConfig."Only Show Released Receipts" = precConfig."Only Show Released Receipts"::Yes ) THEN
          lrecSalesHeader.SETRANGE(Status,lrecSalesHeader.Status::Released);

      IF( lrecSalesHeader.FINDSET(FALSE) ) THEN BEGIN
        REPEAT
          lbIncludeResult := (ptxtFilter = '');

          // check the purchase lines
          lrecSalesLine.RESET;
          lrecSalesLine.SETRANGE("Document Type",lrecSalesHeader."Document Type");
          lrecSalesLine.SETRANGE("Document No.",lrecSalesHeader."No.");
          lrecSalesLine.SETRANGE("Location Code",precConfig."Location Code");
          lrecSalesLine.SETRANGE("Completely Shipped",FALSE);
          lrecSalesLine.SETRANGE(Type,lrecSalesLine.Type::Item);
          lrecSalesLine.SETFILTER("No.",'<>%1','');

          IF( pcodItemNumber <> '' ) THEN
            lrecSalesLine.SETRANGE("No.",pcodItemNumber);

          lrecSalesHeaderTemp.RESET;
          lrecSalesHeaderTemp.SETRANGE("Document Type",lrecSalesHeader."Document Type");

          IF( lrecSalesLine.FINDSET(FALSE) ) THEN BEGIN
            REPEAT
              IF( ptxtFilter <> '' ) THEN BEGIN
                // check the purchase order number
                lrecSalesHeaderTemp.SETFILTER("No.",ptxtFilter);
                IF lrecSalesHeaderTemp.FINDSET(FALSE) THEN BEGIN
                  REPEAT
                    lbIncludeResult := lrecSalesHeaderTemp."No." = lrecSalesHeader."No.";
                  UNTIL( (lrecSalesHeaderTemp.NEXT=0) OR lbIncludeResult);
                END;

                // check the vendor shipment number
                //IF( NOT lbIncludeResult ) THEN BEGIN
                //  lrecSalesHeaderTemp.SETRANGE("No.", lrecSalesHeader."No.");
                //  lrecSalesHeaderTemp.SETFILTER("Vendor Shipment No.",ptxtFilter);
                //  lbIncludeResult := lrecSalesHeaderTemp.FINDFIRST;
                //END;

                // check the source number (whse. receipts only)
              END;

              IF( lbIncludeResult AND lrecLocation."Require Receive" ) THEN BEGIN
                // make sure not already filled on a warehouse receipt
                lbIncludeResult := cuRcptMgmt.canCreateReceipt(
                  DATABASE::"Purchase Line",
                  lrecSalesLine."Document Type",
                  lrecSalesLine."Document No.",
                  lrecSalesLine."Line No.",
                  lrecSalesLine."Quantity (Base)" - lrecSalesLine."Return Qty. Received (Base)"
                );
              END;

              IF( lbIncludeResult ) THEN BEGIN
                cuRcptMgmt.addDocumentToList(
                  ptrecDocList,
                  piLineCounter,
                  FALSE,                                    // use source document
                  lrecSalesLine."Document No.",             // document no
                  '',                                       // source no
                  DATABASE::"Sales Header",              // source table
                  '',//lrecSalesHeader."Vendor Shipment No.",    // reference no
                  lrecSalesHeader."Assigned User ID",       // assigned user
                  lrecSalesHeader."Due Date",               // due date
                  '',                                       // whse document #
                  lrecSalesHeader."Sell-to Customer Name",  // custom text 1
                  '%SO%' + lrecSalesLine."Document No.",     // barcode
                  0,
                  '',
                  0
                );
              END;
            UNTIL((lrecSalesLine.NEXT=0) OR (piLineCounter >= piMaxDocCount));
          END;
        UNTIL((lrecSalesHeader.NEXT=0) OR (piLineCounter >= piMaxDocCount))
      END;
    END;

    PROCEDURE getItemCommentsForPick@1000000000();
    VAR
      lrecLocation@1000000010 : Record 14;
      lcodLocation@1000000009 : Code[10];
      lcodActivityNo@1000000008 : Code[20];
      liActivityType@1000000007 : Integer;
      liLineNumber@1000000006 : Integer;
      lcodBinCode@1000000005 : Code[20];
      lrecWhseActivityLine@1000000004 : Record 5767;
      ltxtLineNumber@1000000003 : Text[50];
      ltxtActivityType@1000000002 : Text[50];
      lrecBin@1000000001 : Record 7354;
      lcodPreviousBin@1000000000 : Code[20];
      lbsOutput@1000000011 : BigText;
      lrecComments@1000000012 : Record 97;
    BEGIN
      //<IW author="R.Letts" date="12/12/18" version="IW18.12" issue="4550">
      lcodLocation := trecEventParams.getValue('location');
      lcodBinCode := trecEventParams.getValue('bin');
      lcodActivityNo := trecEventParams.getDocumentNo();
      ltxtActivityType := trecEventParams.getValue('document_type');
      IF(ltxtActivityType = '') THEN BEGIN
        ltxtActivityType := trecEventParams.getValue('Type');
      END;

      EVALUATE(liActivityType, ltxtActivityType);

      ltxtLineNumber := trecEventParams.getValue('Line No.');
      EVALUATE( liLineNumber, ltxtLineNumber);

      lrecWhseActivityLine.GET(liActivityType,lcodActivityNo,liLineNumber);

      lrecComments.SETRANGE("No.", lrecWhseActivityLine."Item No.");
      lrecComments.SETRANGE("Table Name", lrecComments."Table Name"::Item);
      lrecComments.SETRANGE("Print on Pick Ticket", TRUE);
      IF(lrecComments.FINDFIRST) THEN BEGIN
        REPEAT
          cuWMDMCommon.addMessage(lrecComments.Comment, lbsOutput);
        UNTIL(lrecComments.NEXT = 0);
        sendStandardResult(lbsOutput,TRUE);

      END ELSE BEGIN
        sendSuccessResult('No Comments for pick for item ' + lrecWhseActivityLine."Item No.", TRUE);
      END;
      //</IW>
    END;

    PROCEDURE getPartData@1000000004();
    VAR
      lcodLocation@1000000000 : Code[10];
      lcodItemNumber@1000000001 : Text;
      lcodVariantCode@1000000004 : Text;
      lcodLotNumber@1000000003 : Code[20];
      lcodSerialNumber@1000000002 : Code[20];
      lbsOutput@1000000006 : BigText;
      lrecItem@1000000028 : Record 27;
      lrecBinContents@1000000027 : Record 7302;
      ldQuantity@1000000026 : Decimal;
      lrecSKU@1000000025 : Record 5700;
      lrecReservationEntry@1000000024 : Record 337;
      lrecReservationEntry2@1000000023 : Record 337;
      lrecItemLedgerEntry@1000000022 : Record 32;
      iTransType@1000000021 : Integer;
      lcodShelfNo@1000000020 : Code[10];
      lnNumTrans@1000000019 : Integer;
      lrrefWriter@1000000018 : RecordRef;
      lcodDocNo@1000000017 : Code[30];
      lrecWMDMSetup@1000000016 : Record 23044502;
      ltrecBinContents@1000000015 : TEMPORARY Record 7302;
      lcuWMDMDoc@1000000014 : Codeunit 23044529;
      lrrefOutFoundRecord@1000000013 : RecordRef;
      lrecOutSearchRule@1000000012 : Record 23044529;
      liLineNo@1000000011 : Integer;
      liTotalFieldCount@1000000010 : Integer;
      lfFieldRef@1000000009 : FieldRef;
      liFieldIndex@1000000008 : Integer;
      lbFoundUOMField@1000000007 : Boolean;
      lrecItem2@1000000005 : Record 27;
    BEGIN
      // Event 10001
      lcodLocation := trecEventParams.getValue('location');
      lcodItemNumber := trecEventParams.getItemNo();
      lcodVariantCode := trecEventParams.getVariant();
      lcodLotNumber := trecEventParams.getLotNo();
      lcodSerialNumber := trecEventParams.getSerialNo();
      lrecWMDMSetup.GET();

      lbsOutput.ADDTEXT('<DATASET>');

      lrecItem.GET(lcodItemNumber);
      lrecItem.SETFILTER("Location Filter", lcodLocation);
      lrecItem.SETFILTER("Variant Filter",lcodVariantCode);
      IF (lcodLotNumber <> '') THEN BEGIN
        lrecItem.SETFILTER("Lot No. Filter", lcodLotNumber);
      END;
      IF (lcodSerialNumber <> '') THEN BEGIN
        lrecItem.SETFILTER("Serial No. Filter", lcodSerialNumber);
      END;
      lrecItem.CALCFIELDS(Inventory);

      IF( lrecSKU.GET(lcodLocation,lcodItemNumber,lcodVariantCode) ) THEN
        lcodShelfNo := lrecSKU."Shelf No."
      ELSE
        lcodShelfNo := lrecItem."Shelf No.";

      lbsOutput.ADDTEXT('<TABLE id="item">');

      lbsOutput.ADDTEXT('<COLS>');

      cuWMDMCommon.initializeColumns( TRUE );
      cuWMDMCommon.addDSColumnsFromConfig( lbsOutput,iEventID,'', DATABASE::Item );

      cuWMDMCommon.addDSTrackingColumns(lbsOutput);
      lbsOutput.ADDTEXT('</COLS>');

      lbsOutput.ADDTEXT('<ROWS>');
      lbsOutput.ADDTEXT('<R><FIELDS>');

      lrecItem2.GET(lcodItemNumber);
      lrecItem2.SETFILTER("Location Filter",lcodLocation);
      lrecItem2.CALCFIELDS(Inventory);
      cuWMDMCommon.setDSFieldOverrideValue(iEventID,'',DATABASE::Item,-1,FORMAT(lrecItem2.Inventory));
      IF( (lcodLotNumber <> '') OR (lcodSerialNumber <> '')) THEN BEGIN
        lrecItem2.SETFILTER("Lot No. Filter",lcodLotNumber);
        lrecItem2.SETFILTER("Serial No. Filter",lcodSerialNumber);
        lrecItem2.CALCFIELDS(Inventory);
        cuWMDMCommon.setDSFieldOverrideValue(iEventID,'',DATABASE::Item,-2,FORMAT(lrecItem2.Inventory));
      END;

      lrrefWriter.GETTABLE( lrecItem );
      cuWMDMCommon.addDSFieldsForRecord(lbsOutput,lrrefWriter,iEventID,'');



      cuWMDMCommon.addDSTrackingFields(lbsOutput,lrecItem."Item Tracking Code");

      lbsOutput.ADDTEXT('</FIELDS></R>');
      lbsOutput.ADDTEXT('</ROWS>');
      lbsOutput.ADDTEXT('</TABLE>');


      //
      // create the Bin table
      //
      lrecBinContents.SETRANGE("Location Code",lcodLocation);
      lrecBinContents.SETRANGE("Item No.",lcodItemNumber);

      IF( lcodVariantCode <> '' ) THEN
        lrecBinContents.SETRANGE("Variant Code",lcodVariantCode);

      lbsOutput.ADDTEXT('<TABLE id="bins">');

      // generate the dataset columns
      lbsOutput.ADDTEXT('<COLS>');
      cuWMDMCommon.initializeColumns( TRUE );
      cuWMDMCommon.addDSColumnsFromConfig( lbsOutput,iEventID,'', DATABASE::"Bin Content" );
      lbsOutput.ADDTEXT('</COLS>');

      lbsOutput.ADDTEXT('<ROWS>');

      IF( lrecBinContents.FINDSET(FALSE) ) THEN BEGIN
        REPEAT
          //<IW author="Howie Zhao" date="07/08/16" issue="TFS2647" >
          ltrecBinContents := lrecBinContents;
          ltrecBinContents.Quantity := lrecBinContents.CalcQtyUOM();
          IF (ltrecBinContents.Quantity > 0) THEN BEGIN
            lbsOutput.ADDTEXT('<R><FIELDS>');
            lrrefWriter.GETTABLE( ltrecBinContents );
            cuWMDMCommon.setDSFieldOverrideValue(iEventID, '', DATABASE::"Bin Content", -1, FORMAT(ltrecBinContents.Quantity));
            cuWMDMCommon.addDSFieldsForRecord(lbsOutput,lrrefWriter,iEventID,'');
            lbsOutput.ADDTEXT('</FIELDS></R>');
          END;
        UNTIL( lrecBinContents.NEXT = 0 );
      END;
      lbsOutput.ADDTEXT('</ROWS>');
      lbsOutput.ADDTEXT('</TABLE>');

      //
      // Create the Transaction table
      //
      lbsOutput.ADDTEXT('<TABLE id="transactions">');

      // generate the dataset columns
      lbsOutput.ADDTEXT('<COLS>');
      cuWMDMCommon.initializeColumns( TRUE );
      cuWMDMCommon.addDSColumnsFromConfig( lbsOutput,iEventID,'', DATABASE::"Reservation Entry" );
      lbsOutput.ADDTEXT('</COLS>');

      // generate the rows
      lbsOutput.ADDTEXT('<ROWS>');
      BEGIN
        //
        // find any current reservations for this part and include those
        //
        lrecReservationEntry.ASCENDING(FALSE);
        IF ( lcodSerialNumber <> '' ) THEN
          lrecReservationEntry.SETRANGE("Serial No.",lcodSerialNumber);

        IF ( lcodLotNumber <> '' ) THEN
          lrecReservationEntry.SETRANGE("Lot No.",lcodLotNumber);

        lrecReservationEntry.SETRANGE("Item No.",lcodItemNumber);

        IF( lcodVariantCode <> '' ) THEN
          lrecReservationEntry.SETRANGE("Variant Code",lcodVariantCode);

        lnNumTrans := 0;
        lrecReservationEntry.SETFILTER("Source Type",'<>%1',DATABASE::"Item Ledger Entry" );
        {{// 2009::begin
        IF( lrecReservationEntry.FIND('-') ) THEN BEGIN // '-' to use ASCENDING(FALSE)
        }}// 2009::end
        // 2013::begin
        IF( lrecReservationEntry.FINDSET(FALSE,FALSE) ) THEN BEGIN // '-' to use ASCENDING(FALSE)
        // 2013::end
          REPEAT
            IF( lrecReservationEntry."Source Type" <> DATABASE::"Item Ledger Entry" ) THEN BEGIN
              lbsOutput.ADDTEXT('<R><FIELDS>');
              cuWMDMCommon.initVariantColumnIndex();
              lcodDocNo := '';
              IF(lrecReservationEntry."Source ID" = '' ) THEN BEGIN
                lrecReservationEntry2.SETRANGE("Entry No.", lrecReservationEntry."Entry No.");
                lrecReservationEntry2.SETRANGE(Positive,FALSE);
                IF( lrecReservationEntry2.FINDFIRST ) THEN BEGIN
                  lcodDocNo := lrecReservationEntry2."Source ID";
                  IF ((lrecReservationEntry2."Source Type" = DATABASE::"Transfer Line") OR (lrecReservationEntry2."Source Type" = DATABASE::"Prod. Order Component")) THEN BEGIN
                    liLineNo := lrecReservationEntry2."Source Prod. Order Line";
                  END ELSE BEGIN
                    liLineNo := lrecReservationEntry2."Source Ref. No.";
                  END;
                END ELSE BEGIN
                  lcodDocNo := lrecReservationEntry."Source ID";
                  IF ((lrecReservationEntry."Source Type" = DATABASE::"Transfer Line") OR (lrecReservationEntry."Source Type" = DATABASE::"Prod. Order Component")) THEN BEGIN
                    liLineNo := lrecReservationEntry."Source Prod. Order Line";
                  END ELSE BEGIN
                    liLineNo := lrecReservationEntry."Source Ref. No.";
                  END;
                END;
              END ELSE BEGIN
                lcodDocNo := lrecReservationEntry."Source ID";
                IF ((lrecReservationEntry."Source Type" = DATABASE::"Transfer Line") OR (lrecReservationEntry."Source Type" = DATABASE::"Prod. Order Component")) THEN BEGIN
                  liLineNo := lrecReservationEntry."Source Prod. Order Line";
                END ELSE BEGIN
                  liLineNo := lrecReservationEntry."Source Ref. No.";
                END;
              END;

              lrrefWriter.GETTABLE( lrecReservationEntry );
              cuWMDMCommon.setDSFieldOverrideValue(iEventID,
                '',
                DATABASE::"Reservation Entry",
                lrecReservationEntry.FIELDNO("Source ID"),
                lcodDocNo
              );
              IF (lcuWMDMDoc.GetRecordRefKeys(lcodLocation,
                                              '', //pcodBin
                                              lcodDocNo,
                                              liLineNo,
                                              lcodItemNumber,
                                              FALSE,
                                              trecEventParams,
                                              lrrefOutFoundRecord,
                                              lrecOutSearchRule)) THEN BEGIN
                liFieldIndex := 1;
                liTotalFieldCount := lrrefOutFoundRecord.FIELDCOUNT;
                lbFoundUOMField := FALSE;
                REPEAT
                  lfFieldRef := lrrefOutFoundRecord.FIELDINDEX(liFieldIndex);
                  liFieldIndex := liFieldIndex +1;
                  IF ((lfFieldRef.NAME = 'Unit of Measure Code') OR (lfFieldRef.NAME = 'Unit of Measure')) THEN BEGIN
                    lbFoundUOMField := TRUE;
                    cuWMDMCommon.setDSFieldOverrideValue(iEventID,
                                                        '',
                                                        DATABASE::"Reservation Entry",
                                                        -1,
                                                        FORMAT(lfFieldRef.VALUE)
                                                      );
                  END;
                UNTIL ((liFieldIndex >liTotalFieldCount) OR lbFoundUOMField);
              END;
              cuWMDMCommon.addDSFieldsForRecord(lbsOutput,lrrefWriter,iEventID,'');
              lbsOutput.ADDTEXT('</FIELDS></R>');
              lnNumTrans += 1;
            END;
          UNTIL((lrecReservationEntry.NEXT=0) OR (lnNumTrans = lrecWMDMSetup."Item Inquiry Max Transactions"));
        END;// end reservations
      END;//if serial no. (mh)

      //
      // find the ledger entries
      //
      IF( lnNumTrans < lrecWMDMSetup."Item Inquiry Max Transactions" ) THEN BEGIN
        lrecItemLedgerEntry.RESET;
        lrecItemLedgerEntry.SETCURRENTKEY("Entry No.");

        lrecItemLedgerEntry.SETRANGE("Item No.",lcodItemNumber);
        IF( lcodSerialNumber <> '' ) THEN
          lrecItemLedgerEntry.SETRANGE("Serial No.",lcodSerialNumber);
        IF( lcodLotNumber <> '' ) THEN
          lrecItemLedgerEntry.SETRANGE("Lot No.",lcodLotNumber);
        IF( lcodVariantCode <> '' ) THEN
          lrecItemLedgerEntry.SETRANGE("Variant Code",lcodVariantCode);

        lrecItemLedgerEntry.SETFILTER("Location Code",lcodLocation);//<IW author="E.Li" date="01/30/19" issue="4570">

        lrecItemLedgerEntry.ASCENDING(FALSE);

        {{// 2009::begin
        IF( lrecItemLedgerEntry.FIND('-') )THEN BEGIN
        }}// 2009::end
        // 2013::begin
        IF( lrecItemLedgerEntry.FINDSET(FALSE,FALSE) ) THEN BEGIN
          // 2013::end
          // The same output is re-used for up to 3 different tables.
          // This assumes the mandatory requirement that their must be the same # of columns
          // configured in the PDA column config.
          cuWMDMCommon.initializeColumns( TRUE );
          cuWMDMCommon.setWriteColumnHeader( FALSE ); // already written with shipment header
          cuWMDMCommon.addDSColumnsFromConfig( lbsOutput,iEventID,'', DATABASE::"Item Ledger Entry" );

          REPEAT
            lbsOutput.ADDTEXT('<R><FIELDS>');
            cuWMDMCommon.initVariantColumnIndex();
            lrrefWriter.GETTABLE( lrecItemLedgerEntry );
            cuWMDMCommon.addDSFieldsForRecord(lbsOutput,lrrefWriter,iEventID,'');
            lbsOutput.ADDTEXT('</FIELDS></R>');
            lnNumTrans += 1;
          UNTIL(lrecItemLedgerEntry.NEXT()=0) OR (lnNumTrans = lrecWMDMSetup."Item Inquiry Max Transactions");
        END; // end item ledger entries
      END;

      lbsOutput.ADDTEXT('</ROWS>');
      lbsOutput.ADDTEXT('</TABLE>');
      lbsOutput.ADDTEXT('</DATASET>');

      cuWMDMActivityLogMgt.logActivity(trecEventParams);
      //error('%1',lrecWMDMSetup."Item Inquiry Max Transactions");

      sendStandardResult(lbsOutput, TRUE);
    END;

    LOCAL PROCEDURE getNextBin@1000000010();
    VAR
      lrecLocation@1000000012 : Record 14;
      lcodLocation@1000000011 : Code[10];
      lcodActivityNo@1000000010 : Code[20];
      liActivityType@1000000009 : Integer;
      liLineNumber@1000000008 : Integer;
      lcodBinCode@1000000007 : Code[20];
      lrecWhseActivityLine@1000000006 : Record 5767;
      ltxtLineNumber@1000000005 : Text[50];
      ltxtActivityType@1000000004 : Text[50];
      lrecBin@1000000003 : Record 7354;
      lcodPreviousBin@1000000002 : Code[20];
      lbsOutput@1000000001 : BigText;
      lrecComments@1000000000 : Record 97;
      lrecBinContent@1000000013 : Record 7302;
      lrecPDAActivity@1000000014 : Record 23044532;
      BinFound@1000000015 : Boolean;
      Bin@1000000016 : Record 7354;
    BEGIN
      lcodLocation := trecEventParams.getValue('location');
      lcodBinCode := trecEventParams.getValue('bin');
      lcodActivityNo := trecEventParams.getDocumentNo();
      ltxtActivityType := trecEventParams.getValue('document_type');
      IF(ltxtActivityType = '') THEN BEGIN
        ltxtActivityType := trecEventParams.getValue('Type');
      END;

      EVALUATE(liActivityType, ltxtActivityType);

      ltxtLineNumber := trecEventParams.getValue('Line No.');
      EVALUATE( liLineNumber, ltxtLineNumber);

      lrecWhseActivityLine.GET(liActivityType,lcodActivityNo,liLineNumber);
      trecEventParams.setValue('Previous Bin', lrecWhseActivityLine."Bin Code");

      //filter on bin content here
      {
      lrecBinContent.SETRANGE("Location Code", lrecWhseActivityLine."Location Code");
      lrecBinContent.SETRANGE("Item No.", lrecWhseActivityLine."Item No.");
      lrecBinContent.SETRANGE("Variant Code", lrecWhseActivityLine."Variant Code");
      //lrecBinContent.SETFILTER("Bin Code", '<>%1', lrecWhseActivityLine."Bin Code");
      lrecBinContent.SETFILTER("Bin Code", '<>%1&<>SHIPPING', lrecWhseActivityLine."Bin Code");
      lrecBinContent.SETFILTER("Quantity (Base)", '>=%1', lrecWhseActivityLine."Qty. (Base)");
      IF(lrecBinContent.FINDFIRST()) THEN BEGIN
        lrecWhseActivityLine."Bin Code" := lrecBinContent."Bin Code";
        lrecWhseActivityLine.MODIFY;
      END ELSE BEGIN
        ERROR('Unable to find alternate bin with sufficient Qty. to fulfil the pick.');
      END;
      } //blocked TPZ2752
      //<TPZ2752
      //lrecWhseActivityLine.TESTFIELD("Qty. to Handle",0);
      IF lrecWhseActivityLine."Qty. to Handle" <> 0 THEN
        ERROR('Can not change Bin when Qty Handled')
      ELSE BEGIN
        BinFound := FALSE;
        lrecBinContent.SETRANGE("Location Code", lrecWhseActivityLine."Location Code");
        lrecBinContent.SETRANGE("Item No.", lrecWhseActivityLine."Item No.");
        lrecBinContent.SETRANGE("Variant Code", lrecWhseActivityLine."Variant Code");
        lrecBinContent.SETFILTER("Bin Code", '<>%1', lrecWhseActivityLine."Bin Code");
        lrecBinContent.SETFILTER("Bin Type Code",'PICKPUT');
        lrecBinContent.SETFILTER("Quantity (Base)", '>=%1', lrecWhseActivityLine."Qty. (Base)");
        IF lrecBinContent.FINDSET THEN BEGIN
          REPEAT
            IF Bin.GET(lrecBinContent."Location Code",lrecBinContent."Bin Code") AND ((Bin."Block Movement" <> Bin."Block Movement"::All) AND (Bin."Block Movement" <> Bin."Block Movement"::Outbound) ) THEN BEGIN
        //    IF NOT CONFIRM(BinChangeConfirm,FALSE,lrecWhseActivityLine."Bin Code",lrecBinContent."Bin Code") THEN
        //      EXIT;
              lrecWhseActivityLine."Bin Code" := lrecBinContent."Bin Code";
              lrecWhseActivityLine.MODIFY;
              BinFound := TRUE;
              BREAK;
          END;
          UNTIL lrecBinContent.NEXT=0;
        END;
        IF NOT BinFound THEN
          ERROR('Unable to find alternate bin with sufficient Qty. to fulfil the pick.');
      END;
      //</TPZ2752>
      //Logging
      //ERROR('here');
      trecEventParams.setValue('Summary Type', '3');
      trecEventParams.setValue('New Bin', lrecWhseActivityLine."Bin Code");
      trecEventParams.MODIFY;
      cuWMDMActivityLogMgt.logActivity(trecEventParams);

      sendSuccessResult('', TRUE);
    END;

    BEGIN
    {
      <DMS>
        <REVISION author="R.Trudeau" date="20/12/2016" version="IW16.12" issue="">
          Example extension for extending whse. receipt to post + print.
        </REVISION>
        <REVISION author="R.Letts" date="3/23/17" issue="3580">
          Added the ability to use Sales Return Orders
        </REVISION>
        <REVISION author="R.Trudeau" date="03/23/17" version="IW17.03" issue="24431">
          Added plug-in support for calculating cross-dock prior to receipt posting.
        </REVISION>
        <REVISION author="R.Trudeau" date="10/10/17" version="IW17.10" issue="3580">
          Re-implement 3580 to use 1.8 modified code.
        </REVISION>
        <REVISION author="R.Letts" date="12/12/18" version="IW18.12" issue="4550">
          Added an event to show item card comments for pick lines
        </REIVISION>
        <REVISIONIW author="E.Li" date="01/30/19" issue="4570">
          Added a filter to location
        </REIVISION>
        <REVISION author="R.Letts" date="10/7/19" issue="5037">
          Select next avil. bin action
        </REVISION>
      </DMS>
      2020-31-01 TPZ2752 VAHAMAD
       Code redesigned in function getNextBin
      2020-05-01  TPZ2781  PSHUKLA  Added code for receiving stopped functionality, showing message.
      001 TPZ2886 RPS 10192020 - Picking Performance  | PowerBI
    }
    END.
  }
}

