OBJECT Codeunit 23044516 IWX Barcode Generation
{
  OBJECT-PROPERTIES
  {
    Date=10/03/19;
    Time=[ 9:11:34 AM];
    Version List=IWX2.4.7684.0;
  }
  PROPERTIES
  {
    OnRun=BEGIN
          END;

  }
  CODE
  {
    VAR
      tcInvalidBarcodeType@1000000004 : TextConst 'ENU=Invalid barcode format: %1.;ENC=Unsupported barcode format: %1.';
      dnBarcodeGen@1000000001 : DotNet "'DMS.BarcodeObjects, Version=1.5.0.0, Culture=neutral, PublicKeyToken=e973386185bb852f'.DMS.BarcodeObjects.BarcodeGeneration";
      tcProblem@1000000000 : TextConst 'ENU=Problem: %1;ESM=Problema: %1;FRC=Probl?me: %1;ENC=Problem: %1';

    PROCEDURE initialize@1000000001();
    BEGIN

      //////////////////////////////////////////////
      //<Summary>
      // Initializes the required components
      //</Summary>
      //<Author>R.Trudeau</Author>
      //<Date>12/3/2010</Date>
      //<Issue></Issue>
      //<Version>DMS1.0</Version>
      //////////////////////////////////////////////

      IF ( ISNULL(dnBarcodeGen) ) THEN BEGIN
        dnBarcodeGen := dnBarcodeGen.BarcodeGeneration();
      END;
    END;

    PROCEDURE unInitialize@1000000004();
    BEGIN
      //////////////////////////////////////////////
      //<Summary>
      // Clears the required components - optionally called
      // Cleared when codeunit dies
      //</Summary>
      //<Author>R.Trudeau</Author>
      //<Date>12/3/2010</Date>
      //<Issue></Issue>
      //<Version>DMS1.0</Version>
      //////////////////////////////////////////////


      //CLEAR(aoBarcodeGen);
    END;

    PROCEDURE get2dBarCode@1000000002(VAR ptrecBarcode@1000000003 : TEMPORARY Record 99008535;ptxtCode@1000000001 : Text;piBarcodeDotSize@1000000000 : Integer;piBarcodeMarginSize@1000000002 : Integer;piBarcodeImageSize@1000000004 : Integer);
    VAR
      osBlobStream@1000000005 : OutStream;
      lbFileExists@1000000009 : Boolean;
      ldnMemStream@1000000011 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.MemoryStream";
    BEGIN
      //////////////////////////////////////////////
      //<Summary>
      // Returns a 2D barcode image in the Picture
      // field of temp blob record.
      //</Summary>
      //<Author>R.Trudeau</Author>
      //<Date>12/3/2010</Date>
      //<Issue></Issue>
      //<Version>DMS1.0</Version>
      //////////////////////////////////////////////

      CLEAR(ptrecBarcode);

      initialize();

      // create the memory stream, this will contain
      // the image data that has the barcode
      ldnMemStream := ldnMemStream.MemoryStream();

      // create the image in the memory stream
      IF( NOT dnBarcodeGen.GenerateDataMatrixBarcodeToStream (
            ptxtCode,
            piBarcodeDotSize,
            piBarcodeMarginSize,
            piBarcodeImageSize,
            'bmp',
            ldnMemStream ) ) THEN BEGIN

           ERROR( dnBarcodeGen.GetLastError());
      END;

      // create an outstrem in the temp barcode object to hold the picture
      ptrecBarcode.Blob.CREATEOUTSTREAM( osBlobStream );

      // write the memory stream, now containing our picture, into the blob
      ldnMemStream.WriteTo( osBlobStream );
    END;

    PROCEDURE getProdOrderSerialNos@1000000000(pcodProdOrder@1000000004 : Code[20];psItemNumber@1000000003 : Text;VAR ptrecInvBuffer@1000000002 : TEMPORARY Record 307);
    VAR
      lrecItemLedger@1000000001 : Record 32;
      lrecResEntry@1000000000 : Record 337;
    BEGIN
      //////////////////////////////////////////////
      //<Summary>
      // Returns list of serial numbers for the specified production order
      // evaluates both the item tracking entries and the item ledger entries
      //</Summary>
      //<Author>M.Hamblin</Author>
      //<Date>10/5/2009</Date>
      //<Issue></Issue>
      //<Version>DMS1.0</Version>
      //////////////////////////////////////////////

      ptrecInvBuffer.RESET;
      ptrecInvBuffer.DELETEALL;

      // add posted serial numbers
      lrecItemLedger.SETRANGE("Order Type",lrecItemLedger."Order Type"::Production);
      lrecItemLedger.SETRANGE("Order No.", pcodProdOrder);
      lrecItemLedger.SETRANGE("Item No.", psItemNumber);
      lrecItemLedger.SETRANGE("Entry Type",  lrecItemLedger."Entry Type"::Output);
      lrecItemLedger.SETFILTER("Serial No.", '<>%1', '');

      IF lrecItemLedger.FINDSET THEN
        REPEAT
          ptrecInvBuffer."Item No." := psItemNumber;
          ptrecInvBuffer."Serial No." := lrecItemLedger."Serial No.";
          IF ptrecInvBuffer.INSERT THEN ;
        UNTIL lrecItemLedger.NEXT=0;

      // remove posted serial numbers that have been un-posted
      lrecItemLedger.SETFILTER(Quantity, '<%1', 0);

      IF lrecItemLedger.FINDSET THEN
        REPEAT
          ptrecInvBuffer.SETRANGE("Serial No.", lrecItemLedger."Serial No.");
          IF ptrecInvBuffer.FINDSET THEN
            ptrecInvBuffer.DELETEALL;
        UNTIL lrecItemLedger.NEXT=0;


      ptrecInvBuffer.RESET;

      // now add item tracking lines
      lrecResEntry.SETRANGE("Source ID", pcodProdOrder);
      lrecResEntry.SETRANGE("Item No.", psItemNumber);
      lrecResEntry.SETRANGE("Source Type",  DATABASE::"Prod. Order Line");
      lrecResEntry.SETFILTER("Serial No.", '<>%1', '');

      IF lrecResEntry.FINDSET THEN
        REPEAT
          ptrecInvBuffer."Item No." := psItemNumber;
          ptrecInvBuffer."Serial No." := lrecResEntry."Serial No.";
          IF ptrecInvBuffer.INSERT THEN ;
        UNTIL lrecResEntry.NEXT=0;
    END;

    PROCEDURE create1dBarCode@1000000005(ptxtCode@1000000000 : Text) rtxtBarcode : Text;
    BEGIN

      rtxtBarcode := STRSUBSTNO('*%1*',ptxtCode);
    END;

    PROCEDURE get1dBarcode@1000000006(VAR ptrecBarcode@1000000001 : Text[100];ptxtCode@1000000000 : Text[100]);
    VAR
      ltxtFilename@1000000009 : Text[250];
      StreamInObj@1000000008 : InStream;
      StreamOutObj@1000000007 : OutStream;
      lFile@1000000006 : File;
      liSleepTimerMS@1000000005 : Integer;
      lbLooping@1000000004 : Boolean;
      lbCurrentTotalLoopTimeMS@1000000003 : Integer;
      lbFileExists@1000000002 : Boolean;
    BEGIN
    END;

    LOCAL PROCEDURE getParamValueAsInt@1000000014(psParamValue@1000000000 : Text;piDefaultValue@1000000001 : Integer) : Integer;
    VAR
      liValue@1000000002 : Integer;
    BEGIN
      IF( psParamValue = '' ) THEN
        EXIT(piDefaultValue);

      EVALUATE(liValue,psParamValue);
      EXIT(liValue);
    END;

    PROCEDURE get2dBarCodePDA@1000000003(VAR ptrecBarcode@1000000003 : TEMPORARY Record 99008535;pcodPDACode@1000000001 : Code[20];piLoginMethod@1000000002 : Integer;ptxtDefaultDomain@1000000004 : Text;ptxtDefaultUser@1000000005 : Text;ptxtDefaultPassword@1000000006 : Text;ptxtWebService@1000000007 : Text);
    VAR
      ltxtConfigBarcode@1000000000 : Text;
      osBlobStream@1000000010 : OutStream;
      lbFileExists@1000000009 : Boolean;
      ldnMemStream@1000000008 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.MemoryStream";
    BEGIN
      //
      // This does not use get2DBarcode intentionally
      // as the configuration barcode needs to be larger than
      // the typical default barcode size
      //
      ltxtConfigBarcode := '%CONFIG%&lt;CONFIG&gt;';
      ltxtConfigBarcode += STRSUBSTNO('&lt;OPTION key="webservice" value="%1" /&gt;', ptxtWebService  );
      ltxtConfigBarcode += STRSUBSTNO('&lt;OPTION key="pda_id" value="%1" /&gt;', pcodPDACode);
      ltxtConfigBarcode += STRSUBSTNO('&lt;OPTION key="company" value="%1" /&gt;', COMPANYNAME() );
      ltxtConfigBarcode += STRSUBSTNO('&lt;OPTION key="login_mode" value="%1" /&gt;', piLoginMethod);
      ltxtConfigBarcode += STRSUBSTNO('&lt;OPTION key="default_domain" value="%1" /&gt;', ptxtDefaultDomain );
      ltxtConfigBarcode += STRSUBSTNO('&lt;OPTION key="default_user" value="%1" /&gt;', ptxtDefaultUser );
      ltxtConfigBarcode += STRSUBSTNO('&lt;OPTION key="default_password" value="%1" /&gt;', ptxtDefaultPassword );
      ltxtConfigBarcode += '&lt;/CONFIG&gt;';

      //
      // This has special parameters
      //
      CLEAR(ptrecBarcode);
      initialize();

      // create the memory stream, this will contain
      // the image data that has the barcode
      ldnMemStream := ldnMemStream.MemoryStream();

      // create the image in the memory stream
      // 0 = auto size
      // 24 = 144x144 "Barcode Image Size" enumeration allows up to 3k
      // 20 = 96x96 "Barcode Image Size" enumeration, allows up to 1k
      //IF( NOT dnBarcodeGen.GenerateDataMatrixBarcodeToStream (
      //      ltxtConfigBarcode,
      //      2, // "Barcode Dot Size",
      //      0, // "Barcode Margin Size",
      //      0, // auto size
      //      'bmp',
      //      ldnMemStream ) ) THEN BEGIN
      //     ERROR( dnBarcodeGen.GetLastError());
      //END;

      IF ( NOT dnBarcodeGen.GenerateQRCodeBarcodeToStream(
        ltxtConfigBarcode, // string barcodeData,
        1, // 1 is alphanumeric int encodeType,
        1, // int scale,
        40, // int version,
        3, // low int errorCorrection,
        'bmp', // string fileFormat,
        ldnMemStream ) ) THEN BEGIN
        ERROR( tcProblem,dnBarcodeGen.GetLastError());
      END;


      // create an outstrem in the temp barcode object to hold the picture
      ptrecBarcode.Blob.CREATEOUTSTREAM( osBlobStream );

      // write the memory stream, now containing our picture, into the blob
      ldnMemStream.WriteTo( osBlobStream );
    END;

    PROCEDURE get2dBarCodeAuto@1000000009(VAR ptrecBarcode@1000000003 : TEMPORARY Record 99008535;ptxtBarcode@1000000007 : Text);
    VAR
      osBlobStream@1000000010 : OutStream;
      ldnMemStream@1000000008 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.MemoryStream";
    BEGIN
      //
      // This does not use get2DBarcode intentionally
      // as the configuration barcode needs to be larger than
      // the typical default barcode size
      //
      //
      // This has special parameters
      //
      CLEAR(ptrecBarcode);
      initialize();

      // create the memory stream, this will contain
      // the image data that has the barcode
      ldnMemStream := ldnMemStream.MemoryStream();

      // create the image in the memory stream
      // 0 = auto size
      // 24 = 144x144 "Barcode Image Size" enumeration allows up to 3k
      // 20 = 96x96 "Barcode Image Size" enumeration, allows up to 1k
      IF( NOT dnBarcodeGen.GenerateDataMatrixBarcodeToStream (
            ptxtBarcode,
            2, // "Barcode Dot Size",
            4, // "Barcode Margin Size",
            0, // auto size
            'bmp',
            ldnMemStream ) ) THEN BEGIN
           ERROR( dnBarcodeGen.GetLastError());
      END;

      // QR Code option:
      //IF ( NOT dnBarcodeGen.GenerateQRCodeBarcodeToStream(
      //  ltxtConfigBarcode, // string barcodeData,
      //  1, // 1 is alphanumeric int encodeType,
      //  1, // int scale,
      //  10, // int version,
      //  3, // low int errorCorrection,
      //  'bmp', // string fileFormat,
      //  ldnMemStream ) ) THEN BEGIN
      //  ERROR( 'Problem' + dnBarcodeGen.GetLastError());
      //END;

      // create an outstrem in the temp barcode object to hold the picture
      ptrecBarcode.Blob.CREATEOUTSTREAM( osBlobStream );

      // write the memory stream, now containing our picture, into the blob
      ldnMemStream.WriteTo( osBlobStream );
    END;

    BEGIN
    {
      ************************
      Copyright Notice
      This objects content is copyright of Dynamic Manufacturing Solutions Inc 2011.  All rights reserved.
      Any redistribution or reproduction of part or all of the contents in any form is prohibited.
      ************************
    }
    END.
  }
}

