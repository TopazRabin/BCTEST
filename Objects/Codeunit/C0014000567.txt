OBJECT Codeunit 14000567 Forecast
{
  OBJECT-PROPERTIES
  {
    Date=02/22/21;
    Time=[ 3:49:25 PM];
    Modified=Yes;
    Version List=UBP3.03.03,TPZ;
  }
  PROPERTIES
  {
    OnRun=BEGIN
          END;

  }
  CODE
  {
    VAR
      AdvForSetup@1240030000 : Record 14002651;
      InvMgtSetup@1240030026 : Record 14000551;
      Formula@1000000003 : Record 14002652;
      Location@1240030023 : Record 14;
      GblProcUnit@1240020019 : Record 14000555;
      UBP@1240030053 : Codeunit 14000564;
      ForCustUsageArray@1240030021 : ARRAY [200] OF Decimal;
      ForCustDailyUsageArray@1240030022 : ARRAY [200] OF Decimal;
      ForPeriodDays@1240030014 : ARRAY [200] OF Integer;
      ForPeriodDate@1240030015 : ARRAY [200] OF Date;
      ForPeriodEndDate@1240030033 : ARRAY [200] OF Date;
      ForUsageArray@1240030005 : ARRAY [200] OF Decimal;
      ForDailyUsageArray@1240030006 : ARRAY [200] OF Decimal;
      InvPlusExpRec@1240030024 : ARRAY [200] OF Decimal;
      NonSeasonalTrendPct@1240030017 : Decimal;
      Periods@1240030009 : Integer;
      SeasonalTrendPct@1240030018 : Decimal;
      TotalWeight@1240030011 : Decimal;
      UsageArray@1240030007 : ARRAY [200] OF Decimal;
      Demand@1240030052 : ARRAY [200] OF Decimal;
      Consumed@1240030027 : ARRAY [200] OF Decimal;
      PurchOrders@1240030031 : ARRAY [200] OF Decimal;
      NetTransfers@1240030029 : ARRAY [200] OF Decimal;
      CurrInventory@1240030030 : ARRAY [200] OF Decimal;
      ProdOrders@1240030038 : ARRAY [200] OF Decimal;
      Comp@1240030040 : ARRAY [200] OF Decimal;
      LastPossibleDate@1240030035 : Date;
      FrozenUsageArray@1240030050 : ARRAY [200] OF Decimal;
      FrozenDailyUsageArray@1240030051 : ARRAY [200] OF Decimal;
      SporadicTargetStockLevel@1240030049 : Decimal;
      ProdStatFilter@1240030028 : Text[60];
      Text000@1240020048 : TextConst 'ENU=For Location %1, you must define at least %2 inventory periods after the last closed period %3.';
      Text001@1240030055 : TextConst 'ENU=Proc. Unit %1 %2 %3 has a LTH Date %4 greater than the periods to forecast %5.';
      SingleLocation@1240030056 : Boolean;
      AccumStatForecast@1240030057 : Decimal;
      AccumCustForecast@1240020006 : Decimal;
      LTHAccumForecast@1240030061 : Decimal;
      ForAdj@1240030062 : ARRAY [200] OF Decimal;
      UsageLocationFilter@1000000007 : Text[250];
      UsageLocationFilterSingle@1000000006 : Text[250];
      LocationFilter@1000000005 : Text[250];
      LocationFilterSingle@1000000004 : Text[250];
      ForCalcPeriodDate@1240030036 : ARRAY [200] OF Date;
      ForCalcPeriodEndDate@1240030037 : ARRAY [200] OF Date;
      ForCalcPeriodDays@1240030041 : ARRAY [200] OF Integer;
      ForCalcUsageArray@1240030069 : ARRAY [200] OF Decimal;
      ForCalcDailyUsageArray@1240030070 : ARRAY [200] OF Decimal;
      UseCalcPeriods@1240030077 : Boolean;
      PriorYearUsage@1240030032 : ARRAY [200] OF Decimal;
      PriorYearAdjUsage@1240030082 : ARRAY [200] OF Decimal;
      PriorYearAdjUsagePerDay@1240030084 : ARRAY [200] OF Decimal;
      MaxOverrideLTHDate@1240020001 : Date;
      MaxPeriodsToCalculate@1240020002 : Integer;
      MaxPeriodsToForecast@1240020004 : Integer;
      ForecastOnlyReqPeriods@1240020003 : Boolean;
      ForDailyUsageArrayNoFCAdjust@1240020008 : ARRAY [200] OF Decimal;
      NonStockUnit@1240020010 : Boolean;
      SalesReturnOrders@1000 : ARRAY [200] OF Decimal;
      CalledFromCalcMinSOQ@1240020005 : Boolean;
      GblCalcSingleLocForecast@1240020012 : Boolean;
      SingleLocNetAverageUsage@1240020013 : Decimal;
      ForAutoAdj@1240020014 : ARRAY [200] OF Decimal;
      SetupAvailable@1240020011 : Boolean;
      PrevNetInvPos@1240020015 : Decimal;
      GblNetInvPos@1240020016 : Decimal;
      Text002@1240020046 : TextConst 'ENU=For Location %1, , the workdate %2 is less than the last closed inventory period date %3.';
      Text003@1240020047 : TextConst 'ENU="Procurement Unit %1 %2 %3\.  The forecast cannot find the correct period for the Lead Time Horizon Date %4 using %5 periods.  "';
      Text004@1240020049 : TextConst 'ENU=For Location %1, no closed inventory period could be found.';
      TextAdjShelf@1240020018 : TextConst 'ENU="Net Inv Pos %1 - Min Shelf %2  = Adj Net Inv Pos %3"';
      GblCalcProductionPlanningLines@1240020021 : Boolean;
      LTHForAutoAdj@1240020022 : Decimal;
      LTHDemand@1240020023 : Decimal;
      LTHTotalFC@1240020007 : Decimal;
      LTHConsumed@1240020020 : Decimal;
      AvgOrderQty@1240020024 : Decimal;
      SafetyStockQty@1240020025 : Decimal;
      TextAdjSafetyAllowance@1240020026 : TextConst 'ENU="Net Inv Pos (%1) - (%2) at (%3)  = Adj Net Inv Pos (%4)"';
      NetInvPosSource@1240020027 : Text[250];
      outSafetyStockQtyfromDays@1240020028 : Decimal;
      TextAdjSafetyAllowanceAddStock@1000000001 : TextConst 'ENU="Net Inv Pos (%1) - (%2) at (%3) with Add. Stock (%5)  = Adj Net Inv Pos (%4)"';
      TextSafetyAllowance@1240020029 : TextConst 'ENU=(%1 %2)';
      AdditonalStock@1000000000 : Decimal;
      TextSafetyAllowanceAddStock@1000000002 : TextConst 'ENU=(%1 %2 with Add. Stock %3)';
      TextInvExp@1240020032 : TextConst 'ENU=Inventory Expected (%1)';
      TextTotForecastBegin@1240020034 : TextConst 'ENU=Need (%1) [';
      TextTotForecastEnd@1240020039 : TextConst 'ENU=]';
      TextForecast@1240020038 : TextConst 'ENU=Forecast %1';
      TextAutoForecast@1240020037 : TextConst 'ENU=Demand Adj. %1';
      TextMinus@1240020035 : TextConst 'ENU=-';
      TextAdjusted@1240020036 : TextConst 'ENU=" "';
      TextPrevNetInvPos@1240020033 : TextConst 'ENU=Net Inv Pos (%1)';
      TextNetInvPos@1240020045 : TextConst 'ENU="Net Inv Pos (%1) = "';
      TextAddStock@1240020030 : TextConst 'ENU=with Add. Stock (%1)';
      GblMinSOQ@1000000008 : Decimal;
      ForecastSource@1000000009 : ' ,Min/Max,Frozen Forecast,Frozen Formula,Formula';
      GblLeadTimeHorizonDate@1000000010 : Date;
      GblForcAdjFound@1240020000 : Boolean;
      GblHorizonPer@1240020009 : Integer;
      GblFrozenUsageFound@1240020017 : Boolean;
      LastClosedPeriodDate@1240020040 : Date;
      outViewSporadicQty@1240020041 : Decimal;
      txtDemandExp@1240020042 : TextConst 'ENU=Exp. Demand %1';
      IgnoreFrozenForecastAdjust@1240020043 : Boolean;
      ForcastErrorPct@1240020044 : Decimal;
      GblFrozenForecast@1240020031 : Boolean;
      GblSurplusExcessFactor@1240020050 : Decimal;
      UseSurplusFactor@1240020052 : Boolean;
      UseExcessFactor@1240020051 : Boolean;
      SporadicTargetStockLevelForRollUp@1001 : Decimal;

    PROCEDURE CalcPeriodStartingDates@1240030004(CurrLocation@1240030000 : Record 14;PeriodsToForecast@1240030001 : Integer);
    VAR
      i@1240020000 : Integer;
      LocInvPer@1000000000 : Record 14000553;
    BEGIN
      GetSetup;
      LocInvPer.RESET;
      LocInvPer.SETFILTER("Starting Date",'>%1',CurrLocation."Last Closed Period Date");
      LocInvPer.SETRANGE("Location Code",CurrLocation.Code);
      IF NOT LocInvPer.FIND('-') THEN
        EXIT;
      i := 0;
      REPEAT
        i := i + 1;
        ForPeriodDate[i] := LocInvPer."Starting Date";
        ForPeriodEndDate[i] := LocInvPer."Ending Date";
        IF (ForecastOnlyReqPeriods) AND
            // max override is only used in calcminsoq
           (MaxOverrideLTHDate <> 0D) AND
           (ForPeriodEndDate[i] > MaxOverrideLTHDate)
        THEN BEGIN
          MaxPeriodsToForecast := i;
          AdvForSetup."Periods to Forecast" := i;
        END;
        ForPeriodDays[i] := (LocInvPer."Ending Date" - LocInvPer."Starting Date") + 1;
        LastPossibleDate := LocInvPer."Ending Date";
      UNTIL (LocInvPer.NEXT = 0) OR
            (i >= AdvForSetup."Periods to Forecast");
      LastClosedPeriodDate := CurrLocation."Last Closed Period Date";

      IF i < AdvForSetup."Periods to Forecast" THEN
        ERROR(Text000,CurrLocation.Code,AdvForSetup."Periods to Forecast",LocInvPer."Starting Date");

      IF WORKDATE < CurrLocation."Last Closed Period Date" THEN
        ERROR(Text002,CurrLocation.Code,WORKDATE,CurrLocation."Last Closed Period Date");
    END;

    PROCEDURE CalcForecast@1240030000(ProcUnit@1240030000 : Record 14000555;PeriodsToForecast@1240030001 : Integer;SourceNo@1240030003 : Code[20];CurrSingleLocation@1240030004 : Boolean;CurrUseCalcPeriods@1240030005 : Boolean);
    VAR
      CurrPerStartingDate@1240020000 : Date;
      ItemUsage@1240020001 : Record 14000557;
      i@1240020002 : Integer;
      ItemUsageAdj@1000000000 : Record 14000558;
      LocInvPer@1000000001 : Record 14000553;
      FormulaPeriod@1000000002 : Record 14002653;
      CurrPer@1000000003 : Integer;
      ForecastPeriod@1000000004 : Integer;
      HighUsage@1000000011 : Decimal;
      HighWeightedUsage@1000000010 : Decimal;
      HighWeight@1000000009 : Decimal;
      LowUsage@1000000008 : Decimal;
      LowWeightedUsage@1000000007 : Decimal;
      LowWeight@1000000006 : Decimal;
      ZeroUsageWeight@1000000005 : Decimal;
      WeightedUsage@1000000012 : Decimal;
      CalcPeriod@1000000016 : Integer;
      CalcCurrDays@1000000015 : Integer;
      CalcPostdays@1000000014 : Integer;
      CalcPrevDays@1000000013 : Integer;
      ForcAdjIsFrozen@1240020003 : Boolean;
    BEGIN
      GblProcUnit := ProcUnit;
      SingleLocation := CurrSingleLocation;
      UseCalcPeriods := CurrUseCalcPeriods;
      NonStockUnit := ProcUnit."Nonstock Unit";
      CLEAR(UsageArray);
      CLEAR(ForUsageArray);
      CLEAR(ForDailyUsageArray);
      CLEAR(ForPeriodDays);
      CLEAR(ForPeriodDate);
      CLEAR(ForPeriodEndDate);
      CLEAR(ForCustUsageArray);
      CLEAR(ForCustDailyUsageArray);
      CLEAR(ForDailyUsageArrayNoFCAdjust);
      GetSetup;

      SporadicTargetStockLevel := 0;
      SporadicTargetStockLevelForRollUp := 0;
      SingleLocNetAverageUsage := 0;
      AvgOrderQty := 0;
      SafetyStockQty := 0;

      Location.GET(ProcUnit."Location Code");
      CalcPeriodStartingDates(Location,AdvForSetup."Periods to Forecast");

      IF UseCalcPeriods THEN
        LoadForCalcPeriods;

      IF CalledFromCalcMinSOQ THEN
        GblHorizonPer := GetLeadTimeHorizPeriod(GblLeadTimeHorizonDate);

      LocInvPer.RESET;
      LocInvPer.SETCURRENTKEY("Location Code","Period End Closed");
      LocInvPer.SETRANGE("Location Code",Location.Code);
      LocInvPer.SETRANGE("Period End Closed",TRUE);
      IF NOT LocInvPer.FIND('+') THEN
        ERROR(Text004,Location.Code);

      CurrPerStartingDate := LocInvPer."Starting Date";
      //OpenPerStartingDate := CALCDATE('<+1D>', LocInvPer."Ending Date"); // not in use

      // no forecast if max inventory
      IF (ProcUnit."Replenishment Model" = ProcUnit."Replenishment Model"::"Min/Max") AND
        (ProcUnit."Maximum Inventory" <> 0)
      THEN BEGIN
        ForecastSource := ForecastSource::"Min/Max";
        LoadForPerWithCalcPer;
        EXIT;
      END;

      ItemUsage.SETCURRENTKEY("Location Code","Item No.","Variant Code","Starting Date","Ending Date");
      ItemUsage.ASCENDING(FALSE);
      ItemUsage.SETRANGE("Location Code",ProcUnit."Location Code");
      ItemUsage.SETRANGE("Item No.",ProcUnit."Item No.");
      ItemUsage.SETRANGE("Variant Code",ProcUnit."Variant Code");
      ItemUsage.SETFILTER("Starting Date",'=%1',CurrPerStartingDate);
      ItemUsage.SETFILTER("Source No.",'=%1',SourceNo);
      IF NOT ItemUsage.FIND('-') THEN BEGIN
        //IF NOT GblCalcSingleLocForecast THEN
        CalcFrozenUsage(ProcUnit);  // Formula Source Frozen Forecast
        CalcForecastAdj(ProcUnit, AdvForSetup."Periods to Calculate");
        LoadForPerWithCalcPer;
        EXIT;
      END ELSE BEGIN
        //IF NOT GblCalcSingleLocForecast THEN
          CalcFrozenUsage(ProcUnit);
      END;

      SporadicTargetStockLevel := ItemUsage."Sporadic Target Stock Level";
      SporadicTargetStockLevelForRollUp := ItemUsage."Sporadic Target Stock Level";
      outViewSporadicQty := SporadicTargetStockLevel;
      SingleLocNetAverageUsage := ItemUsage."Single Loc. Avg Usage Per Day";
      AvgOrderQty := ItemUsage."Average Order Qty.";
      RoundValueForForecast(ProcUnit,AvgOrderQty);

      IF (ProcUnit."Frozen Safety Expiration Date" >= WORKDATE) THEN
        SafetyStockQty := ProcUnit."Frozen Safety Allowance %"
      ELSE
        SafetyStockQty := ItemUsage."Safety Allowance Qty.";

      IF SafetyStockQty < 0 THEN
        SafetyStockQty := 0;

      NonSeasonalTrendPct := ItemUsage."Re-For. Non Seasonal Trend %";
      IF (ABS(NonSeasonalTrendPct) > AdvForSetup."Max. Non Seasonal Trend %") THEN BEGIN
        IF NonSeasonalTrendPct < 0 THEN
          NonSeasonalTrendPct := - AdvForSetup."Max. Non Seasonal Trend %"
        ELSE
          NonSeasonalTrendPct := AdvForSetup."Max. Non Seasonal Trend %";
      END;
      SeasonalTrendPct := ItemUsage."Re-For. Seasonal Trend %";
      IF (ABS(SeasonalTrendPct) > AdvForSetup."Max. Seasonal Trend %") THEN BEGIN
        IF SeasonalTrendPct < 0 THEN
          SeasonalTrendPct := - AdvForSetup."Max. Seasonal Trend %"
        ELSE
          SeasonalTrendPct := AdvForSetup."Max. Seasonal Trend %";
      END;

      ForcastErrorPct := ItemUsage."Re-For. Median Error %";

      // Assign frozen formula
      IF (ProcUnit."Frozen Formula" <> '') AND
         (ProcUnit."Frozen Formula Expiration Date" >= WORKDATE) THEN BEGIN
        ForecastSource := ForecastSource::"Frozen Formula";
        IF (ItemUsage."Re-For. Formula" <> ProcUnit."Frozen Formula") THEN
          ForcastErrorPct := 0;
        ItemUsage."Re-For. Formula" := ProcUnit."Frozen Formula";
        SporadicTargetStockLevel := 0;
        SporadicTargetStockLevelForRollUp := 0;
        outViewSporadicQty := 0;
      END;

      // no formula
      IF ItemUsage."Re-For. Formula" = '' THEN BEGIN
        CalcForecastAdj(ProcUnit,AdvForSetup."Periods to Calculate");
        LoadForPerWithCalcPer;
        EXIT;
      END;

      Formula.GET(ItemUsage."Re-For. Formula");
      ForecastSource := ForecastSource::Formula;
      Periods := Formula."Formula Periods";

      IF GblCalcSingleLocForecast THEN
        FindUsageForSingleForecast(ProcUnit, CurrPerStartingDate, SourceNo)
      ELSE
        FindUsageForForecast(ProcUnit, Formula, CurrPerStartingDate, SourceNo);

      ForecastPeriod := 0;
      FormulaPeriod.SETRANGE("Formula Code",Formula.Code);
      REPEAT
        FormulaPeriod.FINDSET;
        TotalWeight := 0;
        WeightedUsage := 0;
        LowUsage := 999999999;
        LowWeightedUsage := 0;
        LowWeight := 0;
        HighUsage := 0;
        HighWeightedUsage := 0;
        HighWeight := 0;
        ZeroUsageWeight := 0;
        REPEAT
          CurrPer := FormulaPeriod.Period - ForecastPeriod;
          IF CurrPer < 1 THEN BEGIN
            WeightedUsage := WeightedUsage + (ForUsageArray[ABS(CurrPer) + 1] * FormulaPeriod.Weight);
            IF ForUsageArray[ABS(CurrPer) + 1] < LowUsage THEN BEGIN
              LowUsage := ForUsageArray[ABS(CurrPer) + 1];
              LowWeightedUsage := (ForUsageArray[ABS(CurrPer) + 1] * FormulaPeriod.Weight);
              LowWeight := FormulaPeriod.Weight;
            END;
            IF ForUsageArray[ABS(CurrPer) + 1] > HighUsage THEN BEGIN
              HighUsage := ForUsageArray[ABS(CurrPer) + 1];
              HighWeightedUsage := (ForUsageArray[ABS(CurrPer) + 1] * FormulaPeriod.Weight);
              HighWeight := FormulaPeriod.Weight;
            END;
            IF ForUsageArray[ABS(CurrPer) + 1] = 0 THEN
              ZeroUsageWeight := ZeroUsageWeight + FormulaPeriod.Weight;
          END ELSE BEGIN
            WeightedUsage := WeightedUsage + (UsageArray[CurrPer] * FormulaPeriod.Weight);
            IF UsageArray[CurrPer] < LowUsage THEN BEGIN
              LowUsage := UsageArray[CurrPer];
              LowWeightedUsage := (UsageArray[CurrPer] * FormulaPeriod.Weight);
              LowWeight := FormulaPeriod.Weight;
            END;
            IF UsageArray[CurrPer] > HighUsage THEN BEGIN
              HighUsage := UsageArray[CurrPer];
              HighWeightedUsage := (UsageArray[CurrPer] * FormulaPeriod.Weight);
              HighWeight := FormulaPeriod.Weight;
            END;
            IF UsageArray[CurrPer] = 0 THEN
              ZeroUsageWeight := ZeroUsageWeight + FormulaPeriod.Weight;
          END;
          TotalWeight := TotalWeight + FormulaPeriod.Weight;
        UNTIL FormulaPeriod.NEXT = 0;
        IF Formula."Exclude Low Usage Period" THEN BEGIN
          IF (NOT Formula."Exclude Zero Usage Periods") OR ((Formula."Exclude Zero Usage Periods") AND (LowUsage > 0)) THEN BEGIN
          WeightedUsage := WeightedUsage - LowWeightedUsage;
          TotalWeight := TotalWeight - LowWeight;
          END;
        END;
        IF Formula."Exclude High Usage Period" THEN BEGIN
          WeightedUsage := WeightedUsage - HighWeightedUsage;
          TotalWeight := TotalWeight - HighWeight;
        END;
        IF Formula."Exclude Zero Usage Periods" THEN
          TotalWeight := TotalWeight - ZeroUsageWeight;
        IF TotalWeight <> 0 THEN
          ForUsageArray[ForecastPeriod + 1] := WeightedUsage / TotalWeight;

        IF (NonSeasonalTrendPct <> 0) THEN BEGIN
          IF (Formula."Non Seasonal Trend Per. Limit" = 0) OR
             (ForecastPeriod + 1 <= Formula."Non Seasonal Trend Per. Limit")
          THEN BEGIN
            IF (ABS(NonSeasonalTrendPct) > AdvForSetup."Max. Non Seasonal Trend %") THEN
              IF NonSeasonalTrendPct < 0 THEN
                NonSeasonalTrendPct := - AdvForSetup."Max. Non Seasonal Trend %"
              ELSE
                NonSeasonalTrendPct := AdvForSetup."Max. Non Seasonal Trend %";
            IF NonSeasonalTrendPct < 0 THEN
              ForUsageArray[ForecastPeriod + 1] :=
                ForUsageArray[ForecastPeriod + 1] - (ForUsageArray[ForecastPeriod + 1] * ABS(NonSeasonalTrendPct / 100))
            ELSE
              ForUsageArray[ForecastPeriod + 1] :=
                ForUsageArray[ForecastPeriod + 1] + (ForUsageArray[ForecastPeriod + 1] * ABS(NonSeasonalTrendPct / 100));
          END;
        END;
        IF (SeasonalTrendPct <> 0) THEN BEGIN
          IF ((ABS(SeasonalTrendPct) < AdvForSetup."Max. Seasonal Trend %")) THEN
            ForUsageArray[ForecastPeriod + 1] :=
              ForUsageArray[ForecastPeriod + 1] + (ForUsageArray[ForecastPeriod + 1] * (SeasonalTrendPct / 100))
          ELSE BEGIN
            IF SeasonalTrendPct < 0 THEN
              ForUsageArray[ForecastPeriod + 1] :=
                ForUsageArray[ForecastPeriod + 1] +
                ForUsageArray[ForecastPeriod + 1] *
                ((AdvForSetup."Max. Seasonal Trend %" * -1) / 100)
            ELSE
              ForUsageArray[ForecastPeriod + 1] :=
                ForUsageArray[ForecastPeriod + 1] +
                ForUsageArray[ForecastPeriod + 1] *
                (AdvForSetup."Max. Seasonal Trend %" / 100);
          END;
        END;
        IF ForUsageArray[ForecastPeriod + 1] < 0 THEN
          ForUsageArray[ForecastPeriod + 1] := 0;

        // Round to NAV baseline
        ForUsageArray[ForecastPeriod + 1] := ROUND(ForUsageArray[ForecastPeriod + 1], 0.00001);

        IF ForPeriodDays[ForecastPeriod + 1] > 0 THEN BEGIN
          ForDailyUsageArray[ForecastPeriod + 1] :=
            ForUsageArray[ForecastPeriod + 1] / ForPeriodDays[ForecastPeriod + 1];
          ForDailyUsageArrayNoFCAdjust[ForecastPeriod + 1] :=
            ForUsageArray[ForecastPeriod + 1] / ForPeriodDays[ForecastPeriod + 1];
        END;
        ForecastPeriod := ForecastPeriod + 1;
      UNTIL ForecastPeriod = AdvForSetup."Periods to Forecast";

      IF NOT CalledFromCalcMinSOQ THEN BEGIN
        IF UseCalcPeriods THEN BEGIN
          ItemUsageAdj.RESET;
          ItemUsageAdj.SETCURRENTKEY(
            "Item No.","Location Code","Variant Code","Starting Date","Ending Date","Line No.");
          ItemUsageAdj.SETRANGE("Location Code",ProcUnit."Location Code");
          ItemUsageAdj.SETRANGE("Item No.",ProcUnit."Item No.");
          ItemUsageAdj.SETRANGE("Variant Code",ProcUnit."Variant Code");
          i := 1;
          REPEAT
            ItemUsageAdj.SETRANGE("Starting Date",ForPeriodDate[i]);
            ItemUsageAdj.SETRANGE("Ending Date",ForPeriodEndDate[i]);
            ItemUsageAdj.CALCSUMS("Adjustment Quantity");
            IF ItemUsageAdj."Adjustment Quantity" <> 0 THEN BEGIN
              PriorYearAdjUsage[i] := ItemUsageAdj."Adjustment Quantity";
              IF ForPeriodDays[i] > 0 THEN
                PriorYearAdjUsagePerDay[i] := ItemUsageAdj."Adjustment Quantity" / ForPeriodDays[i];
            END;
            i := i + 1;
          UNTIL i > AdvForSetup."Periods to Forecast";
        END;
      END;

      IF NOT UseCalcPeriods THEN BEGIN
        //IF NOT GblCalcSingleLocForecast THEN
          CalcFrozenUsage(ProcUnit);

        CalcForecastAdj(ProcUnit,AdvForSetup."Periods to Calculate");

        CLEAR(ForCalcPeriodDate);
        CLEAR(ForCalcPeriodEndDate);
        CLEAR(ForCalcPeriodDays);
        CLEAR(ForCalcUsageArray);
        CLEAR(ForCalcDailyUsageArray);
        i := 0;
        REPEAT
          i := i + 1;
          ForCalcPeriodDate[i] := ForPeriodDate[i];
          ForCalcPeriodEndDate[i] := ForPeriodEndDate[i];
          ForCalcPeriodDays[i] := ForPeriodDays[i];
          ForCalcUsageArray[i] := ForUsageArray[i];
          ForCalcDailyUsageArray[i] := ForDailyUsageArray[i];
        UNTIL ForPeriodDate[i] = 0D;

      END ELSE BEGIN
        CLEAR(ForCalcUsageArray);
        CLEAR(ForCalcDailyUsageArray);
        CalcPeriod := 1;
        i := 1;
        REPEAT
          IF (ForCalcPeriodDate[CalcPeriod] >= ForPeriodDate[i]) AND
             (ForCalcPeriodEndDate[CalcPeriod] <= ForPeriodEndDate[i])
          THEN BEGIN
            ForCalcUsageArray[CalcPeriod] :=
              ForDailyUsageArray[i] * (ForCalcPeriodEndDate[CalcPeriod] - ForCalcPeriodDate[CalcPeriod] + 1);
            PriorYearAdjUsage[CalcPeriod] :=
              PriorYearAdjUsagePerDay[i] * (ForCalcPeriodEndDate[CalcPeriod] - ForCalcPeriodDate[CalcPeriod] + 1);
          END;
          IF ForCalcPeriodDate[CalcPeriod] < ForPeriodDate[i] THEN BEGIN
            CalcPrevDays := ForPeriodDate[i] - ForCalcPeriodDate[CalcPeriod] + 1;
            CalcCurrDays := ForCalcPeriodEndDate[CalcPeriod] - ForPeriodDate[i] + 1;
              ForCalcUsageArray[CalcPeriod] := (ForDailyUsageArray[i] * CalcCurrDays);
            PriorYearAdjUsage[CalcPeriod] :=
              (PriorYearAdjUsagePerDay[i] * CalcCurrDays) + (PriorYearAdjUsagePerDay[i - 1] * CalcPrevDays);
          END;
          IF ForCalcPeriodEndDate[CalcPeriod] > ForPeriodEndDate[i] THEN BEGIN
            CalcCurrDays := ForPeriodEndDate[i] - ForCalcPeriodDate[CalcPeriod] + 1;
            CalcPostdays := ForCalcPeriodEndDate[CalcPeriod] - ForPeriodEndDate[i];
            ForCalcUsageArray[CalcPeriod] := (ForDailyUsageArray[i] * CalcCurrDays) + (ForDailyUsageArray[i + 1] * CalcPostdays);
            PriorYearAdjUsage[CalcPeriod] :=
              (PriorYearAdjUsagePerDay[i] * CalcCurrDays) + (PriorYearAdjUsagePerDay[i + 1] * CalcPostdays);
          END;

         ForCalcUsageArray[CalcPeriod] := ROUND((ForCalcUsageArray[CalcPeriod]), 0.00001);

          IF ForCalcPeriodEndDate[CalcPeriod] >= ForPeriodEndDate[i] THEN
            i := i + 1;
          CalcPeriod := CalcPeriod + 1;
        UNTIL (CalcPeriod > AdvForSetup."Periods to Calculate");

        AdvForSetup."Periods to Calculate" := CalcPeriod - 1;

        //IF NOT GblCalcSingleLocForecast THEN
          CalcFrozenUsage(ProcUnit);

        CalcForecastAdj(ProcUnit,AdvForSetup."Periods to Calculate");

        LoadForPerWithCalcPer;
      END;
    END;

    PROCEDURE LoadForCalcPeriods@1240030049();
    VAR
      StartDate@1240020000 : Date;
      CalcInvPer@1000000000 : Record 14000552;
      CalcPeriod@1000000004 : Integer;
    BEGIN
      CLEAR(ForCalcPeriodDate);
      CLEAR(ForCalcPeriodEndDate);
      CLEAR(ForCalcPeriodDays);
      CLEAR(ForCalcUsageArray);
      CLEAR(ForCalcDailyUsageArray);
      CalcInvPer.RESET;
      CalcInvPer.SETCURRENTKEY("Ending Date");
      CalcInvPer.SETRANGE(Type,CalcInvPer.Type::Calculate);
      CalcInvPer.SETFILTER("Starting Date",'>=%1',ForPeriodDate[1]);
      CalcInvPer.FIND('-');
      StartDate := CalcInvPer."Starting Date";
      CalcInvPer.SETFILTER("Starting Date",'%1..',StartDate);
      CalcInvPer.SETFILTER("Ending Date",'..%1',LastPossibleDate);
      CalcInvPer.SETRANGE("Ending Date");
      CalcInvPer.FIND('-');
      CalcPeriod := 1;
      REPEAT
        ForCalcPeriodDays[CalcPeriod] := CalcInvPer."Ending Date" - CalcInvPer."Starting Date" + 1;
        ForCalcPeriodDate[CalcPeriod] := CalcInvPer."Starting Date";
        ForCalcPeriodEndDate[CalcPeriod] := CalcInvPer."Ending Date";
        IF (ForecastOnlyReqPeriods) AND
           (MaxOverrideLTHDate <> 0D) AND
           (ForCalcPeriodEndDate[CalcPeriod] > MaxOverrideLTHDate)
        THEN BEGIN
          MaxPeriodsToCalculate := CalcPeriod;
          AdvForSetup."Periods to Calculate" := CalcPeriod;
        END;
        CalcInvPer.NEXT;
        CalcPeriod := CalcPeriod + 1;
      UNTIL CalcPeriod > AdvForSetup."Periods to Calculate";
    END;

    PROCEDURE CalcCustForecast@1240030005(ProcUnit@1240030000 : Record 14000555;PeriodsToForecast@1240030001 : Integer);
    VAR
      ForecastEntry@1240020000 : Record 14002603;
      i@1240020001 : Integer;
    BEGIN
      GetSetup;
      CLEAR(ForCustUsageArray);
      CLEAR(ForCustDailyUsageArray);

      CalcDemand(ProcUnit,AdvForSetup."Periods to Calculate");

      IF NOT CalledFromCalcMinSOQ THEN
        CalcConsumed(ProcUnit,AdvForSetup."Periods to Calculate");

      // no forecast if max inventory
      IF (ProcUnit."Replenishment Model" = ProcUnit."Replenishment Model"::"Min/Max") AND
        (ProcUnit."Maximum Inventory" <> 0)
      THEN
        EXIT;

      IF InvMgtSetup."Roll Up Via Repl. Path" THEN BEGIN
        IF GblCalcSingleLocForecast THEN
          ForecastEntry.SETFILTER("Location Code", GetLocationFilter(ProcUnit,TRUE))
        ELSE
          ForecastEntry.SETFILTER(
            "Location Code",GetUsageLocationFilter(ProcUnit,FALSE))
      END ELSE
        ForecastEntry.SETFILTER(
          "Location Code",GetUsageLocationFilter(ProcUnit,SingleLocation));

      ForecastEntry.SETRANGE("Item No.",ProcUnit."Item No.");
      ForecastEntry.SETRANGE("Variant Code",ProcUnit."Variant Code");
      ForecastEntry.SETRANGE(Released,TRUE);
      IF ForecastEntry.ISEMPTY THEN
        EXIT;

      i := 1;
      REPEAT
        ForecastEntry.SETRANGE("Starting Date",ForPeriodDate[i],ForPeriodEndDate[i]);
        ForecastEntry.CALCSUMS(ForecastEntry.Quantity);
        ForCustUsageArray[i] := ForecastEntry.Quantity;
        IF ForPeriodDays[i] > 0 THEN
          ForCustDailyUsageArray[i] := (ForecastEntry.Quantity / ForPeriodDays[i]);
        i := i + 1;
      UNTIL i > AdvForSetup."Periods to Calculate";
    END;

    PROCEDURE CalcInvPlusExpRec@1240030009(ProcUnit@1240030000 : Record 14000555;PeriodsToForecast@1240030001 : Integer);
    VAR
      i@1240020000 : Integer;
    BEGIN
      CLEAR(InvPlusExpRec);
      GetSetup;
      i := 1;
      REPEAT
        ProcUnit.SETFILTER("Date Filter",'..%1',ForPeriodEndDate[i]);
        InvPlusExpRec[i] := ProcUnit.QtyInvPlusExpRec;
        i := i + 1;
      UNTIL i > AdvForSetup."Periods to Calculate";
    END;

    PROCEDURE CalcDemand@1240030042(ProcUnit@1240030001 : Record 14000555;PeriodsToForecast@1240030000 : Integer);
    VAR
      i@1240020000 : Integer;
    BEGIN
      CLEAR(Demand);
      GetSetup;
      i := 1;
      REPEAT
        IF i = 1 THEN
          Demand[i] := CalcDemandForPeriod(ProcUnit, 0D,ForPeriodEndDate[i])
        ELSE
          Demand[i] := CalcDemandForPeriod(ProcUnit, ForPeriodDate[i],ForPeriodEndDate[i]);
        i := i + 1;
      UNTIL i > AdvForSetup."Periods to Calculate";
    END;

    PROCEDURE CalcDemandForPeriod@1240020019(VAR ProcUnit@1240030001 : Record 14000555;CurrStartDate@1240030000 : Date;CurrEndDate@1240020000 : Date) DemandForPeriod : Decimal;
    BEGIN
      DemandForPeriod := 0;
      GetSetup;
      ProcUnit.SETRANGE("Date Filter", CurrStartDate, CurrEndDate);
      IF ProdStatFilter <> '' THEN
        ProcUnit.SETFILTER("Prod. Order Status Filter",ProdStatFilter);
      IF InvMgtSetup."Roll Up Via Repl. Path" THEN BEGIN
        IF GblCalcSingleLocForecast THEN
          ProcUnit.SETFILTER("Location Filter", GetLocationFilter(ProcUnit,TRUE))
        ELSE
          ProcUnit.SETFILTER("Location Filter",GetLocationFilter(ProcUnit,FALSE))
      END ELSE
        ProcUnit.SETFILTER("Location Filter",GetLocationFilter(ProcUnit,SingleLocation));

      IF ProcUnit."Summarize Variant Detail" THEN BEGIN
        ProcUnit.CALCFIELDS(
          "Qty. on Sales Order Sum.","Additional Demand Sum.",
          "Qty. on Component Lines Sum.","Qty. on Service Order Sum.");
        ProcUnit."Qty. on Sales Order" := ProcUnit."Qty. on Sales Order Sum.";
        ProcUnit."Additional Demand" := ProcUnit."Additional Demand Sum.";
        ProcUnit."Qty. on Service Order" := ProcUnit."Qty. on Service Order Sum.";
      END ELSE
        ProcUnit.CALCFIELDS(
          "Qty. on Sales Order","Additional Demand", "Qty. on Service Order");

      IF InvMgtSetup."Consider Comp. Cons. as Usage" THEN BEGIN
        IF ProcUnit."Summarize Variant Detail" THEN BEGIN
          ProcUnit.CALCFIELDS(
            "Qty. on Component Lines Sum.","Qty. on Assy. Comp. Sum.",ProcUnit."Qty. on Assy. Comp. FC Sum.");
          ProcUnit."Qty. on Component Lines" := ProcUnit."Qty. on Component Lines Sum.";
          ProcUnit."Qty. on Assy. Comp." := ProcUnit."Qty. on Assy. Comp. Sum.";
          ProcUnit."Qty. on Assy. Comp. FC" := ProcUnit."Qty. on Assy. Comp. FC Sum.";
        END ELSE
          ProcUnit.CALCFIELDS(
            "Qty. on Component Lines",ProcUnit."Qty. on Assy. Comp.",ProcUnit."Qty. on Assy. Comp. FC");

        DemandForPeriod :=
          ProcUnit."Qty. on Sales Order" + ProcUnit."Additional Demand" +
          ProcUnit."Qty. on Component Lines" + ProcUnit."Qty. on Service Order" +
          ProcUnit."Qty. on Assy. Comp." + ProcUnit."Qty. on Assy. Comp. FC";
      END ELSE
        DemandForPeriod :=
          ProcUnit."Qty. on Sales Order" + ProcUnit."Additional Demand" + ProcUnit."Qty. on Service Order";
      EXIT(DemandForPeriod);
    END;

    PROCEDURE CalcPurchOrders@1240030026(ProcUnit@1240030001 : Record 14000555;PeriodsToForecast@1240030000 : Integer);
    VAR
      i@1240020000 : Integer;
    BEGIN
      CLEAR(PurchOrders);
      GetSetup;
      ProcUnit.SETFILTER("Location Filter",GetLocationFilter(ProcUnit,SingleLocation));
      i := 1;
      REPEAT
        IF i = 1 THEN
          ProcUnit.SETRANGE("Date Filter",0D,ForPeriodEndDate[i])
        ELSE
          ProcUnit.SETRANGE("Date Filter",ForPeriodDate[i],ForPeriodEndDate[i]);
        IF ProcUnit."Summarize Variant Detail" THEN BEGIN
          ProcUnit.CALCFIELDS("Qty. on Purchase Order Sum.","Qty. on Vend. Ret. Order Sum.");
          ProcUnit."Qty. on Purchase Order" := ProcUnit."Qty. on Purchase Order Sum.";
          ProcUnit."Qty. on Vend. Return Order" := ProcUnit."Qty. on Vend. Ret. Order Sum.";
        END ELSE
          ProcUnit.CALCFIELDS("Qty. on Purchase Order","Qty. on Vend. Return Order");
          PurchOrders[i] := ProcUnit."Qty. on Purchase Order" - ProcUnit."Qty. on Vend. Return Order";
        i := i + 1;
      UNTIL i > AdvForSetup."Periods to Calculate";
    END;

    PROCEDURE CalcConsumed@1240030015(ProcUnit@1240020002 : Record 14000555;PeriodsToForecast@1240020003 : Integer);
    VAR
      CompConsumedFilter@1000 : Text[250];
      i@1240020000 : Integer;
    BEGIN
      CLEAR(Consumed);
      i := 1;
      REPEAT
        Consumed[i] := CalcConsumedForPeriod(ProcUnit, ForPeriodDate[i],ForPeriodEndDate[i]);
        IF Consumed[i] < 0 THEN
          Consumed[i] := 0;
        i := i + 1;
      UNTIL i > AdvForSetup."Periods to Calculate";
    END;

    PROCEDURE CalcConsumedForPeriod@1240020018(VAR ProcUnit@1240020003 : Record 14000555;CurrStartDate@1240020001 : Date;CurrEndDate@1240020000 : Date) ConsumedForPeriod : Decimal;
    VAR
      CompConsumedFilter@1000 : Text[250];
    BEGIN
      ConsumedForPeriod := 0;
      GetSetup;
      IF InvMgtSetup."Roll Up Via Repl. Path" THEN BEGIN
        IF AdvForSetup."Exclude Usage on Nonstock Unit" THEN
          ProcUnit.SETFILTER("Location Filter",GetUsageLocationFilter(ProcUnit,FALSE))
        ELSE
          ProcUnit.SETFILTER("Location Filter",GetLocationFilter(ProcUnit,FALSE));
        IF GblCalcSingleLocForecast THEN
          ProcUnit.SETFILTER("Location Filter", GetLocationFilter(ProcUnit,TRUE));
      END ELSE
        ProcUnit.SETFILTER("Location Filter",GetLocationFilter(ProcUnit,SingleLocation));

      IF InvMgtSetup."Consider Neg. Adj. as Usage" THEN BEGIN
        CompConsumedFilter := FORMAT(ProcUnit."Comp. Consumed Option Filter"::"Negative Adjmt.") + '|';
      END;

      IF InvMgtSetup."Consider Comp. Cons. as Usage" THEN BEGIN
        CompConsumedFilter += FORMAT(ProcUnit."Comp. Consumed Option Filter"::Consumption) + '|' +
          FORMAT(ProcUnit."Comp. Consumed Option Filter"::"Assembly Consumption");
      END;

      IF (InvMgtSetup."Consider Neg. Adj. as Usage" OR InvMgtSetup."Consider Comp. Cons. as Usage") THEN BEGIN
        CompConsumedFilter := DELCHR(CompConsumedFilter, '>', '|');
      END;

      ProcUnit.SETRANGE("Date Filter",CurrStartDate, CurrEndDate);

      IF (InvMgtSetup."Consider Neg. Adj. as Usage" OR InvMgtSetup."Consider Comp. Cons. as Usage") THEN BEGIN
        ProcUnit.SETFILTER("Comp. Consumed Option Filter", CompConsumedFilter);
      END;

      IF ProcUnit."Summarize Variant Detail" THEN BEGIN
        ProcUnit.CALCFIELDS("Qty. Shipped Sum.","Qty. Comp. Consumed Sum.");
        ProcUnit."Qty. Shipped" := ProcUnit."Qty. Shipped Sum.";
        ProcUnit."Qty. Comp. Consumed" := ProcUnit."Qty. Comp. Consumed Sum.";
      END ELSE
        ProcUnit.CALCFIELDS("Qty. Shipped",ProcUnit."Qty. Comp. Consumed");

      IF InvMgtSetup."Consider Neg. Adj. as Usage" OR InvMgtSetup."Consider Comp. Cons. as Usage" THEN
        ConsumedForPeriod := ProcUnit."Qty. Shipped" + ProcUnit."Qty. Comp. Consumed"
      ELSE
        ConsumedForPeriod := ProcUnit."Qty. Shipped";
    END;

    PROCEDURE CalcInventory@1240030024(ProcUnit@1240030001 : Record 14000555;PeriodsToForecast@1240030000 : Integer);
    VAR
      i@1240020000 : Integer;
    BEGIN
      GetSetup;
      ProcUnit.SETFILTER("Location Filter",GetLocationFilter(ProcUnit,SingleLocation));

      IF ProcUnit."Summarize Variant Detail" THEN BEGIN
        ProcUnit.CALCFIELDS("Inventory Sum.");
        ProcUnit.Inventory := ProcUnit."Inventory Sum.";
      END ELSE
        ProcUnit.CALCFIELDS(Inventory);
      i := 1;
      REPEAT
        CurrInventory[i] := ProcUnit.Inventory;
        i := i + 1;
      UNTIL i > AdvForSetup."Periods to Calculate";
    END;

    PROCEDURE CalcNetTransfers@1240030025(ProcUnit@1240030001 : Record 14000555;PeriodsToForecast@1240030000 : Integer);
    VAR
      i@1240020000 : Integer;
    BEGIN
      GetSetup;
      CLEAR(NetTransfers);
      ProcUnit.SETFILTER("Location Filter",GetLocationFilter(ProcUnit,SingleLocation));
      i := 1;
      REPEAT
        IF i = 1 THEN
          ProcUnit.SETRANGE("Date Filter",0D,ForPeriodEndDate[i])
        ELSE
          ProcUnit.SETRANGE("Date Filter",ForPeriodDate[i],ForPeriodEndDate[i]);
        IF ProcUnit."Summarize Variant Detail" THEN BEGIN
          ProcUnit.CALCFIELDS("Qty. on Transfer Out Sum.","Qty. on Transfer In Sum.");
          ProcUnit."Qty. on Transfer Out" := ProcUnit."Qty. on Transfer Out Sum.";
          ProcUnit."Qty. on Transfer In" := ProcUnit."Qty. on Transfer In Sum.";
        END ELSE
          ProcUnit.CALCFIELDS("Qty. on Transfer Out","Qty. on Transfer In");
        NetTransfers[i] := ProcUnit."Qty. on Transfer In" - ProcUnit."Qty. on Transfer Out";
        i := i + 1;
      UNTIL i > AdvForSetup."Periods to Calculate";
    END;

    PROCEDURE CalcPriorYear@1240030029(ProcUnit@1240030001 : Record 14000555;PeriodsToForecast@1240030000 : Integer);
    VAR
      PriorYearEndDateFilter@1240020000 : Date;
      i@1240020001 : Integer;
      UsageLedgerEntry@1000000000 : Record 14000556;
      EntryTypeFilter@1000000001 : Text[100];
      UsageQuantity@1000000002 : Decimal;
      TransferQuantity@1000000003 : Decimal;
    BEGIN
      GetSetup;
      UsageLedgerEntry.RESET;
      UsageLedgerEntry.SETCURRENTKEY(
        "Location Code","Item No.","Variant Code","Entry Type","Exclude from Usage",
        "Drop Shipment",Nonstock,"Usage Date","Transfer Out","Replenishment Path Transfer","Source No.");
      UsageLedgerEntry.SETFILTER("Location Code",GetLocationFilter(ProcUnit,FALSE));
      UsageLedgerEntry.SETRANGE("Item No.",ProcUnit."Item No.");
      UsageLedgerEntry.SETRANGE("Variant Code",ProcUnit."Variant Code");
      UsageLedgerEntry.SETRANGE("Exclude from Usage",FALSE);
      IF NOT ProcUnit."Include Drop Ship Usage" THEN
        UsageLedgerEntry.SETRANGE("Drop Shipment",FALSE);

      i := 1;
      REPEAT
        EntryTypeFilter := FORMAT(UsageLedgerEntry."Entry Type"::Sale);
        IF InvMgtSetup."Consider Neg. Adj. as Usage" THEN
          EntryTypeFilter := EntryTypeFilter + '|' + FORMAT(UsageLedgerEntry."Entry Type"::"Negative Adjmt.");
        IF InvMgtSetup."Consider Comp. Cons. as Usage" THEN BEGIN
          EntryTypeFilter := EntryTypeFilter + '|' + FORMAT(UsageLedgerEntry."Entry Type"::Consumption);
          EntryTypeFilter := EntryTypeFilter + '|' + FORMAT(UsageLedgerEntry."Entry Type"::"Assembly Consumption");
        END;

        PriorYearEndDateFilter := CALCDATE('<-1Y>', ForPeriodEndDate[i]);
        IF (DATE2DMY(PriorYearEndDateFilter, 2) = 2) THEN BEGIN
          IF UBP.IsLeapYear(PriorYearEndDateFilter) THEN
            PriorYearEndDateFilter := CALCDATE('<+1D>',PriorYearEndDateFilter);
        END;

        UsageLedgerEntry.SETFILTER("Entry Type",EntryTypeFilter);
        UsageLedgerEntry.SETRANGE("Usage Date",CALCDATE('<-1Y>',ForPeriodDate[i]),PriorYearEndDateFilter);
        UsageLedgerEntry.CALCSUMS(Quantity);
        UsageQuantity := UsageLedgerEntry.Quantity;

        IF NOT InvMgtSetup."Roll Up Via Repl. Path" THEN BEGIN
          UsageLedgerEntry.SETRANGE("Entry Type",UsageLedgerEntry."Entry Type"::Transfer);
          UsageLedgerEntry.SETRANGE("Replenishment Path Transfer",TRUE);
          UsageLedgerEntry.SETRANGE("Transfer Out",TRUE);
          UsageLedgerEntry.CALCSUMS(Quantity);
          TransferQuantity := UsageLedgerEntry.Quantity;
          UsageLedgerEntry.SETRANGE("Replenishment Path Transfer");
          UsageLedgerEntry.SETRANGE("Transfer Out");
        END ELSE
          TransferQuantity := 0;
        PriorYearUsage[i] := - (UsageQuantity + TransferQuantity + PriorYearAdjUsage[i]);
        i := i + 1;
      UNTIL (i > AdvForSetup."Periods to Calculate") OR
            (ForPeriodDate[i] = 0D);
    END;

    PROCEDURE CalcProdOrders@1240030017(ProcUnit@1240030001 : Record 14000555;PeriodsToForecast@1240030000 : Integer);
    VAR
      i@1240020000 : Integer;
    BEGIN
      GetSetup;
      CLEAR(ProdOrders);
      ProcUnit.SETFILTER("Location Filter",GetLocationFilter(ProcUnit,SingleLocation));
      ProcUnit.SETFILTER("Prod. Order Status Filter",UBP.GetProductionStatusFilter);
      i := 1;
      REPEAT
        IF i = 1 THEN
          ProcUnit.SETRANGE("Date Filter",0D,ForPeriodEndDate[i])
        ELSE
          ProcUnit.SETRANGE("Date Filter",ForPeriodDate[i],ForPeriodEndDate[i]);

        IF ProcUnit."Summarize Variant Detail" THEN BEGIN
          ProcUnit.CALCFIELDS("Qty. on Prod. Order Sum.");
          ProcUnit."Qty. on Prod. Order" := ProcUnit."Qty. on Prod. Order Sum.";
        END ELSE
          ProcUnit.CALCFIELDS("Qty. on Prod. Order","Qty. on Assy. Order",ProcUnit."Qty. on Assy. Order FC");

        ProdOrders[i] := ProcUnit."Qty. on Prod. Order" + ProcUnit."Qty. on Assy. Order" + ProcUnit."Qty. on Assy. Order FC";
        i := i + 1;
      UNTIL i > AdvForSetup."Periods to Calculate";
    END;

    PROCEDURE CalcComp@1240030018(ProcUnit@1240030001 : Record 14000555;PeriodsToForecast@1240030000 : Integer);
    VAR
      i@1240020000 : Integer;
    BEGIN
      GetSetup;
      CLEAR(Comp);
      ProcUnit.SETFILTER("Location Filter",GetLocationFilter(ProcUnit,SingleLocation));

      IF InvMgtSetup."Consider Comp. Cons. as Usage" THEN
        EXIT;

      i := 1;
      ProcUnit.SETFILTER("Prod. Order Status Filter",ProdStatFilter);
      REPEAT
        IF i = 1 THEN
          ProcUnit.SETRANGE("Date Filter",0D,ForPeriodEndDate[i])
        ELSE
          ProcUnit.SETRANGE("Date Filter",ForPeriodDate[i],ForPeriodEndDate[i]);
        IF ProcUnit."Summarize Variant Detail" THEN BEGIN
          ProcUnit.CALCFIELDS("Qty. on Component Lines Sum.","Qty. on Assy. Comp.",
          ProcUnit."Qty. on Assy. Comp. FC");
          ProcUnit."Qty. on Component Lines" := ProcUnit."Qty. on Component Lines Sum.";
        END ELSE
          ProcUnit.CALCFIELDS("Qty. on Component Lines",ProcUnit."Qty. on Assy. Comp.","Qty. on Assy. Comp. FC");
        Comp[i] := ProcUnit."Qty. on Component Lines" + ProcUnit."Qty. on Assy. Comp." + ProcUnit."Qty. on Assy. Comp. FC";
        i := i + 1;
      UNTIL i > AdvForSetup."Periods to Calculate";
    END;

    PROCEDURE CalcForecastAdj@1240030038(VAR CurrProcUnit@1240030001 : Record 14000555;PeriodsToForecast@1240030002 : Integer) ForcAdjFound : Boolean;
    VAR
      ForecastAdj@1240030000 : Record 14002707;
      i@1240020000 : Integer;
      ForAdjQty@1240020001 : Decimal;
    BEGIN
      GetSetup;
      ForcAdjFound := FALSE;
      GblFrozenForecast := FALSE;
      CLEAR(ForecastAdj);

      ForecastAdj.RESET;
      ForecastAdj.SETCURRENTKEY("Item No.","Variant Code","Location Code","Starting Date");
      ForecastAdj.SETRANGE("Item No.",CurrProcUnit."Item No.");
      IF NOT CurrProcUnit."Summarize Variant Detail" THEN
        ForecastAdj.SETRANGE("Variant Code",CurrProcUnit."Variant Code");

      ForecastAdj.SETFILTER("Location Code",GetUsageLocationFilter(CurrProcUnit,TRUE));
      ForecastAdj.SETFILTER("Starting Date",'%1..',ForPeriodDate[1]);

      // include or ignore frozen forecast adjust
      // to calculate the statistical we must ignore frozen forecast adjust
      IF NOT ForecastAdj.ISEMPTY THEN BEGIN
        ForcAdjFound := TRUE;

      IF UseCalcPeriods THEN BEGIN
        i := 1;
        REPEAT
          ForAdjQty := 0;
          ForecastAdj.SETFILTER("Starting Date",'%1..%2',ForCalcPeriodDate[i],ForCalcPeriodEndDate[i]);
          IF NOT IgnoreFrozenForecastAdjust THEN BEGIN
            ForecastAdj.SETRANGE("Frozen Forecast", TRUE);
            IF (ForecastAdj.FINDFIRST) THEN BEGIN
              GblFrozenForecast := TRUE;
              ForAdjQty := ForecastAdj.Quantity;
              ForCalcUsageArray[i] := 0;
            END;
          END;

          ForecastAdj.SETRANGE("Frozen Forecast", FALSE);
          ForecastAdj.CALCSUMS(Quantity);
          ForAdjQty := ForAdjQty + ForecastAdj.Quantity;
          ForAdj[i] := ForAdjQty;

          IF CalledFromCalcMinSOQ AND (GblHorizonPer <> 0) THEN
            IF i <= GblHorizonPer THEN
              IF ForAdj[i] <> 0 THEN
                GblForcAdjFound := TRUE;

          i := i + 1;
        UNTIL i > AdvForSetup."Periods to Calculate";
      END ELSE BEGIN
        // system by default always uses calc periods
        // changing to forecast may require summing the forzen forecasts over each calc period
        i := 1;
        REPEAT
          ForAdjQty := 0;
          ForecastAdj.SETFILTER("Starting Date",'%1..%2',ForPeriodDate[i],ForPeriodEndDate[i]);
          IF NOT IgnoreFrozenForecastAdjust THEN BEGIN
            ForecastAdj.SETRANGE("Frozen Forecast", TRUE);
            IF (ForecastAdj.FINDSET) THEN BEGIN
              GblFrozenForecast := TRUE;
              REPEAT
                ForAdjQty := ForAdjQty + ForecastAdj.Quantity;
              UNTIL ForecastAdj.NEXT = 0;
              ForUsageArray[i] := 0;
            END;
          END;
          // ELSE BEGIN
            ForecastAdj.SETRANGE("Frozen Forecast", FALSE);
          ForecastAdj.CALCSUMS(Quantity);
          ForAdjQty := ForAdjQty + ForecastAdj.Quantity;
          ForAdj[i] := ForAdjQty;

          IF CalledFromCalcMinSOQ AND (GblHorizonPer <> 0) THEN
            IF i <= GblHorizonPer THEN
              IF ForAdj[i] <> 0 THEN
                GblForcAdjFound := TRUE;

          i := i + 1;
        UNTIL i > AdvForSetup."Periods to Calculate";
        END;
      END;
      EXIT(ForcAdjFound);
    END;

    PROCEDURE CalcFrozenUsage@1240030050(CurrProcUnit@1240030000 : Record 14000555);
    VAR
      i@1240020000 : Integer;
    BEGIN
      CLEAR(FrozenUsageArray);
      CLEAR(FrozenDailyUsageArray);
      IF (CurrProcUnit."Frozen Usage per Day" <> 0) AND
         (CurrProcUnit."Frozen Usage Expiration Date" >= WORKDATE)
      THEN BEGIN
        IF UseCalcPeriods THEN BEGIN
          FOR i := 1 TO AdvForSetup."Periods to Calculate" DO BEGIN
            IF CurrProcUnit."Frozen Usage Expiration Date" >= ForCalcPeriodEndDate[i] THEN BEGIN
              ForCalcUsageArray[i] := CurrProcUnit."Frozen Usage per Day" * ForCalcPeriodDays[i];
              ForCalcDailyUsageArray[i] := CurrProcUnit."Frozen Usage per Day";
              ForDailyUsageArrayNoFCAdjust[i] := CurrProcUnit."Frozen Usage per Day";
              FrozenUsageArray[i] := ForCalcUsageArray[i];
              FrozenDailyUsageArray[i] := ForCalcDailyUsageArray[i];
              ForecastSource := ForecastSource::"Frozen Forecast";

              IF CalledFromCalcMinSOQ AND (GblHorizonPer <> 0) THEN
                IF i <= GblHorizonPer THEN
                  IF FrozenUsageArray[i] <> 0 THEN
                    GblFrozenUsageFound := TRUE;

            END;
          END;
        END ELSE BEGIN
          FOR i := 1 TO AdvForSetup."Periods to Forecast" DO BEGIN
            IF CurrProcUnit."Frozen Usage Expiration Date" >= ForPeriodEndDate[i] THEN BEGIN
              ForUsageArray[i] := CurrProcUnit."Frozen Usage per Day" * ForPeriodDays[i];
              ForDailyUsageArray[i] := CurrProcUnit."Frozen Usage per Day";
              ForDailyUsageArrayNoFCAdjust[i] := CurrProcUnit."Frozen Usage per Day";
              FrozenUsageArray[i] := ForUsageArray[i];
              FrozenDailyUsageArray[i] := ForDailyUsageArray[i];
              ForecastSource := ForecastSource::"Frozen Forecast";

              IF CalledFromCalcMinSOQ AND (GblHorizonPer <> 0) THEN
                IF i <= GblHorizonPer THEN
                  IF FrozenUsageArray[i] <> 0 THEN
                    GblFrozenUsageFound := TRUE;
            END;
          END;
        END;
      END;
    END;

    PROCEDURE GetPeriodStartingDate@1240030003(Period@1240030000 : Integer) StartingDate@1240030001 : Date;
    BEGIN
      EXIT(ForPeriodDate[Period]);
    END;

    PROCEDURE GetPeriodEndingDate@1240030033(Period@1240030000 : Integer) EndingDate@1240030001 : Date;
    BEGIN
      EXIT(ForPeriodEndDate[Period]);
    END;

    PROCEDURE GetPeriodDays@1240030031(Period@1240030000 : Integer) PeriodDays@1240030001 : Integer;
    BEGIN
      EXIT(ForPeriodDays[Period]);
    END;

    PROCEDURE GetPeriodForecastUsage@1240030001(Period@1240030000 : Integer) Usage@1240030001 : Decimal;
    BEGIN
      EXIT(ForUsageArray[Period]);
    END;

    PROCEDURE GetDailyForecastUsage@1240030006(Period@1240030000 : Integer) DailyUsage@1240030001 : Decimal;
    BEGIN
      EXIT(ForDailyUsageArray[Period]);
    END;

    PROCEDURE GetCustForecastUsage@1240030007(Period@1240030000 : Integer) CustForUage@1240030001 : Decimal;
    BEGIN
      EXIT(ForCustUsageArray[Period]);
    END;

    PROCEDURE GetCustDailyForecastUsage@1240030008(Period@1240030000 : Integer) CustDailyForUsage@1240030001 : Decimal;
    VAR
      Text000@1240030002 : TextConst 'ENU=The lead time horizon date can not be more than 12 periods after the last closed inventory period.';
    BEGIN
      GetSetup;
      IF Period > AdvForSetup."Periods to Calculate" THEN
        EXIT(0);
      IF ForPeriodDays[Period] <> 0 THEN
        EXIT((ForCustUsageArray[Period] + GetAutoForcAdjustment(Period)) / ForPeriodDays[Period]);
    END;

    PROCEDURE GetTotUsage@1240030011(Period@1240030000 : Integer) TotUsage@1240030001 : Decimal;
    BEGIN
      EXIT(ForUsageArray[Period] + ForCustUsageArray[Period]);
    END;

    PROCEDURE GetTotDailyUsage@1240030012(Period@1240030000 : Integer) TotDailyUsage@1240030001 : Decimal;
    BEGIN
      EXIT(ForDailyUsageArray[Period] + ForCustDailyUsageArray[Period]);
    END;

    PROCEDURE GetInvPlusExpRec@1240030014(Period@1240030000 : Integer) InvPlusExpRec2@1240030001 : Decimal;
    BEGIN
      EXIT(InvPlusExpRec[Period]);
    END;

    PROCEDURE GetDemand@1240030044(Period@1240030000 : Decimal) DemandResp : Decimal;
    BEGIN
      EXIT(Demand[Period]);
    END;

    PROCEDURE GetConsumed@1240030043(Period@1240030000 : Integer) ConsumedResp : Decimal;
    BEGIN
      EXIT(Consumed[Period]);
    END;

    PROCEDURE GetAutoForcAdjustment@1240030019(Period@1240030000 : Integer) ForcAdjustment@1240030001 : Decimal;
    VAR
      ProRatedAdj@1240030005 : Decimal;
      RemainingDays@1240030002 : Integer;
      UnderForecast@1240030003 : Decimal;
      UsagePerDay@1240030004 : Decimal;
      DaysIntoPer@1240020000 : Integer;
      Per1Adj@1240020001 : Decimal;
      CurrForecastUsage@1000 : Decimal;
      FCAdjPerHorizon@1240020002 : Boolean;
      HorizonPer@1240020003 : Integer;
      TotConsumedLTH@1240020004 : Decimal;
      TotDemandLTH@1240020005 : Decimal;
      ForecastLTH@1240020006 : Decimal;
      PeriodForecastPerDay@1240020007 : Decimal;
      j@1240020008 : Integer;
    BEGIN
      EXIT(ForAutoAdj[Period]);
    END;

    PROCEDURE CalcAutoForcAdjustment@1240020014(VAR CurrProcUnit@1240020000 : Record 14000555;CurrHorizon@1240020001 : Date);
    VAR
      HorizonPer@1240020003 : Integer;
      i@1240020009 : Integer;
      PeriodsToCalculate@1240020010 : Integer;
      StartPeriod@1240020011 : Integer;
    BEGIN
      CLEAR(ForAutoAdj);
      GetSetup;
      IF UseCalcPeriods THEN
        PeriodsToCalculate := AdvForSetup."Periods to Calculate"
      ELSE
        PeriodsToCalculate := AdvForSetup."Periods to Forecast";
      IF CurrHorizon <= WORKDATE THEN
        CurrHorizon := WORKDATE;
      IF (AdvForSetup."Auto Forcast Adj. Option" = AdvForSetup."Auto Forcast Adj. Option"::Period)
        OR (AdvForSetup."Auto Forcast Adj. Option" = AdvForSetup."Auto Forcast Adj. Option"::"Period and LTH") THEN BEGIN
        StartPeriod := 1;
        FOR i := StartPeriod TO PeriodsToCalculate DO BEGIN
          ForAutoAdj[i] := CalcAutoForcAdjustmentByPeriod(i);
        END;
      END ELSE BEGIN
        StartPeriod := GetLeadTimeHorizPeriod(CurrHorizon);
        HorizonPer := StartPeriod;
        FOR i := StartPeriod TO PeriodsToCalculate DO BEGIN
          IF i > HorizonPer THEN BEGIN
            ForAutoAdj[i] := CalcAutoForcAdjustmentByPeriod(i);
          END ELSE BEGIN
            CalcAutoForcAdjustmentByHorizon(CurrProcUnit,CurrHorizon,ForAutoAdj);
          END;
        END;
      END;
    END;

    PROCEDURE CalcAutoForcAdjustmentByHorizon@1240020009(VAR CurrProcUnit@1240020010 : Record 14000555;CurrHorizon@1240020009 : Date;VAR CurrForAutoAdj@1240020020 : ARRAY [200] OF Decimal) ForcAdjustment@1240030001 : Decimal;
    VAR
      RemainingDays@1240030002 : Integer;
      DaysIntoPer@1240020000 : Integer;
      TotConsumedLTH@1240020004 : Decimal;
      TotDemandLTH@1240020005 : Decimal;
      ForecastLTH@1240020006 : Decimal;
      TotForecastHorizPeriod@1240020003 : Decimal;
      AdditionalForecastLTH@1240020002 : Decimal;
      PeriodForecastPerDay@1240020007 : ARRAY [200] OF Decimal;
      j@1240020008 : Integer;
      UnderForPerPeriod@1240020013 : ARRAY [200] OF Decimal;
      AdditionalFCPerPeriod@1240020017 : ARRAY [200] OF Decimal;
      ForecastPeriodMethodLTH@1240020018 : Decimal;
      ForecastPerPeriod@1240020019 : ARRAY [200] OF Decimal;
      HorizonPer@1240020001 : Integer;
    BEGIN
      ForcAdjustment := 0;
      CLEAR(PeriodForecastPerDay);
      CLEAR(ForecastPerPeriod);
      CLEAR(UnderForPerPeriod);
      CLEAR(AdditionalFCPerPeriod);
      DaysIntoPer := 0;
      ForecastLTH := 0;
      ForecastPeriodMethodLTH := 0;
      GetSetup;
      // calculate demand over horizon
      TotDemandLTH := CalcDemandForPeriod(CurrProcUnit, 0D, CurrHorizon);
      TotConsumedLTH := CalcConsumedForPeriod(CurrProcUnit, ForPeriodDate[1], CurrHorizon);
      HorizonPer := GetLeadTimeHorizPeriod(CurrHorizon);

      // calculate forecast LTH
      FOR j := 1 TO HorizonPer DO BEGIN
        ForecastPerPeriod[j] := (ForUsageArray[j] + ForAdj[j] + ForCustUsageArray[j]);
        TotForecastHorizPeriod := TotForecastHorizPeriod  + ForecastPerPeriod[j];
        IF ForPeriodDays[j] > 0 THEN
          PeriodForecastPerDay[j] := (ForecastPerPeriod[j]) / ForPeriodDays[j];

        IF CurrHorizon > ForPeriodEndDate[j] THEN BEGIN
          ForecastLTH := ForecastLTH + (ForUsageArray[j] + ForAdj[j] + ForCustUsageArray[j]);
        END ELSE BEGIN
          IF UseCalcPeriods THEN
            DaysIntoPer := (CurrHorizon - ForCalcPeriodDate[j]) + 1
          ELSE
            DaysIntoPer := (CurrHorizon - ForPeriodDate[j]) + 1;
          ForecastLTH := ForecastLTH + (PeriodForecastPerDay[j] * DaysIntoPer);
        END;
      END;

      IF ((TotConsumedLTH + TotDemandLTH) > ForecastLTH) THEN BEGIN

        IF ((Location."Auto. Forecast Adj. %" > 0) AND (NOT GblCalcSingleLocForecast)) THEN BEGIN
          IF (TotConsumedLTH + TotDemandLTH) > TotForecastHorizPeriod THEN
            AdditionalForecastLTH := ((ForecastLTH * Location."Auto. Forecast Adj. %") / 100);
        END;

        ForcAdjustment :=
          ((TotConsumedLTH + TotDemandLTH) -
          (ForecastLTH)) + AdditionalForecastLTH;

        CurrForAutoAdj[HorizonPer] := ForcAdjustment;

      END;

      IF ForcAdjustment < 0 THEN
        ForcAdjustment := 0;
      EXIT(ForcAdjustment);
    END;

    PROCEDURE CalcAutoForcAdjustmentByPeriod@1240020013(Period@1240030000 : Integer) ForcAdjustment2@1240030001 : Decimal;
    VAR
      ProRatedAdj@1240030005 : Decimal;
      RemainingDays@1240030002 : Integer;
      UnderForecast@1240030003 : Decimal;
      UsagePerDay@1240030004 : Decimal;
      DaysIntoPer@1240020000 : Integer;
      Per1Adj@1240020001 : Decimal;
      CurrForecastUsage@1000 : Decimal;
    BEGIN
      UnderForecast := 0;
      UsagePerDay := 0;
      RemainingDays := 0;
      DaysIntoPer := 0;
      ProRatedAdj := 0;
      GetSetup;
      IF (AdvForSetup."Prorate Per. 1 Before Cons.") AND
         (Period = 1) AND
         (NOT NonStockUnit) AND
         ((Consumed[Period] + Demand[Period]) < (ForUsageArray[Period] + ForAdj[Period] + ForCustUsageArray[Period]))
      THEN BEGIN
        IF UseCalcPeriods THEN BEGIN
          DaysIntoPer := (WORKDATE - ForCalcPeriodDate[Period]) + 1;
        END ELSE BEGIN
          DaysIntoPer := (WORKDATE - ForPeriodDate[Period]) + 1;
        END;

        IF (DaysIntoPer > AdvForSetup."Prorate Forc. Adj. Min. Days") THEN BEGIN
          CurrForecastUsage := 0;
          ProRatedAdj := 0;
          RemainingDays := ForPeriodDays[Period] - DaysIntoPer;
          IF ForPeriodDays[Period] > 0 THEN
            UsagePerDay := (ForUsageArray[Period] + ForAdj[Period] + ForCustUsageArray[Period]) / ForPeriodDays[Period];
          CurrForecastUsage := DaysIntoPer * UsagePerDay;
          UnderForecast := (Consumed[Period] + Demand[Period]) - (CurrForecastUsage);
          IF (UnderForecast > 0) THEN BEGIN
            Per1Adj := UnderForecast + ProRatedAdj;
            Per1Adj := ROUND(Per1Adj,0.1);
            EXIT(Per1Adj);
          END;
        END;
      END;

      IF (Consumed[Period] + Demand[Period]) >
         (ForUsageArray[Period] + ForAdj[Period] + ForCustUsageArray[Period])
      THEN BEGIN
         IF ForPeriodDays[Period] > 0 THEN
           UsagePerDay := ((ForUsageArray[Period] + ForAdj[Period] + ForCustUsageArray[Period]) / ForPeriodDays[Period]);
         RemainingDays := 0;
         IF (WORKDATE <= ForPeriodEndDate[Period]) AND
            (WORKDATE >= ForPeriodDate[Period])
         THEN
           RemainingDays := ForPeriodEndDate[Period] - WORKDATE;
         IF (WORKDATE <= ForPeriodEndDate[Period]) AND
            (WORKDATE < ForPeriodDate[Period])
         THEN
           RemainingDays := (ForPeriodEndDate[Period] - ForPeriodDate[Period]) + 1;
         UnderForecast :=
           (Consumed[Period] + Demand[Period]) -
           (ForUsageArray[Period] + ForAdj[Period] + ForCustUsageArray[Period]);
         IF (RemainingDays = 0) OR
            (Location."Auto. Forecast Adj. %" = 0) OR
            (GblCalcSingleLocForecast)
         THEN
           EXIT(UnderForecast)
         ELSE BEGIN
           ProRatedAdj := ((UsagePerDay * Location."Auto. Forecast Adj. %") / 100) * RemainingDays;
           EXIT(ROUND(ProRatedAdj + UnderForecast,0.1));
         END;
      END ELSE
        EXIT(0);
    END;

    PROCEDURE CalcAutoForcAdjustmentByHorizonInsidePeriod@1240020016(VAR CurrProcUnit@1240020010 : Record 14000555;PeriodStartDate@1240020002 : Date;CurrHorizon@1240020009 : Date) ForcAdjustment@1240030001 : Decimal;
    VAR
      RemainingDays@1240030002 : Integer;
      DaysIntoPer@1240020000 : Integer;
      TotConsumedLTH@1240020004 : Decimal;
      TotDemandLTH@1240020005 : Decimal;
      ForecastLTH@1240020006 : Decimal;
      PeriodForecastPerDay@1240020007 : ARRAY [200] OF Decimal;
      j@1240020008 : Integer;
      UnderForPerPeriod@1240020013 : ARRAY [200] OF Decimal;
      AdditionalFCPerPeriod@1240020017 : ARRAY [200] OF Decimal;
      ForecastPerPeriod@1240020019 : ARRAY [200] OF Decimal;
      HorizonPer@1240020001 : Integer;
    BEGIN
      // AdvForSetup."Auto Forcast Adj. Option"::"Period and LTH
      ForcAdjustment := 0;
      CLEAR(PeriodForecastPerDay);
      CLEAR(ForecastPerPeriod);
      CLEAR(UnderForPerPeriod);
      CLEAR(AdditionalFCPerPeriod);
      DaysIntoPer := 0;
      ForecastLTH := 0;
      GetSetup;

      TotDemandLTH := CalcDemandForPeriod(CurrProcUnit, PeriodStartDate, CurrHorizon); // demand until horizon
      HorizonPer := GetLeadTimeHorizPeriod(CurrHorizon);
      TotConsumedLTH := CalcConsumedForPeriod(CurrProcUnit, ForPeriodDate[HorizonPer], CurrHorizon); // consumed only inside LTH period

      // calculate forecast LTH
      j := HorizonPer;
      ForecastPerPeriod[j] := (ForUsageArray[j] + ForAdj[j] + ForCustUsageArray[j]);
      IF ForPeriodDays[j] > 0 THEN
        PeriodForecastPerDay[j] := (ForecastPerPeriod[j]) / ForPeriodDays[j];
      IF CurrHorizon > ForPeriodEndDate[j] THEN BEGIN
        ForecastLTH := ForecastLTH + (ForUsageArray[j] + ForAdj[j] + ForCustUsageArray[j]);
      END ELSE BEGIN
        IF UseCalcPeriods THEN
          DaysIntoPer := (CurrHorizon - ForCalcPeriodDate[j]) + 1
        ELSE
          DaysIntoPer := (CurrHorizon - ForPeriodDate[j]) + 1;
        ForecastLTH := ForecastLTH + (PeriodForecastPerDay[j] * DaysIntoPer);
      END;


      IF ((TotConsumedLTH + TotDemandLTH) > ForecastLTH)
      THEN BEGIN

        IF (WORKDATE <= ForPeriodEndDate[j]) AND (WORKDATE >= ForPeriodDate[j]) THEN BEGIN
          RemainingDays := ForPeriodEndDate[j] - WORKDATE;
        END ELSE BEGIN
          RemainingDays := (ForPeriodEndDate[j] - ForPeriodDate[j]) + 1;
        END;


        IF (RemainingDays > 0) OR
            ((Location."Auto. Forecast Adj. %" > 0) AND (NOT GblCalcSingleLocForecast))
          THEN BEGIN
            // only apply additonal if over the period as well
            IF (TotDemandLTH + TotConsumedLTH) > ForecastPerPeriod[j] THEN
              AdditionalFCPerPeriod[j] := ((PeriodForecastPerDay[j] * Location."Auto. Forecast Adj. %") / 100) * RemainingDays;
          END;

        IF UseCalcPeriods THEN
          DaysIntoPer := (CurrHorizon - ForCalcPeriodDate[j]) + 1
        ELSE
          DaysIntoPer := (CurrHorizon - ForPeriodDate[j]) + 1;

        ForcAdjustment :=
          ((TotConsumedLTH + TotDemandLTH) -
          (ForecastLTH)) + ((AdditionalFCPerPeriod[j]/ForPeriodDays[j]) * DaysIntoPer);
      END;
      IF ForcAdjustment < 0 THEN
        ForcAdjustment := 0;
      EXIT(ForcAdjustment);
    END;

    PROCEDURE GetAccumForecast@1240030016(Period@1240030000 : Integer) AccumForecast@1240030001 : Decimal;
    VAR
      i@1240020000 : Integer;
      StartDate@1240020004 : Date;
      HorizonPer@1240020005 : Integer;
    BEGIN
      i := 0;
      REPEAT
        i := i + 1;
        IF i <= AdvForSetup."Periods to Calculate" THEN BEGIN
          CASE AdvForSetup."Auto Forcast Adj. Option" OF
            AdvForSetup."Auto Forcast Adj. Option"::Period :
              AccumForecast := AccumForecast + (ForUsageArray[i] + GetForecastAdj(i) + ForCustUsageArray[i] + GetAutoForcAdjustment(i)) - Consumed[i];
            AdvForSetup."Auto Forcast Adj. Option"::"Period and LTH":
            BEGIN
                AccumForecast := AccumForecast + (ForUsageArray[i] + GetForecastAdj(i) + ForCustUsageArray[i] + GetAutoForcAdjustment(i)) - Consumed[i]
            END;
            AdvForSetup."Auto Forcast Adj. Option"::"Lead Time Horizon":
              AccumForecast := AccumForecast + (ForUsageArray[i] + GetForecastAdj(i) + ForCustUsageArray[i]);
          END;
        END ELSE
          AccumForecast := 0;

        IF (AdvForSetup."Auto Forcast Adj. Option" = AdvForSetup."Auto Forcast Adj. Option"::Period)
          OR (AdvForSetup."Auto Forcast Adj. Option" = AdvForSetup."Auto Forcast Adj. Option"::"Period and LTH") THEN BEGIN
          IF AccumForecast < 0 THEN
            AccumForecast := 0;
        END;
      UNTIL (i = Period);

      // LTH Auto FC Adj
      IF (AdvForSetup."Auto Forcast Adj. Option" = AdvForSetup."Auto Forcast Adj. Option"::"Lead Time Horizon") THEN BEGIN
        AccumForecast := AccumForecast - CalcConsumedForPeriod(GblProcUnit, ForPeriodDate[1], ForPeriodEndDate[Period]);
        IF AccumForecast < 0 THEN
          AccumForecast := 0;

      END;
      // LTH Auto FC Adj

      IF AccumForecast < 0 THEN
        AccumForecast := 0;

      EXIT(AccumForecast);
    END;

    PROCEDURE GetFormulaCode@1240030002() FormulaCode@1240030000 : Code[20];
    BEGIN
      EXIT(Formula.Code);
    END;

    PROCEDURE GetTrendPercent@1240020007(VAR outNonSeasonalTrendPct@1240020000 : Decimal;VAR outSeasonalTrendPct@1240020001 : Decimal);
    BEGIN
      outNonSeasonalTrendPct := NonSeasonalTrendPct;
      outSeasonalTrendPct := SeasonalTrendPct;
    END;

    PROCEDURE GetLeadTimeHorizPeriod@1240030013(LTHorizDate@1240030000 : Date) @1240030001 : Integer;
    VAR
      i@1240020000 : Integer;
      txtCalc@1240020001 : TextConst 'ENU=Calc';
      txtForecast@1240020002 : TextConst 'ENU=Forecast';
    BEGIN
      IF LTHorizDate < ForPeriodDate[1] THEN
        EXIT(1);
      i := 0;

      IF UseCalcPeriods THEN BEGIN
      REPEAT
        i := i + 1;
          IF ForCalcPeriodDate[i] = 0D THEN
            ERROR(STRSUBSTNO(Text003,GblProcUnit."Location Code", GblProcUnit."Item No.", GblProcUnit."Variant Code", LTHorizDate,txtCalc));
        UNTIL (ForCalcPeriodDate[i] <= LTHorizDate) AND
              (ForCalcPeriodEndDate[i] >= LTHorizDate);
      END ELSE BEGIN
        REPEAT
          i := i + 1;
        IF ForPeriodDate[i] = 0D THEN
            ERROR(STRSUBSTNO(Text003,GblProcUnit."Location Code", GblProcUnit."Item No.", GblProcUnit."Variant Code", LTHorizDate,txtForecast));
      UNTIL (ForPeriodDate[i] <= LTHorizDate) AND
            (ForPeriodEndDate[i] >= LTHorizDate);
      END;
      EXIT(i);
    END;

    PROCEDURE GetTotalForecast@1240030021(Period@1240030000 : Integer) @1240030001 : Decimal;
    BEGIN
      EXIT(ForUsageArray[Period] + GetForecastAdj(Period) + ForCustUsageArray[Period] + GetAutoForcAdjustment(Period));
    END;

    PROCEDURE GetTotalForecastNoAutoFCAdj@1240020003(Period@1240030000 : Integer) @1240030001 : Decimal;
    BEGIN
      EXIT(ForUsageArray[Period] + GetForecastAdj(Period) + ForCustUsageArray[Period]);
    END;

    PROCEDURE GetTotalDailyForecast@1240030035(Period@1240030000 : Integer) : Decimal;
    BEGIN
      IF ForPeriodDays[Period] > 0 THEN
        EXIT((GetTotalForecast(Period) - GetConsumed(Period)) / ForPeriodDays[Period])
      ELSE
        EXIT(0);
    END;

    PROCEDURE GetTotalDailyForecastNoAutoFCAdj@1240020017(Period@1240030000 : Integer) : Decimal;
    BEGIN
      EXIT(GetTotalForecastNoAutoFCAdj(Period)/ ForPeriodDays[Period]);
    END;

    PROCEDURE GetInventory@1240030022(Period@1240030000 : Integer) CurrInventory2@1240030001 : Decimal;
    BEGIN
      EXIT(CurrInventory[Period]);
    END;

    PROCEDURE GetTransfers@1240030023(Period@1240030000 : Integer) NetTransfers2@1240030001 : Decimal;
    BEGIN
      EXIT(NetTransfers[Period]);
    END;

    PROCEDURE GetPurchOrders@1240030027(Period@1240030000 : Integer) PurchOrders2@1240030001 : Decimal;
    BEGIN
      EXIT(PurchOrders[Period]);
    END;

    PROCEDURE GetProdOrders@1240030020(Period@1240030000 : Integer) ProdOrders2 : Decimal;
    BEGIN
      EXIT(ProdOrders[Period]);
    END;

    PROCEDURE GetComp@1240030032(Period@1240030000 : Integer) Comp2 : Decimal;
    BEGIN
      EXIT(Comp[Period]);
    END;

    PROCEDURE GetNetInvPosition@1240030028(Period@1240030000 : Integer) NetInv : Decimal;
    VAR
      AccumTransfers@1240030002 : Decimal;
      AccumPurchOrders@1240030003 : Decimal;
      AccumProdOrders@1240030001 : Decimal;
      AccumProdComp@1240030005 : Decimal;
      x@1240030004 : Integer;
      AccumSalesReturnOrders@1000 : Decimal;
    BEGIN
      AccumTransfers := 0;
      AccumPurchOrders := 0;
      AccumProdOrders := 0;
      AccumProdComp := 0;
      AccumSalesReturnOrders := 0;

      x := 0;
      REPEAT
        x := x + 1;
        AccumTransfers := AccumTransfers + NetTransfers[x];
        AccumPurchOrders := AccumPurchOrders + PurchOrders[x];
        AccumProdOrders := AccumProdOrders + ProdOrders[x];
        AccumProdComp := AccumProdComp + Comp[x];
        AccumSalesReturnOrders := AccumSalesReturnOrders + SalesReturnOrders[x];
      UNTIL x = Period;
      IF InvMgtSetup."Consider Comp. Cons. as Usage" THEN
        NetInv :=
          (CurrInventory[Period] + AccumTransfers + AccumPurchOrders + AccumProdOrders + AccumSalesReturnOrders) -
          (GetAccumForecast(Period))
      ELSE
        NetInv :=
          (CurrInventory[Period] + AccumTransfers + AccumPurchOrders + AccumProdOrders + AccumSalesReturnOrders) -
          (AccumProdComp + GetAccumForecast(Period));
      EXIT(NetInv);
    END;

    PROCEDURE GetPriorYear@1240030030(Period@1240030000 : Integer) PriorYearUsage2@1240030001 : Decimal;
    BEGIN
      EXIT(PriorYearUsage[Period]);
    END;

    PROCEDURE GetTargetStockLevel@1240030034() Resp : Decimal;
    BEGIN
      EXIT(SporadicTargetStockLevel);
    END;

    PROCEDURE GetSetup@1240030037();
    VAR
      ProcUnit@1240030001 : Record 14000555;
    BEGIN
      IF NOT SetupAvailable THEN BEGIN
        AdvForSetup.GET;
        IF ForecastOnlyReqPeriods THEN BEGIN
          IF MaxPeriodsToForecast <> 0 THEN
            AdvForSetup."Periods to Forecast" := MaxPeriodsToForecast;
          IF MaxPeriodsToCalculate <> 0 THEN
            AdvForSetup."Periods to Calculate" := MaxPeriodsToCalculate;
        END;
        InvMgtSetup.GET;
        ProdStatFilter := UBP.GetProductionStatusFilter;
        IF ProdStatFilter <> '' THEN
          ProcUnit.SETFILTER("Prod. Order Status Filter",ProdStatFilter);
        SetupAvailable := TRUE;
      END;
    END;

    PROCEDURE GetLTHStatForecast@1240030040() Resp : Decimal;
    BEGIN
      EXIT(AccumStatForecast);
    END;

    PROCEDURE GetLTHForecast@1240030036() Resp : Decimal;
    BEGIN
      EXIT(LTHAccumForecast);
    END;

    PROCEDURE GetForecastAdj@1240030045(Period@1240030000 : Integer) Resp : Decimal;
    BEGIN
      EXIT(ForAdj[Period]);
    END;

    PROCEDURE GetLTHForecastAdj@1240030046(CurrLocationCode@1240030001 : Code[10];CurrLTHDate@1240030002 : Date) AccumForecastAdj : Decimal;
    VAR
      LocInvPeriod@1240030005 : Record 14000553;
      Finished@1240030000 : Boolean;
      i@1240020000 : Integer;
    BEGIN
      GetSetup;
      // function only called from roll-up and after calcminsoq
      IF (AdvForSetup."Auto Forcast Adj. Option" = AdvForSetup."Auto Forcast Adj. Option"::"Lead Time Horizon") THEN
        AccumForecastAdj := LTHForAutoAdj
      ELSE BEGIN
      Finished := FALSE;
      AccumForecastAdj := 0;
      i := 1;
      REPEAT
        IF i > AdvForSetup."Periods to Calculate" THEN
          ERROR(
            Text001,
            CurrLocationCode,
            '',
            '',
            CurrLTHDate,
            AdvForSetup."Periods to Calculate");
        IF CurrLTHDate > ForCalcPeriodDate[i] THEN
          AccumForecastAdj := AccumForecastAdj + GetAutoForcAdjustment(i);
        IF (CurrLTHDate >= ForCalcPeriodDate[i]) AND
           (CurrLTHDate <= ForCalcPeriodEndDate[i]) THEN
          Finished := TRUE;
        i := i + 1;
      UNTIL (i > AdvForSetup."Periods to Calculate") OR
            (Finished);
      END;

      EXIT(AccumForecastAdj);
    END;

    PROCEDURE CustForecastExists@1240030039(CurrProcUnit@1240030000 : Record 14000555;CurrStartingDate@1240030001 : Date) Resp : Boolean;
    VAR
      ForecastEntry@1240020000 : Record 14002603;
    BEGIN
      ForecastEntry.RESET;
      ForecastEntry.SETCURRENTKEY("Location Code","Item No.","Variant Code","Starting Date",Released);
      IF InvMgtSetup."Roll Up Via Repl. Path" THEN
        ForecastEntry.SETFILTER(
          "Location Code",GetUsageLocationFilter(CurrProcUnit,FALSE))
      ELSE
        ForecastEntry.SETFILTER(
          "Location Code",GetUsageLocationFilter(CurrProcUnit,SingleLocation));
      ForecastEntry.SETRANGE("Item No.",CurrProcUnit."Item No.");
      ForecastEntry.SETRANGE("Variant Code",CurrProcUnit."Variant Code");
      ForecastEntry.SETRANGE(Released,TRUE);
      ForecastEntry.SETFILTER("Starting Date",'%1..',CurrStartingDate);
      IF NOT ForecastEntry.ISEMPTY THEN
        EXIT(TRUE);
    END;

    PROCEDURE ForecastAdjustExists@1240030041(CurrProcUnit@1240030000 : Record 14000555;CurrStartingDate@1240030001 : Date) Resp : Boolean;
    VAR
      ForecastAdj@1240030002 : Record 14002707;
    BEGIN
      ForecastAdj.RESET;
      ForecastAdj.SETCURRENTKEY("Item No.","Variant Code","Location Code","Starting Date");
      ForecastAdj.SETRANGE("Item No.",CurrProcUnit."Item No.");
      IF CurrProcUnit."Summarize Variant Detail" THEN
        ForecastAdj.SETRANGE("Variant Code")
      ELSE
        ForecastAdj.SETRANGE("Variant Code",CurrProcUnit."Variant Code");

      ForecastAdj.SETFILTER(
        "Location Code",GetUsageLocationFilter(CurrProcUnit,TRUE));

      ForecastAdj.SETFILTER("Starting Date",'%1..',CurrStartingDate);
      IF NOT ForecastAdj.ISEMPTY THEN
        EXIT(TRUE);
    END;

    PROCEDURE GetLocationFilter@1240030047(CurrProcUnit@1240030000 : Record 14000555;CurrSingleLocation@1240030001 : Boolean) Resp : Text[250];
    BEGIN
      IF CurrSingleLocation THEN BEGIN
        IF LocationFilterSingle = '' THEN
          LocationFilterSingle := UBP.GetLocationFilter(CurrProcUnit,TRUE);
        EXIT(LocationFilterSingle);
      END ELSE BEGIN
        IF LocationFilter = '' THEN
          LocationFilter := UBP.GetLocationFilter(CurrProcUnit,FALSE);
        EXIT(LocationFilter);
      END;
    END;

    PROCEDURE GetUsageLocationFilter@1240030048(CurrProcUnit@1240030000 : Record 14000555;CurrSingleLocation@1240030001 : Boolean) Resp : Text[250];
    BEGIN
      IF CurrSingleLocation THEN BEGIN
        IF UsageLocationFilterSingle = '' THEN
          UsageLocationFilterSingle :=
            UBP.GetUsageLocationFilter(
              CurrProcUnit."Location Code",CurrProcUnit."Item No.",CurrProcUnit."Variant Code",TRUE);
        EXIT(UsageLocationFilterSingle);
      END ELSE BEGIN
        IF UsageLocationFilter = '' THEN
          UsageLocationFilter :=
            UBP.GetUsageLocationFilter(
              CurrProcUnit."Location Code",CurrProcUnit."Item No.",CurrProcUnit."Variant Code",FALSE);
        EXIT(UsageLocationFilter);
      END;
    END;

    PROCEDURE SetForecastOnlyReqPeriods@1240020000();
    BEGIN
      ForecastOnlyReqPeriods := TRUE;
    END;

    PROCEDURE LoadForPerWithCalcPer@1240020001();
    VAR
      CalcPeriod@1000000003 : Integer;
    BEGIN
      IF NOT UseCalcPeriods THEN
        EXIT;
      CLEAR(ForPeriodDate);
      CLEAR(ForPeriodEndDate);
      CLEAR(ForPeriodDays);
      CLEAR(ForUsageArray);
      CLEAR(ForDailyUsageArray);
      CalcPeriod := 1;
      REPEAT
        ForPeriodDate[CalcPeriod] := ForCalcPeriodDate[CalcPeriod];
        ForPeriodEndDate[CalcPeriod] := ForCalcPeriodEndDate[CalcPeriod];
        ForPeriodDays[CalcPeriod] := ForCalcPeriodDays[CalcPeriod];
        ForUsageArray[CalcPeriod] := ForCalcUsageArray[CalcPeriod];
        ForDailyUsageArray[CalcPeriod] := ForCalcDailyUsageArray[CalcPeriod];
      CalcPeriod := CalcPeriod + 1;
      UNTIL CalcPeriod > AdvForSetup."Periods to Calculate";
    END;

    PROCEDURE GetDailyForUsageNoFCAdjust@1240020004(Period@1240030000 : Integer) @1240030001 : Decimal;
    BEGIN
      EXIT(ForDailyUsageArrayNoFCAdjust[Period]);
    END;

    PROCEDURE GetSalesReturnOrders@1(Period@1240030000 : Integer) PurchOrders2@1240030001 : Decimal;
    BEGIN
      EXIT(SalesReturnOrders[Period]);
    END;

    PROCEDURE CalcSalesReturnOrders@3(ProcUnit@1240030001 : Record 14000555;PeriodsToForecast@1240030000 : Integer);
    VAR
      i@1240020000 : Integer;
    BEGIN
      GetSetup;
      IF NOT InvMgtSetup."Incl. Qty. on Sales Ret. Order" THEN
        EXIT;

      CLEAR(SalesReturnOrders);
      ProcUnit.SETFILTER("Location Filter",GetLocationFilter(ProcUnit,SingleLocation));
      i := 1;
      REPEAT
        IF i = 1 THEN
          ProcUnit.SETRANGE("Date Filter",0D,ForPeriodEndDate[i])
        ELSE
          ProcUnit.SETRANGE("Date Filter",ForPeriodDate[i],ForPeriodEndDate[i]);
        IF ProcUnit."Summarize Variant Detail" THEN BEGIN
        END ELSE
          ProcUnit.CALCFIELDS("Qty. on Sales Return Order");
        ProcUnit.CALCFIELDS("Qty. on Sales Return Order");
        SalesReturnOrders[i] := ProcUnit."Qty. on Sales Return Order";
        i := i + 1;
      UNTIL i > AdvForSetup."Periods to Calculate";
    END;

    PROCEDURE GetLTHCustForecast@1240020005() Resp : Decimal;
    BEGIN
      EXIT(AccumCustForecast);
    END;

    LOCAL PROCEDURE FindUsageForForecast@1240020010(VAR CurrProcUnit@1240020002 : Record 14000555;VAR CurrFormula@1000000000 : Record 14002652;CurrForecastPerStartingDate@1240020004 : Date;CurrSourceFilter@1240020003 : Text[250]);
    VAR
      UnusualUsageAdj@1240020001 : Record 14002658;
      j@1240020000 : Integer;
    BEGIN
      // usage for the formula calculation
      UnusualUsageAdj.SETCURRENTKEY("Location Code","Item No.","Variant Code","Starting Date","Ending Date");
      UnusualUsageAdj.ASCENDING(FALSE);
      UnusualUsageAdj.SETRANGE("Location Code",CurrProcUnit."Location Code");
      UnusualUsageAdj.SETRANGE("Item No.",CurrProcUnit."Item No.");
      UnusualUsageAdj.SETRANGE("Variant Code",CurrProcUnit."Variant Code");
      UnusualUsageAdj.SETFILTER("Starting Date",'<=%1', CurrForecastPerStartingDate);
      UnusualUsageAdj.SETFILTER("Source No.",'=%1', CurrSourceFilter);
      UnusualUsageAdj.FIND('-');
      j := 1;
      REPEAT
        IF (NOT AdvForSetup."Auto Adj. Unusual Usage") OR
           (Formula."Exclude Zero Usage Periods") OR
           ((NOT AdvForSetup."Auto. Adj. Sea. Usage") AND
            (Formula."Seasonal Formula"))
        THEN
          UsageArray[j] := UnusualUsageAdj."Period End Adjusted Usage"
        ELSE
          UsageArray[j] := UnusualUsageAdj.Usage;
        j := j + 1;
        Periods := Periods - 1;
      UNTIL (UnusualUsageAdj.NEXT = 0) OR
            (Periods = 0);
    END;

    LOCAL PROCEDURE FindSafetyStockQty@1240020011(VAR CurrProcUnit@1240020002 : Record 14000555;CurrEndingDate@1240020000 : Date) SafetyStockQty : Decimal;
    VAR
      ItemUsage@1240020001 : Record 14000557;
    BEGIN
      // not in use
      SafetyStockQty := 0;
      IF CurrProcUnit."Nonstock Unit" THEN
        EXIT(SafetyStockQty);

      IF  CurrProcUnit."Frozen Safety Expiration Date" >= WORKDATE THEN
        SafetyStockQty := CurrProcUnit."Frozen Safety Allowance %"
      ELSE BEGIN
        ItemUsage.SETCURRENTKEY("Item No.","Location Code","Variant Code","Starting Date","Ending Date");
        ItemUsage.SETRANGE("Location Code",CurrProcUnit."Location Code");
        ItemUsage.SETRANGE("Item No.",CurrProcUnit."Item No.");
        ItemUsage.SETRANGE("Variant Code",CurrProcUnit."Variant Code");
        ItemUsage.SETRANGE("Ending Date", CurrEndingDate);
        ItemUsage.SETRANGE("Source No.",'');
        IF ItemUsage.FINDFIRST THEN
          SafetyStockQty := ItemUsage."Safety Allowance Qty.";
      END;
      EXIT(SafetyStockQty);
    END;

    LOCAL PROCEDURE CalcSafetyStockQtyFromDays@1240020026(VAR CurrProcUnit@1240020002 : Record 14000555;CurrHorizonDate@1000000000 : Date;CurrForecast@1240020000 : Decimal;CurrSafetyStockDays@1240020005 : Integer) outSafetyStockQty : Decimal;
    VAR
      HorizonDays@1240020003 : Integer;
      SafetyStockPerDay@1240020004 : Decimal;
    BEGIN
      outSafetyStockQty := 0;
      IF (CurrForecast <= 0) AND (CurrSafetyStockDays <= 0) THEN
        EXIT(outSafetyStockQty);
      // For Reference - Statistical forecast only
      IF (NOT CurrProcUnit."Nonstock Unit") AND
          (CurrProcUnit."Replenishment Source Type" IN [CurrProcUnit."Replenishment Source Type"::Vendor, CurrProcUnit."Replenishment Source Type"::" "]) AND
          (CurrProcUnit."Replenishment Model" <> CurrProcUnit."Replenishment Model"::"Min/Max") THEN BEGIN

        HorizonDays := (CurrHorizonDate -  ForPeriodDate[1] ) + 1;  // if period is not closed then it cannot be from workdate
        IF HorizonDays > 0 THEN BEGIN
          SafetyStockPerDay := CurrForecast/HorizonDays;
          outSafetyStockQty := CurrSafetyStockDays * SafetyStockPerDay;
        END;
      END;
      RoundValueForForecast(CurrProcUnit, outSafetyStockQty);
      EXIT(outSafetyStockQty);
    END;

    LOCAL PROCEDURE FindUsageForSingleForecast@1240020002(VAR CurrProcUnit@1240020002 : Record 14000555;CurrForecastPerStartingDate@1240020004 : Date;CurrSourceFilter@1240020003 : Text[250]);
    VAR
      UnusualUsageAdj@1240020001 : Record 14002658;
      j@1240020000 : Integer;
    BEGIN
      // usage for the formula calculation
      UnusualUsageAdj.SETCURRENTKEY("Location Code","Item No.","Variant Code","Starting Date","Ending Date");
      UnusualUsageAdj.ASCENDING(FALSE);
      UnusualUsageAdj.SETRANGE("Location Code",CurrProcUnit."Location Code");
      UnusualUsageAdj.SETRANGE("Item No.",CurrProcUnit."Item No.");
      UnusualUsageAdj.SETRANGE("Variant Code",CurrProcUnit."Variant Code");
      UnusualUsageAdj.SETFILTER("Starting Date",'<=%1', CurrForecastPerStartingDate);
      UnusualUsageAdj.SETFILTER("Source No.",'=%1', CurrSourceFilter);
      IF UnusualUsageAdj.FIND('-') THEN BEGIN
        j := 1;
        REPEAT
          IF (NOT AdvForSetup."Auto Adj. Unusual Usage") OR
           (Formula."Exclude Zero Usage Periods") OR
           ((NOT AdvForSetup."Auto. Adj. Sea. Usage") AND
           (Formula."Seasonal Formula"))
          THEN
            UsageArray[j] := UnusualUsageAdj."Single Loc. Per. End Adj. Usg."
          ELSE
            UsageArray[j] := UnusualUsageAdj."Single Loc. Usage";
          j := j + 1;
          Periods := Periods - 1;
        UNTIL (UnusualUsageAdj.NEXT = 0) OR
              (Periods = 0);
      END;
    END;

    PROCEDURE SetOverrideForSingleLocForecast@1240020006(inSetSingleLocForecast@1240020000 : Boolean);
    BEGIN
      GblCalcSingleLocForecast := inSetSingleLocForecast;
    END;

    LOCAL PROCEDURE GetSingleLocNetAvgUsage@1240020012() : Decimal;
    BEGIN
      EXIT(SingleLocNetAverageUsage);
    END;

    LOCAL PROCEDURE CalcPromoForecastAdj@1240020030(CurrProcUnit@1240030001 : Record 14000555;StartDate@1240020000 : Date;EndDate@1240030002 : Date) : Decimal;
    VAR
      ForecastAdj@1240030000 : Record 14002707;
    BEGIN
      // promotion
      ForecastAdj.SETCURRENTKEY("Item No.","Variant Code","Location Code","Starting Date");
      ForecastAdj.SETFILTER("Location Code", UBP.GetUsageLocationFilter(CurrProcUnit."Location Code",CurrProcUnit."Item No.",CurrProcUnit."Variant Code",TRUE));
      ForecastAdj.SETRANGE("Item No.",CurrProcUnit."Item No.");
      IF CurrProcUnit."Summarize Variant Detail" THEN
        ForecastAdj.SETRANGE("Variant Code")
      ELSE
        ForecastAdj.SETRANGE("Variant Code",CurrProcUnit."Variant Code");
      ForecastAdj.SETRANGE("Starting Date", StartDate, EndDate);
      ForecastAdj.SETFILTER("Promotion Code", '<>%1', '');
      ForecastAdj.CALCSUMS(Quantity);
      EXIT(ForecastAdj.Quantity);
    END;

    PROCEDURE SetUseCalcPeriods@1240020008(CurrUseCalcPeriods@1240020000 : Boolean);
    BEGIN
      UseCalcPeriods := CurrUseCalcPeriods;
    END;

    PROCEDURE GetNetInvPosSource@1240020015() : Text[250];
    BEGIN
      NetInvPosSource := STRSUBSTNO(TextNetInvPos,GblNetInvPos) + ' ' + NetInvPosSource;
      EXIT(NetInvPosSource);
    END;

    PROCEDURE GetSafetyStockQty@1240020029() : Decimal;
    BEGIN
      EXIT(SafetyStockQty);
    END;

    PROCEDURE SetCalcProductionPlanninglines@1240020020(inCalcProductionPlanningLines@1240020000 : Boolean);
    BEGIN
      GblCalcProductionPlanningLines := inCalcProductionPlanningLines;
    END;

    PROCEDURE GetLeadTimeHorizonAutoFCAdj@1240020021() : Decimal;
    BEGIN
      EXIT(LTHForAutoAdj);
    END;

    PROCEDURE GetLeadTimeHorizonDemand@1240020024() : Decimal;
    BEGIN
      EXIT(LTHDemand);
    END;

    PROCEDURE GetLeadTimeHorizonTotalFC@1240020025(CurrHorizonPer@1240020001 : Integer;CurrHorizonDate@1240020000 : Date) TotalFC : Decimal;
    VAR
      i@1240020002 : Integer;
    BEGIN
      TotalFC := 0;
          TotalFC := LTHTotalFC;
      EXIT(TotalFC);
    END;

    PROCEDURE GetLeadTimeHorizonConsumed@1240020022() : Decimal;
    BEGIN
      EXIT(LTHConsumed);
    END;

    PROCEDURE GetSafetyStockQtyFromDays@1240020028(VAR CurrSafetyStockDays@1240020000 : Decimal) : Decimal;
    BEGIN
      CASE GblProcUnit."Safety Stock Calc. Method" OF
        GblProcUnit."Safety Stock Calc. Method"::Fixed:
        BEGIN
          IF CurrSafetyStockDays > 0 THEN
            outSafetyStockQtyfromDays := CalcSafetyStockQtyFromDays(GblProcUnit, GblLeadTimeHorizonDate, LTHAccumForecast, CurrSafetyStockDays);
        END;
        GblProcUnit."Safety Stock Calc. Method"::"Forecast Deviation":
          outSafetyStockQtyfromDays := SafetyStockQty;
      END;
      EXIT(outSafetyStockQtyfromDays);
    END;

    PROCEDURE RoundValueForDisplay@1240020031(VAR CurrValue@1240020000 : Decimal);
    BEGIN
      CASE InvMgtSetup."Item Usage Decimal Places" OF
        0:
          CurrValue := ROUND(CurrValue,1.0);
        1:
          CurrValue := ROUND(CurrValue,0.1);
        2:
          CurrValue := ROUND(CurrValue,0.01);
        3:
          CurrValue := ROUND(CurrValue,0.001);
        4:
          CurrValue := ROUND(CurrValue,0.0001);
        5:
          CurrValue := ROUND(CurrValue,0.00001);
        6:
          CurrValue := ROUND(CurrValue,0.000001);
      END;
    END;

    PROCEDURE RoundValueForForecast@1000000008(VAR CurrProcUnit@1240020003 : Record 14000555;VAR CurrValue@1240020000 : Decimal);
    VAR
      Direction@1240020001 : Code[3];
      Precision@1240020002 : Decimal;
    BEGIN
      IF CurrValue = 0 THEN
        EXIT;
      GetSetup;
      Direction := '=';
      IF (CurrValue > 0) AND (CurrValue < 1) THEN BEGIN
        CASE AdvForSetup."Small Forc. Alt. Rounding Rule" OF
          AdvForSetup."Small Forc. Alt. Rounding Rule"::Natural : Direction := '=';
          AdvForSetup."Small Forc. Alt. Rounding Rule"::"Round Up" : Direction := '>';
          AdvForSetup."Small Forc. Alt. Rounding Rule"::"Round Down" : Direction := '<';
        END;
      END ELSE BEGIN
        CASE AdvForSetup."Rounding Rule" OF
          AdvForSetup."Rounding Rule"::Natural : Direction := '=';
          AdvForSetup."Rounding Rule"::"Round Up" : Direction := '>';
          AdvForSetup."Rounding Rule"::"Round Down" : Direction := '<';
        END;
      END;
      CASE AdvForSetup."Forecast Decimal Places" OF
        0:
          Precision := 1.0;
        1:
          Precision := 0.1;
        2:
          Precision := 0.01;
        3:
          Precision := 0.001;
        4:
          Precision := 0.0001;
        5:
          Precision := 0.00001;
        ELSE
          Precision := 1.0;
      END;
      CurrValue := ROUND(CurrValue, Precision, Direction);
    END;

    PROCEDURE GetAddtionalStockQty@1000000001() : Decimal;
    BEGIN
      EXIT(AdditonalStock);
    END;

    PROCEDURE GetAverageOrderQty@1000000000() : Decimal;
    BEGIN
      EXIT(AvgOrderQty);
    END;

    LOCAL PROCEDURE CalcAdditionalStock@1000000002(VAR CurrProcUnit@1000000001 : Record 14000555) : Decimal;
    VAR
      LocProcUnit@1000000000 : Record 14000555;
    BEGIN
      // additional stock >>
      LocProcUnit.COPY(CurrProcUnit);
      LocProcUnit.SETFILTER("Location Filter", CurrProcUnit."Location Code");
      LocProcUnit.SETFILTER("Expire Date Filter",'>=%1',WORKDATE);
      IF LocProcUnit."Summarize Variant Detail" THEN BEGIN
        LocProcUnit.CALCFIELDS("Additional Stock Quantity Sum.");
        IF (LocProcUnit."Additional Stock Quantity Sum." > 0) THEN BEGIN
          AdditonalStock := LocProcUnit."Additional Stock Quantity Sum.";
        END;
      END ELSE BEGIN
        LocProcUnit.CALCFIELDS("Additional Stock Quantity");
        IF (LocProcUnit."Additional Stock Quantity" > 0) THEN BEGIN
          AdditonalStock := LocProcUnit."Additional Stock Quantity";
        END;
      END;
      RoundValueForForecast(CurrProcUnit, AdditonalStock);
      EXIT(AdditonalStock);
      // additional stock <<
    END;

    PROCEDURE CalcNetNeed@1000000004(VAR CurrProcUnit@1240030000 : Record 14000555;CurrSourceNo@1000000002 : Code[20];OverrideLTHDate@1240030015 : Date;OverrideUseCalcPeriods@1240020008 : Boolean) NetInvPos : Decimal;
    VAR
      Finished@1240030006 : Boolean;
      SafetyStockQty@1240020000 : Decimal;
      i@1240020001 : Integer;
      StartDate@1240020002 : Date;
      HorizonPer@1240020003 : Integer;
      LeadTimeHorizonDate@1000000000 : Date;
      AccumForecast@1000000001 : Decimal;
      AccumForecastNoAutoFC@1240020004 : Decimal;
      AccumAutoFC@1240020005 : Decimal;
      TempAccumForecastNoAutoFC@1240020006 : Decimal;
      TempConsumed@1240020007 : Decimal;
    BEGIN
      GblProcUnit := CurrProcUnit;
      GblMinSOQ := 0;
      GblNetInvPos := 0;
      CalledFromCalcMinSOQ := TRUE;
      GblForcAdjFound := FALSE;
      GblFrozenUsageFound := FALSE;
      GblHorizonPer := 0;
      IF OverrideUseCalcPeriods THEN
        UseCalcPeriods := FALSE
      ELSE
        UseCalcPeriods := TRUE;


      IF OverrideLTHDate = 0D THEN
        OverrideLTHDate := UBP.GetLeadTimeHoriz(CurrProcUnit);
      GetSetup;
      IF OverrideLTHDate <> 0D THEN
        LeadTimeHorizonDate := OverrideLTHDate;

      UBP.CheckMaxLTHDate(CurrProcUnit, LeadTimeHorizonDate);

      IF ForecastOnlyReqPeriods THEN
        MaxOverrideLTHDate := LeadTimeHorizonDate;

      GblLeadTimeHorizonDate := LeadTimeHorizonDate;

      CalcForecast(CurrProcUnit, AdvForSetup."Periods to Calculate", CurrSourceNo, TRUE, UseCalcPeriods);
      CalcCustForecast(CurrProcUnit, AdvForSetup."Periods to Calculate");
      CalcConsumed(CurrProcUnit, AdvForSetup."Periods to Calculate");

      IF (AdvForSetup."Auto Forcast Adj. Option" = AdvForSetup."Auto Forcast Adj. Option"::Period)
        OR (AdvForSetup."Auto Forcast Adj. Option" = AdvForSetup."Auto Forcast Adj. Option"::"Period and LTH") THEN
        CalcAutoForcAdjustment(CurrProcUnit, LeadTimeHorizonDate);

      AccumForecast := 0;
      AccumStatForecast := 0;
      AccumCustForecast := 0;
      AccumForecastNoAutoFC := 0;

      LTHDemand := 0;
      LTHAccumForecast := 0;
      LTHTotalFC := 0;
      LTHForAutoAdj := 0;
      LTHConsumed := 0;

      Finished := FALSE;

      // Accumulate Forecast and its partitions
      i := 1;
      REPEAT
        TempConsumed := 0;
        TempAccumForecastNoAutoFC := 0;
        IF LeadTimeHorizonDate > ForPeriodEndDate[i] THEN BEGIN
          // previous periods
          IF (AdvForSetup."Auto Forcast Adj. Option" = AdvForSetup."Auto Forcast Adj. Option"::Period)
            OR (AdvForSetup."Auto Forcast Adj. Option" = AdvForSetup."Auto Forcast Adj. Option"::"Period and LTH") THEN BEGIN
            AccumForecast := AccumForecast + GetTotalForecast(i);
            AccumForecast := AccumForecast - GetConsumed(i);

            TempAccumForecastNoAutoFC := GetTotalForecastNoAutoFCAdj(i);
            TempConsumed := GetConsumed(i);
            IF (TempConsumed > TempAccumForecastNoAutoFC) THEN
              TempAccumForecastNoAutoFC := 0
            ELSE
              TempAccumForecastNoAutoFC := TempAccumForecastNoAutoFC - TempConsumed;
            AccumForecastNoAutoFC := AccumForecastNoAutoFC + TempAccumForecastNoAutoFC;

          END ELSE BEGIN
            AccumForecast := AccumForecast + (GetTotalForecastNoAutoFCAdj(i)); // LTH model Consumed is calculated later together
            LTHTotalFC := AccumForecast;
          END;

          AccumStatForecast := AccumStatForecast + ForUsageArray[i];
          AccumCustForecast := AccumCustForecast + ForCustUsageArray[i];
        END ELSE BEGIN
          // current and future periods
          IF (AdvForSetup."Auto Forcast Adj. Option" = AdvForSetup."Auto Forcast Adj. Option"::Period)
            OR (AdvForSetup."Auto Forcast Adj. Option" = AdvForSetup."Auto Forcast Adj. Option"::"Period and LTH") THEN BEGIN
            //  Auto Forecast Adj Option = Period & LTH
            IF (AdvForSetup."Auto Forcast Adj. Option" = AdvForSetup."Auto Forcast Adj. Option"::"Period and LTH") THEN BEGIN
              IF (LeadTimeHorizonDate <= ForPeriodEndDate[i]) AND (LeadTimeHorizonDate >= ForPeriodDate[i]) THEN BEGIN
                // horizon period - recalculate this 1 period's forecast
                LTHTotalFC  := GetTotalDailyForecastNoAutoFCAdj(i) * (LeadTimeHorizonDate - ForPeriodDate[i] + 1);
                AccumForecast := AccumForecast + LTHTotalFC;
                LTHConsumed := CalcConsumedForPeriod(CurrProcUnit, ForPeriodDate[i], LeadTimeHorizonDate);

                // for min shelf compare - consumed is remove from gettotaldailyforecast
                TempAccumForecastNoAutoFC := LTHTotalFC;
                TempConsumed := LTHConsumed;
                IF (TempConsumed > TempAccumForecastNoAutoFC) THEN
                  TempAccumForecastNoAutoFC := 0
                ELSE
                  TempAccumForecastNoAutoFC := TempAccumForecastNoAutoFC - TempConsumed;
                AccumForecastNoAutoFC := AccumForecastNoAutoFC + TempAccumForecastNoAutoFC;

                AccumForecast := AccumForecast - LTHConsumed;
                IF i = 1 THEN
                  StartDate := 0D
                ELSE
                  StartDate := ForPeriodDate[i];
                LTHDemand := CalcDemandForPeriod(CurrProcUnit, StartDate, LeadTimeHorizonDate);
                LTHForAutoAdj := CalcAutoForcAdjustmentByHorizonInsidePeriod(CurrProcUnit, StartDate, LeadTimeHorizonDate);
                IF LTHForAutoAdj < 0 THEN
                  LTHForAutoAdj := 0;
                LTHTotalFC := LTHTotalFC + LTHForAutoAdj;
                AccumForecast := AccumForecast + LTHForAutoAdj;
              END ELSE
                // future period use auto forecast per period
                AccumForecast := AccumForecast + GetTotalDailyForecast(i) * (LeadTimeHorizonDate - ForPeriodDate[i] + 1);
            END ELSE BEGIN
              // Auto Forecast Adj Option = Period
              AccumForecast := AccumForecast + GetTotalDailyForecast(i) * (LeadTimeHorizonDate - ForPeriodDate[i] + 1);

              // for min shelf compare - consumed is remove from gettotaldailyforecast
              TempAccumForecastNoAutoFC := GetTotalDailyForecastNoAutoFCAdj(i) * (LeadTimeHorizonDate - ForPeriodDate[i] + 1);
              TempConsumed := GetConsumed(i);
              IF (TempConsumed > TempAccumForecastNoAutoFC) THEN
                TempAccumForecastNoAutoFC := 0
              ELSE
                TempAccumForecastNoAutoFC := TempAccumForecastNoAutoFC - TempConsumed;
              AccumForecastNoAutoFC := AccumForecastNoAutoFC + TempAccumForecastNoAutoFC;
            END;
          END ELSE BEGIN
            // Auto Forecast Adj. Option = LTH
            IF (LeadTimeHorizonDate <= ForPeriodEndDate[i]) AND (LeadTimeHorizonDate >= ForPeriodDate[i]) THEN BEGIN
              AccumForecast := AccumForecast + GetTotalDailyForecastNoAutoFCAdj(i) * (LeadTimeHorizonDate - ForPeriodDate[i] + 1);
              LTHTotalFC := AccumForecast;
            END ELSE
              AccumForecast := AccumForecast + (GetTotalForecast(i));
          END;

          AccumStatForecast :=
            AccumStatForecast + (ForDailyUsageArray[i] * (LeadTimeHorizonDate - ForPeriodDate[i] + 1));
          AccumCustForecast := AccumCustForecast + ForCustDailyUsageArray[i] * (LeadTimeHorizonDate - ForPeriodDate[i] + 1);
          Finished := TRUE;
        END;

        IF (AdvForSetup."Auto Forcast Adj. Option" = AdvForSetup."Auto Forcast Adj. Option"::Period)
          OR (AdvForSetup."Auto Forcast Adj. Option" = AdvForSetup."Auto Forcast Adj. Option"::"Period and LTH") THEN BEGIN
          IF AccumForecast < 0 THEN
            AccumForecast := 0;
        END;

        IF AccumStatForecast < 0 THEN
          AccumStatForecast := 0;

        IF AccumCustForecast < 0 THEN
          AccumCustForecast := 0;

        i := i + 1;

      UNTIL (i > AdvForSetup."Periods to Calculate") OR
            (Finished);


      // Auto forecast adjust full horizon method
      IF (AdvForSetup."Auto Forcast Adj. Option" = AdvForSetup."Auto Forcast Adj. Option"::"Lead Time Horizon") THEN BEGIN
        LTHDemand := CalcDemandForPeriod(CurrProcUnit, 0D, LeadTimeHorizonDate);
        // Accumforecast is not adjusted above to prevent issues with consumed over the entire period
        HorizonPer := GetLeadTimeHorizPeriod(LeadTimeHorizonDate);
        LTHConsumed := CalcConsumedForPeriod(CurrProcUnit, ForPeriodDate[1], ForPeriodEndDate[HorizonPer]);
        AccumForecast := AccumForecast - LTHConsumed;
        AccumForecastNoAutoFC := AccumForecast;
        LTHForAutoAdj := CalcAutoForcAdjustmentByHorizon(CurrProcUnit,LeadTimeHorizonDate,ForAutoAdj);
        LTHTotalFC := LTHTotalFC + LTHForAutoAdj;
        AccumForecast := AccumForecast + LTHForAutoAdj;

        IF AccumForecast < 0 THEN
          AccumForecast := 0;

        IF AccumForecast < LTHDemand THEN
          AccumForecast := LTHDemand;
      END ELSE BEGIN

        IF (AdvForSetup."Auto Forcast Adj. Option" = AdvForSetup."Auto Forcast Adj. Option"::Period) THEN BEGIN
          LTHDemand := CalcDemandForPeriod(CurrProcUnit, 0D, LeadTimeHorizonDate);
          IF AccumForecast < LTHDemand THEN
            AccumForecast := LTHDemand;
        END;
      END;

      IF AccumForecast < 0 THEN
        AccumForecast := 0;

      IF AccumForecastNoAutoFC < 0 THEN
        AccumForecastNoAutoFC := 0;

      IF LTHTotalFC < 0 THEN
        LTHTotalFC := 0;

      IF LTHTotalFC > 0 THEN
        RoundValueForForecast(CurrProcUnit, LTHTotalFC);

      IF AccumForecast > 0 THEN
        RoundValueForForecast(CurrProcUnit, AccumForecast);

      IF AccumForecastNoAutoFC > 0 THEN
        RoundValueForForecast(CurrProcUnit, AccumForecastNoAutoFC);

      IF (AccumForecastNoAutoFC <> AccumForecast) THEN BEGIN
        AccumAutoFC := AccumForecast - AccumForecastNoAutoFC;
      END;

      LTHAccumForecast := AccumForecast;

      NetInvPos := CalcNetPosition(CurrProcUnit, LeadTimeHorizonDate, AccumForecast, AccumForecastNoAutoFC, AccumAutoFC);

      GblNetInvPos := NetInvPos;
      CalledFromCalcMinSOQ := FALSE;
    END;

    PROCEDURE GetMinSOQ@1000000005() : Decimal;
    BEGIN
      // order qty from global net inv pos
      GblMinSOQ := 0;
      IF GblNetInvPos < 0 THEN
        GblMinSOQ := ABS(GblNetInvPos);
      EXIT(GblMinSOQ);
    END;

    PROCEDURE GetReplenishmentText@1000000016(VAR CurrProcUnit@1240020000 : Record 14000555) : Text;
    VAR
      Text027@1000000007 : TextConst 'ENU=Min %1 Max %2 Qty.';
      Text028@1000000006 : TextConst 'ENU=Min %1 Max %2 Days';
      Text031@1000000001 : TextConst 'ENU=Sporadic %1';
      CurrFormulaText@1000000000 : Text;
    BEGIN
      CurrFormulaText := '';
      IF CurrProcUnit."Replenishment Model" = CurrProcUnit."Replenishment Model"::"Min/Max" THEN BEGIN
        IF (CurrProcUnit."Replenishment Model" = CurrProcUnit."Replenishment Model"::"Min/Max") AND
         (CurrProcUnit."Maximum Inventory" > 0)
        THEN
           CurrFormulaText := STRSUBSTNO(Text027, CurrProcUnit."Minimum Inventory", CurrProcUnit."Maximum Inventory")
        ELSE BEGIN
          IF (SporadicTargetStockLevel <> 0) AND (NOT GblForcAdjFound) AND (NOT GblFrozenUsageFound) THEN
            CurrFormulaText := STRSUBSTNO(Text031, SporadicTargetStockLevel)
          ELSE
            CurrFormulaText := STRSUBSTNO(Text028, CurrProcUnit."Minimum Days Supply", CurrProcUnit."Maximum Days Supply") + ' ' + Formula.Code;
        END;
      END ELSE BEGIN
        IF (SporadicTargetStockLevel <> 0) AND (NOT GblForcAdjFound) AND (NOT GblFrozenUsageFound) THEN
          CurrFormulaText := STRSUBSTNO(Text031, SporadicTargetStockLevel)
        ELSE BEGIN
          CurrFormulaText := Formula.Code;
        END;
      END;
      EXIT(CurrFormulaText);
    END;

    PROCEDURE GetTrendText@1000000017() : Text;
    VAR
      Text023@1000000011 : TextConst 'ENU=No Trend';
      Text024@1000000010 : TextConst 'ENU=Non Sea.';
      Text025@1000000009 : TextConst 'ENU=Sea.';
      Text027@1000000007 : TextConst 'ENU=Min %1 Max %2 Qty.';
      Text028@1000000006 : TextConst 'ENU=Min %1 Max %2 Days';
      Text031@1000000001 : TextConst 'ENU=Sporadic %1';
      CurrTrendText@1000000002 : Text;
    BEGIN
      CurrTrendText := Text023;
      IF NonSeasonalTrendPct <> 0 THEN
        CurrTrendText := Text024 + ' ' + FORMAT(ROUND(NonSeasonalTrendPct,0.1)) + '%';
      IF SeasonalTrendPct <> 0 THEN
        CurrTrendText := Text025 + ' ' + FORMAT(ROUND(SeasonalTrendPct,0.1)) + '%';
      EXIT(CurrTrendText);
    END;

    LOCAL PROCEDURE CalcNetPosition@1240020041(VAR CurrProcUnit@1240020000 : Record 14000555;CurrHorizonDate@1240020001 : Date;CurrForecast@1240020004 : Decimal;CurrForecastNoAutoAdj@1240020003 : Decimal;CurrAutoForcAdjust@1240020005 : Decimal) NetInvPos : Decimal;
    VAR
      InvExp@1240020002 : Decimal;
      AdditionalStockQty@1000000001 : Decimal;
      QtyExp@1000000002 : Decimal;
      QtyAdjustmentSource@1240020006 : Text;
      NewForecast@1240020007 : Decimal;
      AdjNetInvPos@1240020008 : Decimal;
      txtSafetyStockQty@1240020009 : TextConst 'ENU=Safety Qty %1';
      SafetyStockQtyTemp@1240020010 : Decimal;
      DemandExp@1240020011 : Decimal;
      TempNetInvPos@1240020012 : Decimal;
      txtSporadicTargetStockLevel@1240020013 : TextConst 'ENU=Sporadic Qty %1';
    BEGIN
      NetInvPosSource := '';
      InvExp := CalcNetExpectedInventoryB4Forecast(CurrProcUnit, CurrHorizonDate, QtyExp, DemandExp);
      // inventory position information and forecast before static quantity adjustment

      IF (GblForcAdjFound) OR (GblFrozenUsageFound) THEN BEGIN
          SporadicTargetStockLevel := 0;
          SporadicTargetStockLevelForRollUp := 0;
      END;

      IF (CurrProcUnit."Safety Stock Calc. Method" <> CurrProcUnit."Safety Stock Calc. Method"::"Forecast Deviation") THEN
          SafetyStockQty := 0;

      IF UseSurplusFactor OR UseExcessFactor THEN BEGIN
        SetSurplusFactorAdjustment(CurrProcUnit, Location);
      END;

      // safety stock is applied after since it may be zerod
      IF (CurrProcUnit."Safety Stock Calc. Method" = CurrProcUnit."Safety Stock Calc. Method"::"Forecast Deviation") THEN BEGIN
          TempNetInvPos := InvExp - CurrForecast - SporadicTargetStockLevel - SafetyStockQty;
      END ELSE
          TempNetInvPos := InvExp - CurrForecast - SporadicTargetStockLevel;

      NewForecast := AdjustForecastForStockLevel(CurrProcUnit, CurrHorizonDate, CurrForecastNoAutoAdj, CurrAutoForcAdjust, InvExp, QtyExp, QtyAdjustmentSource);  // adjust for fixed qty calculations


      IF (CurrProcUnit."Safety Stock Calc. Method" = CurrProcUnit."Safety Stock Calc. Method"::"Forecast Deviation") THEN
          AdjNetInvPos := InvExp - DemandExp - NewForecast - SafetyStockQty - SporadicTargetStockLevel
      ELSE
          AdjNetInvPos := InvExp - DemandExp - NewForecast - SporadicTargetStockLevel;

      // if forecast was adjusted
      IF (CurrForecastNoAutoAdj < NewForecast) AND (AdjNetInvPos < TempNetInvPos) THEN BEGIN
          // calculate net after fixed quantity adjustment
          NetInvPosSource := STRSUBSTNO(TextInvExp, InvExp);
          NetInvPosSource := NetInvPosSource + ' ' + TextMinus;
          NetInvPosSource := NetInvPosSource + ' ' + STRSUBSTNO(TextTotForecastBegin, DemandExp + NewForecast + SafetyStockQty + SporadicTargetStockLevel);
          IF (DemandExp > 0) THEN
              NetInvPosSource := NetInvPosSource + ' ' + STRSUBSTNO(txtDemandExp, DemandExp);

          IF (SafetyStockQty) > 0 THEN BEGIN
            IF (DemandExp > 0) THEN
              NetInvPosSource := NetInvPosSource + ' ';
            NetInvPosSource := NetInvPosSource + STRSUBSTNO(txtSafetyStockQty, SafetyStockQty);
          END;

          IF (SporadicTargetStockLevel) > 0 THEN BEGIN
            IF (DemandExp > 0) OR (SafetyStockQty > 0) THEN
              NetInvPosSource := NetInvPosSource + ' ';
            NetInvPosSource := NetInvPosSource +  STRSUBSTNO(txtSporadicTargetStockLevel, SporadicTargetStockLevel);
          END;

          IF (DemandExp > 0) OR (SafetyStockQty > 0) OR (SporadicTargetStockLevel > 0) THEN
            NetInvPosSource := NetInvPosSource + ' ';

          NetInvPosSource := NetInvPosSource + QtyAdjustmentSource + ' ' + FORMAT((NewForecast));
          NetInvPosSource := NetInvPosSource + TextTotForecastEnd;
          NetInvPos := AdjNetInvPos;
      END ELSE BEGIN
          NetInvPosSource := STRSUBSTNO(TextInvExp, InvExp);
          NetInvPosSource := NetInvPosSource + ' ' + TextMinus + ' ';
          NetInvPosSource := NetInvPosSource + ' ' + STRSUBSTNO(TextTotForecastBegin, CurrForecast + SafetyStockQty + SporadicTargetStockLevel);

          IF CurrForecast > 0 THEN
              NetInvPosSource := NetInvPosSource + STRSUBSTNO(TextForecast, CurrForecast);

          IF (SafetyStockQty) > 0 THEN BEGIN
            IF (CurrForecast > 0) THEN
              NetInvPosSource := NetInvPosSource + ' ';
            NetInvPosSource := NetInvPosSource + STRSUBSTNO(txtSafetyStockQty, SafetyStockQty);
          END;

          IF (SporadicTargetStockLevel) > 0 THEN BEGIN
            IF (CurrForecast > 0) OR (SafetyStockQty > 0) THEN
              NetInvPosSource := NetInvPosSource + ' ';
            NetInvPosSource := NetInvPosSource + STRSUBSTNO(txtSporadicTargetStockLevel, SporadicTargetStockLevel);
          END;

          NetInvPosSource := NetInvPosSource + TextTotForecastEnd;
          NetInvPos := TempNetInvPos;
      END;


      // Additional stock is not additional forecast
      // Additonal Stock Qty >>
      AdditionalStockQty := CalcAdditionalStock(CurrProcUnit);
      IF (AdditionalStockQty > 0) THEN BEGIN
          NetInvPos := NetInvPos - AdditionalStockQty;
          NetInvPosSource := NetInvPosSource + ' ' + STRSUBSTNO(TextAddStock, AdditionalStockQty);
      END;
      // Additonal Stock Qty <<
      EXIT(NetInvPos);
    END;

    LOCAL PROCEDURE CalcNetExpectedInventoryB4Forecast@1240020040(VAR CurrProcUnit@1240020000 : Record 14000555;CurrHorizonDate@1240020001 : Date;VAR CurrQtyExp@1240020003 : Decimal;VAR CurrDemandExp@1240020004 : Decimal) NetInvPos : Decimal;
    VAR
      InvExp@1240020002 : Decimal;
    BEGIN
      // Calculate Net Expected Inventory

      NetInvPos := 0;
      CurrProcUnit.SETFILTER("Location Filter", GetLocationFilter(CurrProcUnit,SingleLocation));
      CurrProcUnit.SETFILTER("Date Filter",'..%1', CurrHorizonDate);
      CurrProcUnit.SETFILTER("Expire Date Filter", '>=%1', WORKDATE);
      CurrProcUnit.SETFILTER("Prod. Order Status Filter", UBP.GetProductionStatusFilter);
      InvExp := CurrProcUnit.QtyInvPlusExpRec;  // qty plus expected receipt

      // execution of production plan - simulated orders not yet created output entries
      IF GblCalcProductionPlanningLines THEN BEGIN
        IF CurrProcUnit."Summarize Variant Detail" THEN BEGIN
          CurrProcUnit.CALCFIELDS("Qty. on Prod. Plan Sum.");
          CurrProcUnit."Qty. on Prod. Plan" := CurrProcUnit."Qty. on Prod. Plan Sum.";
        END ELSE
          CurrProcUnit.CALCFIELDS("Qty. on Prod. Plan");
        InvExp := InvExp + CurrProcUnit."Qty. on Prod. Plan";
      END;

      IF InvMgtSetup."Consider Comp. Cons. as Usage" THEN BEGIN
        CurrDemandExp := (CurrProcUnit."Qty. on Sales Order" + CurrProcUnit."Additional Demand" +
              CurrProcUnit."Qty. on Component Lines" + CurrProcUnit."Qty. on Service Order" +
              CurrProcUnit."Qty. on Assy. Comp. FC" + CurrProcUnit."Qty. on Assy. Comp.");
      END ELSE BEGIN
        InvExp := InvExp - CurrProcUnit."Qty. on Component Lines" -
            CurrProcUnit."Qty. on Assy. Comp. FC" - CurrProcUnit."Qty. on Assy. Comp.";

        CurrDemandExp := (CurrProcUnit."Qty. on Sales Order" + CurrProcUnit."Additional Demand" +
               + CurrProcUnit."Qty. on Service Order");
      END;

      CurrQtyExp := InvExp - CurrDemandExp;

      NetInvPos := InvExp;

      EXIT(NetInvPos);
    END;

    LOCAL PROCEDURE AdjustForecastForStockLevel@1000000003(VAR CurrProcUnit@1240020001 : Record 14000555;CurrHorizonDate@1000000000 : Date;VAR CurrForecast@1000000001 : Decimal;CurrAutoForecastAdj@1240020000 : Decimal;CurrInvExp@1000000006 : Decimal;CurrQtyExp@1240020002 : Decimal;VAR QtyAdjustmentSource@1240020003 : Text) NewForecast : Decimal;
    VAR
      HorizonDays@1000000002 : Integer;
      MinDays@1000000008 : Integer;
      MinQty@1000000003 : Decimal;
      MaxQty@1000000004 : Decimal;
      RemainingDays@1000000009 : Integer;
      txtMinMaxQty@1000000013 : TextConst 'ENU=Min %1 Max %2 Qty';
      txtMinMaxDays@1000000014 : TextConst 'ENU=Min %1 Max %2 Qty for Days';
      txtSafetyStockQty@1000000015 : TextConst 'ENU=Safety Qty';
      txtMinShelf@1000000010 : TextConst 'ENU=Min Shelf';
      txtSporadic@1000000011 : TextConst 'ENU=Sporadic Stock';
      txtMinPresentation@1000000012 : TextConst 'ENU=Stock Item';
      ForecastToCompare@1240020004 : Decimal;
    BEGIN
      // treating min shelf as min demand / min forecast
      // non-stock - no mn adjustments
      IF CurrProcUnit."Nonstock Unit" THEN BEGIN
        QtyAdjustmentSource := '';
        EXIT;
      END;

      // min/max qty - no min demand
      IF (CurrProcUnit."Replenishment Model" = CurrProcUnit."Replenishment Model"::"Min/Max") THEN BEGIN
        IF (CurrProcUnit."Maximum Inventory" <> 0) OR
            ((CurrProcUnit."Maximum Inventory" = 0) AND
            (CurrProcUnit."Minimum Inventory" = 0) AND
            (CurrProcUnit."Minimum Days Supply" = 0) AND
            (CurrProcUnit."Maximum Days Supply" = 0)) THEN BEGIN
              IF (CurrProcUnit."Minimum Inventory" > CurrQtyExp) THEN BEGIN
                MinQty := CurrProcUnit."Minimum Inventory";
                MaxQty := CurrProcUnit."Maximum Inventory";
                QtyAdjustmentSource := STRSUBSTNO(txtMinMaxQty, FORMAT(MinQty), FORMAT(MaxQty));
                NewForecast := MaxQty;
                SafetyStockQty := 0;
                SporadicTargetStockLevel := 0;
                SporadicTargetStockLevelForRollUp := 0;
                EXIT(NewForecast);
              END;
            END;
      END;

      IF (CurrProcUnit."Safety Stock Calc. Method" <> CurrProcUnit."Safety Stock Calc. Method"::"Forecast Deviation") THEN
          SafetyStockQty := 0;

      // total forecast includes sat + collaborative + sporadic + safetystockqty
      ForecastToCompare := CurrForecast + SporadicTargetStockLevel + SafetyStockQty;

      IF (CurrProcUnit."Minimum Shelf Stock" > ForecastToCompare) AND (NewForecast < CurrProcUnit."Minimum Shelf Stock") THEN BEGIN
        NewForecast := CurrProcUnit."Minimum Shelf Stock";
        QtyAdjustmentSource := STRSUBSTNO(txtMinShelf, CurrProcUnit."Minimum Shelf Stock");
        SafetyStockQty := 0;
        SporadicTargetStockLevel := 0;
      END;

      IF (Location."Min. Presentation Qty." > ForecastToCompare) AND (NewForecast < Location."Min. Presentation Qty.") THEN BEGIN
        NewForecast := Location."Min. Presentation Qty.";
        QtyAdjustmentSource := STRSUBSTNO(txtMinPresentation, Location."Min. Presentation Qty.");
        SafetyStockQty := 0;
        SporadicTargetStockLevel := 0;
      END;

      // Avg Order Qty >> not implemented
      //    IF (CurrProcUnit."Minimum Shelf Stock" < AvgOrderQty) AND (AvgOrderQty > 0) THEN BEGIN
      //      CurrProcUnit."Minimum Shelf Stock" := AvgOrderQty;
      //      QtyAdjustmentSource := 'Avg. Order'
      //    END;
      // Avg Order Qty << not implemented

      RoundValueForForecast(CurrProcUnit, NewForecast);

      EXIT(NewForecast);
    END;

    PROCEDURE SetIgnoreFrozenForcAdjust@1240020045(inSetIgnoreFrozenForcAdjust@1240020000 : Boolean);
    BEGIN
      IgnoreFrozenForecastAdjust := inSetIgnoreFrozenForcAdjust;
    END;

    PROCEDURE GetForcastErrorPct@1240020033() : Decimal;
    BEGIN
      EXIT(ForcastErrorPct);
    END;

    PROCEDURE GetFrozenForecast@1240020037() : Boolean;
    BEGIN
      EXIT(GblFrozenForecast);
    END;

    PROCEDURE GetFrozenUsage@1240020023() : Boolean;
    BEGIN
      EXIT(GblFrozenUsageFound);
    END;

    PROCEDURE SetUseSurplusFactor@1240020027(inUseSurplusFactor@1240020002 : Boolean);
    BEGIN
      UseSurplusFactor := inUseSurplusFactor;
    END;

    PROCEDURE SetUseExcessFactor@1240020048(inUseExcessFactor@1240020000 : Boolean);
    BEGIN
      UseExcessFactor := inUseExcessFactor;
    END;

    LOCAL PROCEDURE SetSurplusFactorAdjustment@1240020032(VAR CurrProcUnit@1240020000 : Record 14000555;VAR CurrLocation@1240020005 : Record 14) SurplusFactorAdj : Decimal;
    VAR
      ReqQty@1240020001 : Decimal;
      SurplusPct@1240020002 : Decimal;
      SurplusReqQty@1240020003 : Decimal;
      ExcessReqQty@1240020004 : Decimal;
    BEGIN
      ReqQty := SporadicTargetStockLevel;
      IF (CurrProcUnit."Replenishment Model" = CurrProcUnit."Replenishment Model"::"Min/Max") AND
        (CurrProcUnit."Maximum Inventory" <> 0)
        THEN
          ReqQty := CurrProcUnit."Maximum Inventory";

      SurplusFactorAdj := ReqQty;

      CASE CurrProcUnit."Replenishment Source Type" OF
        CurrProcUnit."Replenishment Source Type"::Vendor,
        CurrProcUnit."Replenishment Source Type"::Production,
        CurrProcUnit."Replenishment Source Type"::Assembly:
        BEGIN
          SurplusPct := (CurrLocation."Vend. Surplus Calc. Add Pct." / 100);
        END;
        CurrProcUnit."Replenishment Source Type"::Location:
        BEGIN
          SurplusPct := (CurrLocation."Loc. Surplus Calc. Add Pct." / 100);
        END;
      END;

      IF SurplusPct < 0 THEN
        SurplusPct := 0;

      SurplusReqQty := ROUND(ReqQty + (ReqQty * SurplusPct),1.0);
      IF UseExcessFactor THEN BEGIN
        ExcessReqQty := (SurplusReqQty + (ReqQty * (GetExcessPct(CurrProcUnit) / 100)));
        SurplusFactorAdj := ExcessReqQty;
      END ELSE
        SurplusFactorAdj := SurplusReqQty;

      RoundValueForForecast(CurrProcUnit, SurplusFactorAdj);

      IF (CurrProcUnit."Replenishment Model" = CurrProcUnit."Replenishment Model"::"Min/Max") AND
        (CurrProcUnit."Maximum Inventory" <> 0)
      THEN BEGIN
          CurrProcUnit."Maximum Inventory" := SurplusFactorAdj;
          CurrProcUnit."Minimum Inventory" := SurplusFactorAdj;
      END ELSE
        SporadicTargetStockLevel := SurplusFactorAdj;
      EXIT(SurplusFactorAdj);
    END;

    LOCAL PROCEDURE GetExcessPct@1240020035(CurrProcUnit@1240020000 : Record 14000555) ExcessPct : Decimal;
    VAR
      InvPostGroup@1240020002 : Record 94;
      ItemCategory@1240020001 : Record 5722;
      Item@1240020003 : Record 27;
    BEGIN
      ExcessPct := InvMgtSetup."Default Excess Calc. Percent";
      Item.GET(CurrProcUnit."Item No.");
      CASE InvMgtSetup."Excess Definition" OF
        DATABASE::"Inventory Posting Group":
          BEGIN
            IF Item."Inventory Posting Group" <> '' THEN
              IF InvPostGroup.Code <> Item."Inventory Posting Group" THEN
                IF InvPostGroup.GET(Item."Inventory Posting Group") THEN
                  IF InvPostGroup."Excess Calc. Percent" <> 0 THEN
                    ExcessPct := InvPostGroup."Excess Calc. Percent";
          END;
        DATABASE::"Item Category":
          BEGIN
            IF Item."Item Category Code" <> '' THEN
              IF ItemCategory.Code <> Item."Item Category Code" THEN
                IF ItemCategory.GET(Item."Item Category Code") THEN
                  IF ItemCategory."Excess Calc. Percent" <> 0 THEN
                    ExcessPct := ItemCategory."Excess Calc. Percent";
          END;
      END;
      EXIT(ExcessPct);
    END;

    PROCEDURE GetTargetStockLevelForRollUp@2() Resp : Decimal;
    BEGIN
      EXIT(SporadicTargetStockLevelForRollUp);
    END;

    PROCEDURE GetForecastOnly@1240020034(CurrPeriod@1240020000 : Integer) : Decimal;
    BEGIN
      EXIT(ForUsageArray[CurrPeriod]);
    END;

    BEGIN
    {
            2019-08-13 TPZ2590 UCHOUHAN
              Added new function GetForecastonly.
    }
    END.
  }
}

